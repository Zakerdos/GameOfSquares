<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=800, initial-scale=1.0" />
  <title>A Game of Squares</title>
  <style>
	html, body {
	  overflow: hidden;    /* Prevents scrollbars from appearing */
	  touch-action: none;  /* Disables default touch actions like scrolling and zooming */
	}
    body {
      margin: 0;
      background-color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Title Styles */
    #title {
      text-align: center;
      margin-top: 20px;
      margin-bottom: 10px;
      width: 800px;
    }
    #titleTop {
      color: grey;
      font-size: 24px;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    #titleBottom {
      color: white;
      font-size: 48px;
      font-weight: bold;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    /* HUD Container */
    #hudContainer {
      width: 800px;
      background-color: #333;
      border-radius: 8px;
      padding: 5px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: Arial, sans-serif;
	  position: relative;
    }
	#hudTriangles {
	  position: absolute;
	  right: 180px;  /* adjust this value as needed so it sits nicely between Level and High Score */
	  top: 50%;
	  transform: translateY(-50%);
	  display: flex;
	  gap: 10px;  /* gap between triangles */
	}
	.triangle.green {
	  box-shadow: none;
	}
	.triangle.blue {
	  box-shadow: none;
	}
	.triangle.purple {
	  box-shadow: none;
	}	

	/* Creating an equilateral triangle pointing upward. */
	.triangle {
	  width: 41px; /* approximates the base of an equilateral triangle with 35px height */
	  height: 35px;
	  background-color: #202020;
	  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
	  box-shadow: inset -10px -5px 5px rgba(0, 0, 0, 0.5); /* adjust shadow as needed */
	}
    /* HUD elements */
    .hud-label {
      color: grey;
      font-size: 20px;
    }
    /* Lives: Fixed blue circle that stays the same size */
    #hudLife {
      background-color: blue;
      color: white;
      font-size: 20px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 5px;
    }
    /* Center HUD */
    #hudLevel {
      color: white;
      font-size: 26px;
      font-weight: bold;
      margin: 0 2px 0 0;
    }
    /* Level progression */
    #hudLevelProg {
      background-color: green;
      color: white;
      font-size: 16px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 2px;
      display: inline-block;
      position: relative;
    }
    /* The tiny indicator inside the green circle */
    #hudorbIndicator {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background-color: grey;
      border-radius: 50%;
    }
    /* High Score: fixed width for the number */
    #hudHighScore {
      color: white;
      font-size: 20px;
      font-weight: bold;
      width: 30px;
      text-align: center;
      display: inline-block;
      margin-left: 1px;
    }
    /* Containers for left, center, and right parts */
    #hudLeft, #hudCenter, #hudRight {
      display: flex;
      align-items: center;
    }
    /* Game container and canvas */
    #gameContainer {
      position: relative;
      width: 800px;
      height: 600px;
      margin-top: 10px;
    }
    canvas {
      background-color: #111;
      display: block;
    }
    /* Overlay for in-canvas messages */
    #messageOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: Arial, sans-serif;
      font-size: 48px;
      font-weight: bold;
      z-index: 5;
      pointer-events: none;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      text-align: center;
    }
	#bottomBar {
	  width: 800px;
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  font-family: Arial, sans-serif;
	  font-size: 12px;
	  margin-top: 2px;
	}

	#debugModeIndicator {
	  text-align: left;
	  color: blue;
	}

	#devVersion {
	  text-align: right;
	  color: #2a2a2a;
	}
	.glow {
	  animation: glowEffect 1s infinite alternate;
	}
	
	.frozen {
	  position: relative;
	  background-color: rgba(19, 200, 207, 0.5); /* ICE_COLOUR with 50% transparency */
	  pointer-events: none; /* Prevents interaction while frozen */
	  z-index: 10; /* Ensures it sits on top of the square */
	}

	.frozen::before {
	  content: '';
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  bottom: 0;
	  background-color: rgba(19, 200, 207, 0.5); /* Icy overlay */
	  pointer-events: none; /* Ensures overlay doesn't block interactions */
	}	

	@keyframes glowEffect {
	  from {
		filter: brightness(1);
	  }
	  to {
		filter: brightness(1.5);
	  }
	}
  </style>
</head>
<body>
  <div id="title">
    <div id="titleTop">Dave Longhurst presents</div>
    <div id="titleBottom">A Game of Squares</div>
  </div>
	<div id="hudContainer">
	  <div id="hudLeft">
		<span class="hud-label">Lives:</span>
		<span id="hudLife">1</span>
	  </div>
	  <div id="hudCenter">
		<span id="hudLevel">Level 1</span>
		<span id="hudLevelProg">0/5
		  <div id="hudorbIndicator"></div>
		</span>
	  </div>
	  <div id="hudTriangles">
		<div class="triangle"></div>
		<div class="triangle"></div>
		<div class="triangle"></div>
	  </div>
	  <div id="hudRight">
		<span class="hud-label">High Score:</span>
		<span id="hudHighScore">1</span>
	  </div>
	</div>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="messageOverlay"></div>
  </div>
  <div id="bottomBar">
    <div id="debugModeIndicator"></div>
    <div id="devVersion">v1.4.6</div>
  </div>
  <script>
    let debug = 0;
	if (debug) {
	  document.getElementById("debugModeIndicator").textContent = "Debug Mode";
	} else {
	  document.getElementById("debugModeIndicator").textContent = "";
	}
	
	// Click HUD triangles
	if (debug) {
	  const triangles = document.querySelectorAll("#hudTriangles .triangle");
	  if (triangles.length >= 3) {
		// Left triangle toggles hasTriGreen
		triangles[0].addEventListener("click", () => {
		  hasTriGreen = hasTriGreen === 1 ? 0 : 1;
		  hasGreenArrow = hasGreenArrow === 1 ? 0 : 1;
		  triHud();
		});
		// Middle triangle toggles hasTriBlue
		triangles[1].addEventListener("click", () => {
		  hasTriBlue = hasTriBlue === 1 ? 0 : 1;
		  triHud();
		});
		// Right triangle toggles hasTriPurple
		triangles[2].addEventListener("click", () => {
		  hasTriPurple = hasTriPurple === 1 ? 0 : 1;
		  triHud();
		});
	  }
	}

	function drawTriPower() {
	  // Draw each triangle only if it's active
	  drawTriObj(triGreen, "green");
	  drawTriObj(triBlue, "blue");
	  drawTriObj(triPurple, PURPLE_COLOUR);
	}

	function drawTriObj(tri, activeColor) {
	  // Only draw the triangle if it is active.
	  if (!tri.active) return;
	  
	  ctx.save();
	  // For active triangles, fill with the active color and use no shadow.
	  ctx.shadowColor = "transparent";
	  ctx.fillStyle = activeColor;
	  
	  // Draw an upward pointing triangle.
	  // Assume tri.x and tri.y are the top-left of a square that bounds the triangle.
	  let x = tri.x;
	  let y = tri.y;
	  let width = tri.width || 41;
	  let height = tri.height || 35;
		  
	  ctx.beginPath();
	  // Mimic the HUD clip-path: polygon (50% 0%, 0% 100%, 100% 100%)
	  ctx.moveTo(x + width / 2, y);       // Top vertex at the middle of the top edge.
	  ctx.lineTo(x, y + height);          // Bottom left vertex.
	  ctx.lineTo(x + width, y + height);  // Bottom right vertex.
	  ctx.closePath();
	  ctx.fill();
	  
	  ctx.restore();
	}

	// TriGreen Collision with player
	function checkTriGreenCollision() {
	  // Only perform the check if triGreen is active.
	  if (!triGreen.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triGreen area.
	  if (player.x < triGreen.x + triangleWidth &&
		  player.x + player.size > triGreen.x &&
		  player.y < triGreen.y + triangleHeight &&
		  player.y + player.size > triGreen.y) {
		// When collision occurs, remove triGreen and set hasTriGreen.
		triGreen.active = false;
		hasTriGreen = 1;
	  }
	}
	// TriBlue Collision with player
	function checkTriBlueCollision() {
	  // Only perform the check if triBlue is active.
	  if (!triBlue.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triBlue area.
	  if (player.x < triBlue.x + triangleWidth &&
		  player.x + player.size > triBlue.x &&
		  player.y < triBlue.y + triangleHeight &&
		  player.y + player.size > triBlue.y) {
		// When collision occurs, remove triBlue and set hasTriBlue.
		triBlue.active = false;
		hasTriBlue = 1;
	  }
	}
	// Player collision with TriPurple
	function checkTriPurpleCollision() {
	  // Only perform the check if triPurple is active.
	  if (!triPurple.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triPurple area.
	  if (player.x < triPurple.x + triangleWidth &&
		  player.x + player.size > triPurple.x &&
		  player.y < triPurple.y + triangleHeight &&
		  player.y + player.size > triPurple.y) {
		// When collision occurs, remove triPurple and set hasTriPurple.
		triPurple.active = false;
		hasTriPurple = 1;
		nextLevel();		
	  }
	}

    let highScore = 1;
	// Load saved values from localStorage (default to 0 if not found)
	highScore = localStorage.getItem("highScore") ? parseInt(localStorage.getItem("highScore")) : 1;
	
    let gameOverPrompted = false;
    const PURPLE_COLOUR = "#7F00FF";
    const FLASH_COLOUR = "#c78fff";	
    const ICE_COLOUR = "#13c8cf";
	const DARK_PURPLE = "#4B0082"; 
    let purpleorbUsed = false;
    
    // Use fixed shield rings (up to 3).
    let shieldRings = [];
    // Flag to prevent awarding multiple shields in one temporary purple cycle.
    let shieldAwardedForCurrentTempPurple = false;
    // Indicates that the temporary purple effect is active.
	let purplePower = false;
	let purplePowerTimeout = null;
	let purplePowerEndTime = 0;  // Timestamp when the purple power should end
    let flashIntervalTimeout = null;
	let flashInterval = null;
	let loggingInterval = null;
	
	let icePower = false;
	let icePowerTimeout = null;
	let icePowerEndTime = 0;
    
    // Constants for shield ring drawing.
    // Desired radii: first ring = 20, second = 25, third = 30.
    const desiredRadii = [20, 25, 30];
    const shieldThickness = 3;  // Stroke width is 3 pixels.
    
    // Recalculate each shield ring's radius based on its index.
    function recalcShieldRadii() {
      for (let i = 0; i < shieldRings.length; i++) {
        shieldRings[i].ringRadius = desiredRadii[i];
      }
    }
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
	
	// Touch variables
	let touchStartX = null;
	let touchStartY = null;
	let touchActive = false;
	let touchDx = 0;
	let touchDy = 0;

	// Touch event listeners
	canvas.addEventListener('touchstart', function(e) {
	  if (!gamePaused) {
		e.preventDefault();
	  } // Prevent scrolling when unpaused
		  if (gamePaused) {
			// Allow unpause only if 1 second (1000 ms) has passed since pausing
			if (Date.now() - pauseTimestamp >= 1000) {
			resumeGame()
			} else {
			  // Not enough time has passed; ignore the input
			  return;
			}
		  }
		  // Check if game over and try again is available
		  if (gameOver && tryAgainAvailable) {
			restartGame();
			return;
		  }	  
			  if (e.touches.length > 0) {
				  touchActive = true;
				  if (touchStartX === null && touchStartY === null) {
					  touchStartX = e.touches[0].clientX;
					  touchStartY = e.touches[0].clientY;
				  }
				  touchDx = 0;
				  touchDy = 0;
			  }
	}, {passive: false});

	canvas.addEventListener('touchmove', function(e) {
	  if (!gamePaused) {
		e.preventDefault();
	  } // Prevent scrolling when unpaused
	  if (touchActive && e.touches.length > 0) {
		  let currentX = e.touches[0].clientX;
		  let currentY = e.touches[0].clientY;
		  touchDx = currentX - touchStartX;
		  touchDy = currentY - touchStartY;
	  }
	}, {passive: false});

	canvas.addEventListener('touchend', function(e) {
	  e.preventDefault();
	  touchActive = false;
	  touchStartX = null; // Reset initial touch point for next touch event
	  touchStartY = null;
	  touchDx = 0;
	  touchDy = 0;
	}, {passive: false});
	
    canvas.addEventListener('contextmenu', function(event) {
      event.preventDefault();
    });
    const messageOverlay = document.getElementById("messageOverlay");
    const hudLife = document.getElementById("hudLife");
    const hudLevelElem = document.getElementById("hudLevel");
    const hudLevelProg = document.getElementById("hudLevelProg");
    const hudorbIndicator = document.getElementById("hudorbIndicator");
    const hudHighScore = document.getElementById("hudHighScore");
    const zoneSize = 250;
    let tryAgainAvailable = false;
    
    let orbActive = true;
    let manualPauseTimer = null;
    let manualPauseLocked = false;
    let controlsLocked = false;
	let playerIsPink = false;
	let cheatNoWrap = false;
	let cheatCodeBuffer = ""; //0000-Clear 3712-Pink 2505-NoWrap
	let bossRotationSpeed = 0.04;
	let bossFail = 0;
	
	// --------------------
	// GLOBAL ROCK VALUES
	// --------------------
	let rockValues = [];

	function recalcRockValues() {
	  rockValues = []; // Reset the array.
	  for (let i = 0; i < 99; i++) {
		if (i === 3) {
		  rockValues.push(42);
		} else {
		  // Each value is 10 * (i+1) plus a random number between 1 and 9.
		  rockValues.push(10 * (i + 1) + (Math.floor(Math.random() * 9) + 1));
		}
	  }
	  //console.log("rockValues array recalculated:", rockValues);
	}

	
	// Trail Effect
	let playerTrail = [];
	const TRAIL_LENGTH = 20;  
	
	let hasTriGreen = 0;
	let hasTriBlue = 0;
	let hasTriPurple = 0;
	// Load saved values from localStorage (default to 0 if not found)
	hasTriPurple = localStorage.getItem("hasTriPurple") ? parseInt(localStorage.getItem("hasTriPurple")) : 0;
	hasTriBlue = localStorage.getItem("hasTriBlue") ? parseInt(localStorage.getItem("hasTriBlue")) : 0;
	hasTriGreen = localStorage.getItem("hasTriGreen") ? parseInt(localStorage.getItem("hasTriGreen")) : 0;
	let triGreen = {
	  active: false,  // Indicates if the triGreen is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	let triBlue = {
	  active: false,  // Indicates if the triBlue is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	let triPurple = {
	  active: false,  // Indicates if the triPurple is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	
	function triHud() {
	  // Get the three triangle elements in order: left, middle, right.
	  let triangles = document.querySelectorAll("#hudTriangles .triangle");
	  if (triangles.length < 3) return; // Ensure all three exist

	  // Left triangle (green)
	  if (hasTriGreen === 1) {
		hasGreenArrow = 1;
		triangles[0].style.backgroundColor = "green";
		triangles[0].classList.add("green");
		triangles[0].style.boxShadow = "none";
		localStorage.setItem("hasTriGreen", hasTriPurple); // Save to localStorage
	  } else {
		triangles[0].style.backgroundColor = "#202020";
		triangles[0].classList.remove("green");
		triangles[0].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
	  }

	  // Middle triangle (blue)
	  if (hasTriBlue === 1) {
		triangles[1].style.backgroundColor = "blue";
		triangles[1].classList.add("blue");
		triangles[1].style.boxShadow = "none";
		  localStorage.setItem("hasTriBlue", hasTriPurple); // Save to localStorage
	  } else {
		triangles[1].style.backgroundColor = "#202020";
		triangles[1].classList.remove("blue");
		triangles[1].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
	  }

		// Right triangle (purple)
		if (hasTriPurple === 1) {
		  triangles[2].style.backgroundColor = PURPLE_COLOUR;
		  triangles[2].classList.add("purple");
		  triangles[2].style.boxShadow = "none";
		  localStorage.setItem("hasTriPurple", hasTriPurple); // Save to localStorage
		  if (player.shieldCount >= 1) {
			triangles[2].classList.add("glow");
		  } else {
			triangles[2].classList.remove("glow");
		  }
		} else {
		  triangles[2].style.backgroundColor = "#202020";
		  triangles[2].classList.remove("purple");
		  triangles[2].classList.remove("glow");
		  triangles[2].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
		}
	}
	
	function activatePurplePower() {
	  const extension = Math.max(5000, Math.min(15000, player.level * 1000));
	  const now = Date.now();

	  if (!purplePower) {
		// Activate purple power for the first time:
		clearIcePower();
		purplePower = true;
		// Apply the purple effect to enemies
		sqrs.forEach(enemy => {
		  if (!enemy.temporarilyPurple) {
			enemy.originalColor = enemy.color;
			enemy.color = PURPLE_COLOUR;
			enemy.temporarilyPurple = true;
		  }
		});
		hudorbIndicator.style.backgroundColor = PURPLE_COLOUR;
		console.log("Purple power activated!");
		purplePowerEndTime = now + extension;
	  } else {
		// Extend the power duration
		purplePowerEndTime = Math.max(purplePowerEndTime, now) + extension;
		console.log("Purple power extended!");
	  }

	  // Clear any existing timeouts/intervals
	  if (purplePowerTimeout) {
		clearTimeout(purplePowerTimeout);
	  }
	  if (flashIntervalTimeout) {
		clearTimeout(flashIntervalTimeout);
	  }
	  if (flashInterval) {
		clearInterval(flashInterval);
		flashInterval = null;
	  }

	  const remainingTime = purplePowerEndTime - now;

	  // Start flashing 2 seconds before purple power expires
	  if (remainingTime > 2000) {
		flashIntervalTimeout = setTimeout(() => {
		  // Start the flash interval
		  flashInterval = setInterval(() => {
			sqrs.forEach(enemy => {
			  if (enemy.temporarilyPurple) {
				enemy.color = (enemy.color === PURPLE_COLOUR) ? FLASH_COLOUR : PURPLE_COLOUR;
			  }
			});
		  }, 100); // Flash rate
		}, remainingTime - 2000);
	  }

	  // Schedule deactivation of purple power
	  purplePowerTimeout = setTimeout(clearPurplePower, remainingTime);
	}

	function clearPurplePower() {
	  // Stop flashing if it's still active
	  if (flashInterval) {
		clearInterval(flashInterval);
		flashInterval = null;
	  }
	  // console.log("Purple power ended!");
	  purplePower = false;
	  // Revert enemy colors to their original state
	  sqrs.forEach(enemy => {
		if (enemy.temporarilyPurple) {
		  enemy.color = enemy.originalColor;
		  enemy.temporarilyPurple = false;
		}
	  });
	  playerTrail = [];
	}
	
	function activateIcePower() {
	  const extension = 10000; // Fixed extension: 10 seconds
	  const now = Date.now();

	  if (!icePower) {
	    clearPurplePower();
		icePower = true;
		// Apply the ice effect to enemies
		sqrs.forEach(enemy => {
		  if (!enemy.temporarilyFrozen) {
			enemy.originalColor = enemy.color;
			enemy.color = ICE_COLOUR;
			enemy.temporarilyFrozen = true;
		  }
		});
		console.log("Ice power activated!");
		icePowerEndTime = now + extension;
	  } else {
		// If already active, reset the timer to 10 seconds from now.
		icePowerEndTime = Date.now() + extension;
		console.log("Ice power extended!");
	  }

	  // Clear any existing timeout and schedule clearIcePower.
	  if (icePowerTimeout) clearTimeout(icePowerTimeout);
	  icePowerTimeout = setTimeout(() => {
		if (Date.now() >= icePowerEndTime) {
		  clearIcePower();
		}
	  }, icePowerEndTime - Date.now());
	}

	function clearIcePower() {
	  // Double-check that the duration is over.
	  if (Date.now() < icePowerEndTime) return;

	  // Restore each enemy's original properties.
	  sqrs.forEach(enemy => {
		if (enemy.temporarilyFrozen) {
		  enemy.color = enemy.originalColor;
		  enemy.temporarilyFrozen = false;
		}
	  });
	  //console.log("Ice power ended!");
	  icePower = false;
	}

	// Boss state variables and triShot counter
	let bossState = "yellow"; // Possible states: "yellow", "orange", "red"
	let triShotShieldCount = 0; // Counts the number of triShot that have hit a Shield
	let triShots = [];  // Array for triShot projectiles

	// updateBossState, colour and rotation
	function updateBossState() {
	if (boss){
		if (bossState === "yellow") { boss.color = "yellow", bossRotationSpeed = 0.03;}
		if (bossState === "orange") { boss.color = "orange", bossRotationSpeed = 0.06;}
		if (bossState === "red") { boss.color = "red", bossRotationSpeed = 0.09;}
	}
		
		if (bossState === "yellow" && !bossFail) {
		    bossShots = []; // Delete all existing boss shots
			bossState = "orange";
		}
		if (bossState === "orange") {
			setTimeout(() => {
			fireSpiral() // Oooh pretty spiral
			}, 3000);    // How long before the Spiral come
			setTimeout(() => {
				if (bossState === "orange") {
					bossShots = []; // Delete all existing boss shots
					fireTriShots(); // Fires two triShots in opposite random directions
					bossState = "red"; // Change boss state to red
				}
			}, 18000); // How long before the triShots come
		}
	}

	// Fires two triShots at opposite directions
	function fireTriShots() {
	if (triShots.length > 0) return; // Don't fire if they exist.
		if (bossState === "orange") {
						
			// Calculate the vector from the boss to the player
			let dx = (player.x + player.size / 2) - (boss.x + boss.size / 2);
			let dy = (player.y + player.size / 2) - (boss.y + boss.size / 2);

			// Compute perpendicular vectors (90-degree rotation)
			let angle1 = Math.atan2(dy, dx) + Math.PI / 2;  // 90 degrees counterclockwise
			let angle2 = Math.atan2(dy, dx) - Math.PI / 2;  // 90 degrees clockwise

			// Spawn the two triShots moving perpendicularly
			spawnTriShot(angle1);
			spawnTriShot(angle2);
			bossState = "red";
		}
	}
	// Fire spiral
	let isSpiralActive = false;
	let hasSpiralFired = false;

	function fireSpiral() {
	  if (hasSpiralFired || isSpiralActive || !boss || !bossFight || gamePaused) return;
	  hasSpiralFired = true;  // Mark the spiral as fired for this boss fight
	  isSpiralActive = true;
	  let spiralStartTime = Date.now(); // Record start time
	  let spiralInitialLives = player.lives; // Store player's lives at the start
	  let bossCenterX = boss.x + boss.size / 2;
	  let bossCenterY = boss.y + boss.size / 2;
	  let initialAngleDeg = -90; // -90° is straight upward.
	  let totalShots = 11400; // Duration of Spiral
	  let currentShot = 0;
	  let spiralSpeed = 0.75; // How tight the Spiral is
	  let spiralDelay = 20;  // How slow the Spiral circles
	  
	  // Randomize spin direction: +1 for clockwise, -1 for counterclockwise.
	  let spinDirection = Math.random() < 0.5 ? 1 : -1;
	  
	  function shootNext() {
		// Stop the spiral
		if (Date.now() - spiralStartTime >= totalShots || currentShot >= totalShots || gamePaused || gameOver || player.lives < spiralInitialLives) {
		  isSpiralActive = false;
		  return;
		}
		
		// Calculate the angle in degrees and convert to radians.
		let angleDeg = initialAngleDeg + (currentShot * 2 * spinDirection);
		let angleRad = angleDeg * Math.PI / 180;
		
		// Fire a normal orange shot ("single" style) at this angle with the given speed.
		fireBossShotOrange("single", bossCenterX, bossCenterY, angleRad, spiralSpeed);
		
		currentShot++;
		setTimeout(shootNext, spiralDelay);
	  }
	  
	  shootNext();
	}
    
    const safeMargin = 30;
    function isTooClose(a, b, margin) {
      return (
        a.x < b.x + b.size + margin &&
        a.x + a.size > b.x - margin &&
        a.y < b.y + b.size + margin &&
        a.y + a.size > b.y - margin
      );
    }
    function getValidSpawnPosition(entitySize, existingEntities = []) {
      let x, y, valid = false;
      let candidate = { x: 0, y: 0, size: entitySize };
      while (!valid) {
        x = Math.random() * (canvas.width - entitySize);
        y = Math.random() * (canvas.height - entitySize);
        candidate.x = x;
        candidate.y = y;
        valid = true;
        for (let ent of existingEntities) {
          if (isTooClose(candidate, ent, safeMargin)) {
            valid = false;
            break;
          }
        }
      }
      return { x, y };
    }
    // Player spawn positioning during Boss Fight.
    function getValidBossFightSpawnPosition(entitySize, obstacles) {
      let x, y, valid = false;
      let candidate;
      while (!valid) {
        // Ensure the spawn is within the canvas excluding the 20px moat border.
        x = 20 + Math.random() * (canvas.width - entitySize - 40);
        y = 20 + Math.random() * (canvas.height - entitySize - 40);
        candidate = { x: x, y: y, size: entitySize };
        valid = true;
        for (let obs of obstacles) {
          if (isTooClose(candidate, obs, safeMargin)) {
            valid = false;
            break;
          }
        }
      }
      return { x, y };
    }
    function getValidEnemySpawnPosition(entitySize) {
      let pos;
      let tries = 0;
      do {
        pos = getValidSpawnPosition(entitySize, rocks.concat(sqrs, [player]));
        tries++;
      } while (
        rocks.some(obs =>
          pos.x < obs.x + obs.size &&
          pos.x + entitySize > obs.x &&
          pos.y < obs.y + obs.size &&
          pos.y + entitySize > obs.y
        ) && tries < 1000
      );
      return pos;
    }
    function getRandomAngle() {
      return Math.random() * 2 * Math.PI;
    }
	// Clamp a value between min and max.
	function clamp(val, min, max) {
	  return Math.max(min, Math.min(max, val));
	}

	// Compute reflection vector.
	function reflectVector(vx, vy, nx, ny) {
	  let dot = vx * nx + vy * ny;
	  return { vx: vx - 2 * dot * nx, vy: vy - 2 * dot * ny };
	}

	// Collision between circle and rectangle.
	function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
	  let closestX = clamp(cx, rx, rx + rw);
	  let closestY = clamp(cy, ry, ry + rh);
	  let dx = cx - closestX;
	  let dy = cy - closestY;
	  return (dx * dx + dy * dy) < (radius * radius);
	}

	// Collision between circle and player's rectangle.
	function circlePlayerCollision(cx, cy, radius, player) {
	  return circleRectCollision(cx, cy, radius, player.x, player.y, player.size, player.size);
	}

	// Collision between circle (boss shot) and a boss rock (rectangle).
	function bossShotRockCollision(shot, rock) {
	  return circleRectCollision(shot.x, shot.y, shot.size / 2, rock.x, rock.y, rock.width, rock.height);
	}

	// Returns a random boss shot interval between 1 and 3 seconds.
	function getRandomBossShotInterval() {
	  return 1000 + Math.random() * 2000;
	}

	// Schedules next boss shot interval.
	function scheduleNextBossShot() {
	  lastBossShotTime = Date.now();
	  bossShotInterval = getRandomBossShotInterval();
	}
    
	// Player Setup
    const basePlayerSpeed = 5;
    let player = { x: 50, y: 50, size: 20, speed: basePlayerSpeed, lives: 1, level: 1, shieldCount: 0 };
    let progress = 0;
    let orb = { x: 200, y: 200, size: 20, color: "green", isHex: false };
    let sqrs = [];
    let rocks = [];
    let mud = [];
	
	let lastPlayerMoveTime = Date.now();
	let overrideNextBossShot = false;
	let lastPlayerX = player.x;
	let lastPlayerY = player.y;		
	let hasGreenArrow = 0;
	
	// boss fight globals
	let bossFight = false;
	let boss = null;
	let bossRocks = [];
	// boss shot globals
	let bossShots = [];
	let lastBossShotTime = Date.now();
	let bossShotInterval = getRandomBossShotInterval(); // initial interval

	let miniBoss = false;

    let hitCooldown = false;
    let gameOver = false;
	
	// Global variables for pause state.
	let gamePaused = false;
	let pauseTimestamp = 0
	let pauseReason = ''; 
	
 	function setPause(paused, colour = '', reason = '') {
	  gamePaused = paused;
	  pauseColour = colour;
	  pauseReason = paused ? reason : '';
	  if (gamePaused) {
	    messageOverlay.style.color = pauseColour;
		messageOverlay.textContent = pauseReason;
		pauseTimestamp = Date.now(); // Record the time when the game is paused
	  } else {
		messageOverlay.textContent = '';
	  }
	}
	
	// Function to resume the game.
	function resumeGame() {
		if (Date.now() - pauseTimestamp >= 1000) {
		  setPause(false);
		  controlsLocked = false;
		  messageOverlay.textContent = "";
		  
		}
	} 
 
    function isIntersecting(entity, zone) {
      return !(entity.x + entity.size < zone.x ||
               entity.x > zone.x + zone.width ||
               entity.y + entity.size < zone.y ||
               entity.y > zone.y + zone.height);
    }
	function isCollidingWithObstacle(entity, obstacles) {
	  for (let obs of obstacles) {
		let collision;
		// If obstacle is a rockFake, use checkRockCollision to include timer logic.
		if (obs.rockFake) {
		  collision = checkRockCollision(obs);
		} else {
		  collision = (
			entity.x < obs.x + obs.width &&
			entity.x + entity.size > obs.x &&
			entity.y < obs.y + obs.height &&
			entity.y + entity.size > obs.y
		  );
		}
		if (collision) return true;
	  }
	  return false;
	}
	
	function checkRockCollision(rock) {
	  if (!rock) return false;  // Guard: if rock is undefined, return false.

	  const collision = (
		player.x < rock.x + rock.width &&
		player.x + player.size > rock.x &&
		player.y < rock.y + rock.height &&
		player.y + player.size > rock.y
	  );
	  
	  if (rock.rockFake) {
		if (collision) {
		  if (!rock.fakeCollisionStart) {
			// Start timer on first collision.
			rock.fakeCollisionStart = Date.now();
		  } else if (Date.now() - rock.fakeCollisionStart >= 500) {
			// After 500ms of continuous collision, mark as inside.
			rock.inside = true;
		  }
		} else {
		  // Reset timer and inside flag when collision stops.
		  rock.fakeCollisionStart = null;
		  rock.inside = false;
		}
		// When the rockFake is in its "inside" (darker) state, ignore collision.
		if (rock.inside) return false;
	  }
	  return collision;
				 
	}
	
	// rockFake stuff
	// Global variables for tracking entry time and last player position.
	let rockFakeEntryTime = null;
	let lastPlayerPos = { x: null, y: null };
	
	let shop = false;
	let isWrapping = false;

	function rockFakeUpdate() {
	  let insideRockFake = false;
	  // Loop through all rocks to check for a rockFake with the 'inside' flag.
	  for (let rock of rocks) {
		if (rock.rockFake && rock.inside) {
		  // Check if the player's rectangle intersects this rock.
		  if (
			player.x < rock.x + rock.width &&
			player.x + player.size > rock.x &&
			player.y < rock.y + rock.height &&
			player.y + player.size > rock.y
		  ) {
			insideRockFake = true;
			break; // Found one; no need to check further.
		  }
		}
	  }
	  
	  // Adjust player's speed accordingly.
	  if (insideRockFake) {
		player.speed = basePlayerSpeed * 0.1;
		
		// If this is the first frame we detect the player inside, record the time and position.
		if (rockFakeEntryTime === null) {
		  rockFakeEntryTime = Date.now();
		  lastPlayerPos = { x: player.x, y: player.y };
		} else {
		  // Check if the player has moved.
		  if (player.x !== lastPlayerPos.x || player.y !== lastPlayerPos.y) {
			// Player moved, so reset the timer and update the position.
			rockFakeEntryTime = Date.now();
			lastPlayerPos = { x: player.x, y: player.y };
		  } else {
			// Player hasn't moved; check if 3 seconds have passed.
			if (Date.now() - rockFakeEntryTime >= 3000) {
			  openShop();
			}
		  }
		}
	  } else {
		// If not inside, reset the timer and last position.
		player.speed = basePlayerSpeed;
		rockFakeEntryTime = null;
		lastPlayerPos = { x: null, y: null };
	  }
	}
   
    function getRandomCornerPattern() {
      let pattern;
      do {
        pattern = [
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5
        ];
      } while (pattern.filter(c => c).length === 0 || pattern.filter(c => c).length === 4);
      return pattern;
    }
    
    function spawnmud() {
      mud = [];
      if (player.level === 1) return;
      let count = 1;
      if (player.level >= 50) count = 5;
      else if (player.level >= 40) count = 4;
      else if (player.level >= 30) count = 3;
      else if (player.level >= 20) count = 2;
      count = Math.min(count, 5);
      for (let i = 0; i < count; i++) {
        mud.push({
          x: Math.random() * (canvas.width - zoneSize),
          y: Math.random() * (canvas.height - zoneSize),
          width: zoneSize,
          height: zoneSize,
          color: "#5D3A1A"
        });
      }
    }
    
	function spawnrocks() {
	  rocks = [];
	  if (player.level === 1) return;
	  
	  // Determine number of rocks (example logic)
	  let count = Math.floor(Math.random() * Math.floor(player.level / 2)) + 1;
	  count = Math.min(count, 10);
	  
	  const shapes = [
		{ width: 50, height: 50 },
		{ width: 50, height: 75 },
		{ width: 50, height: 100 },
		{ width: 75, height: 50 },
		{ width: 75, height: 75 },
		{ width: 75, height: 100 },
		{ width: 100, height: 50 },
		{ width: 100, height: 75 },
		{ width: 100, height: 100 }
	  ];
	  
	  for (let i = 0; i < count; i++) {
		let shape = shapes[Math.floor(Math.random() * shapes.length)];
		let rockSize = Math.max(shape.width, shape.height);
		let pos = getValidSpawnPosition(rockSize, rocks.concat([player]));
		// Assume getRandomCornerPattern() returns an array for the default (sharp) corners.
		let corners = getRandomCornerPattern();
		
		let rock = {
		  x: pos.x, 
		  y: pos.y, 
		  width: shape.width, 
		  height: shape.height, 
		  size: rockSize, 
		  color: "#222",          // default rock colour
		  corners: corners,       // Used for drawing (sharp corners by default)
		  rockFake: false,        // Flag to mark the special rock
		  fakeCollisionStart: null, // Timer for collision duration
		  inside: false           // Becomes true when player collides for 500ms
		};
		rocks.push(rock);
	  }
	  
	  // Flag one rock as rockFake if the player's level matches one of the rockValues.
	  if (rockValues.includes(player.level) && rocks.length > 0) {
		let index = Math.floor(Math.random() * rocks.length);
		rocks[index].rockFake = true;
	  }
	}

  
    const ICE_SPEED = 0.1, YELLOW_SPEED = 1, ORANGE_SPEED = 2, RED_SPEED = 4;
    const YELLOW_SIZE = 20, ORANGE_SIZE = 25, RED_SIZE = 30;
	const MUD_SLOW = 0.5;
  
	function spawnsqrs() {
	  sqrs = [];
	  const redCount = Math.floor(player.level / 25);
	  const orangeCount = Math.floor(player.level / 10);
	  const yellowCount = Math.max(0, player.level - (redCount + orangeCount));
	  const intendedTotal = redCount + orangeCount + yellowCount;
	  const totalEnemies = Math.min(intendedTotal, 30); 	            // Cap total enemies
	  
	  // Mapping enemy types to their properties
	  const enemyConfig = {
		red:    { size: RED_SIZE,    speed: RED_SPEED },
		orange: { size: ORANGE_SIZE, speed: ORANGE_SPEED },
		yellow: { size: YELLOW_SIZE, speed: YELLOW_SPEED }
	  };
	  
	  // Build an array of enemy types based on counts
	  let enemyTypes = [];
	  for (let i = 0; i < redCount; i++) {
		enemyTypes.push("red");
	  }
	  for (let i = 0; i < orangeCount; i++) {
		enemyTypes.push("orange");
	  }
	  for (let i = 0; i < yellowCount; i++) {
		enemyTypes.push("yellow");
	  }
	  // Apply the total enemies cap
	  enemyTypes = enemyTypes.slice(0, totalEnemies);

	  enemyTypes.forEach(type => {
		let enemy = {
		  x: 0,
		  y: 0,
		  size: enemyConfig[type].size,
		  speedX: 0,
		  speedY: 0,
		  color: type,
		  // Store base speeds for later use
		  baseSpeedX: 0,
		  baseSpeedY: 0
		};

		// Find a valid spawn position, but avoid an infinite loop
		let validSpawn = false;
		let pos;
		let iterations = 0;
		while (!validSpawn && iterations < 100) {
		  pos = getValidEnemySpawnPosition(enemy.size);
		  validSpawn = true;
		  for (let rock of rocks) {
			if (
			  pos.x < rock.x + rock.width &&
			  pos.x + enemy.size > rock.x &&
			  pos.y < rock.y + rock.height &&
			  pos.y + enemy.size > rock.y
			) {
			  validSpawn = false;
			  break;
			}
		  }
		  iterations++;
		}
		// If no valid position is found, skip this enemy spawn
		if (!validSpawn) {
		  console.warn("Failed to spawn enemy of type " + type + " due to no valid position found.");
		  return; // Skip adding this enemy
		}
		enemy.x = pos.x;
		enemy.y = pos.y;
		let angle = getRandomAngle();
		enemy.speedX = Math.cos(angle) * enemyConfig[type].speed;
		enemy.speedY = Math.sin(angle) * enemyConfig[type].speed;
		enemy.baseSpeedX = enemy.speedX;
		enemy.baseSpeedY = enemy.speedY;
		
		sqrs.push(enemy);
	  });
	}
    // Main Orb Spawning function
	function spawnorb() {
	  if (bossFight || miniBoss || shop) return;                        // Prevent orb spawning during boss fights and shopping.

	  orbActive = true;
	  const minDistance = 250;                                          // Minimum spawn distance from Player
	  const playerCenterX = player.x + player.size / 2;
	  const playerCenterY = player.y + player.size / 2;
	  let pos, distance;

	  // Ensure the orb spawns far enough from the player.
	  do {
		pos = getValidSpawnPosition(orb.size, rocks.concat(sqrs, [player]));
		const orbCenterX = pos.x + orb.size / 2;
		const orbCenterY = pos.y + orb.size / 2;
		const dx = orbCenterX - playerCenterX;
		const dy = orbCenterY - playerCenterY;
		distance = Math.sqrt(dx * dx + dy * dy);
	  } while (distance < minDistance);

	  orb.x = pos.x;
	  orb.y = pos.y;
	  
	  // Determine the orb's color and shape.
	  let orbData;
	  if (progress === 0) {
		// Always green when progress is 0.
		orbData = { color: "green", shape: "circle" };
		} else if (progress === 4) {
		  // When progress is 4/5, choose blue or green with a 50/50 chance.
		  // Every 10th level uses a hex shape; otherwise, use a circle.
		  let chosenColor = (Math.random() < 0.5) ? "blue" : "green";
		  orbData = { color: chosenColor, shape: (player.level % 10 === 0) ? "hex" : "circle" };
		} else {
		// Otherwise, use the function to determine the orb.
		orbData = getRandomOrb(0.1, PURPLE_COLOUR, "circle", 0.2, ICE_COLOUR, "circle");
	  }  
	  orb.color = orbData.color;
	  orb.shape = orbData.shape;
	  //console.log("Spawned orb:", orb.color, orb.shape);
	}

	// Parameters should be  in groups of three: [threshold, color, shape]
	function getRandomOrb(...params) {
	  const defaultOption = { color: "green", shape: "circle" }; 	    // Default orb option if no condition is met.
	  
	  // Build an array of options from the parameters. Each option is an object with a threshold, color, and shape.
	  let options = [];
	  for (let i = 0; i < params.length; i += 3) {
		options.push({
		  threshold: params[i],
		  color: params[i + 1],
		  shape: params[i + 2]
		});
	  }	  
	  // Generate a random number between 0 and 1.
	  const rand = Math.random();	  
	  // Check each option in order.
	  for (let option of options) {
		if (rand < option.threshold) {
		  // Special case: if the option is purple, only allow one per level.
		  if (option.color === PURPLE_COLOUR) {
			if (!purpleorbUsed) {
			  purpleorbUsed = true;
			  return { color: PURPLE_COLOUR, shape: option.shape };
			} else {
			  // Purple orb already used; choose default.
			  return defaultOption;
			}
		  }
		  // For any other option, return it.
		  return { color: option.color, shape: option.shape };
		}
	  }	  
	  return defaultOption; 	                                        // If no thresholds are met, return default.
	}
	
	// Level functions
	function clearLevel() {
		bossFight = false;
		shop = false;
		boss = null;
		//shot.remove = true;
		bossRocks = [];
		bossShots = [];
		clearPurplePower();
		clearIcePower();
		shieldAwardedForCurrentTempPurple = false;
	    purpleorbUsed = false;
		hudorbIndicator.style.backgroundColor = "grey";
		clearIcePower();
		progress = 0;
	}

	function spawnLevel() {
		spawnmud();
		spawnrocks();
		spawnsqrs();
		spawnorb();
	}		

	function nextLevel() {
		player.level++;
		setPause(true, "blue", "Level " + player.level);
		clearLevel();
		spawnLevel();
	}	

	// Function to fire a boss shot (or bursts) based on probabilities and limits.
	function fireBossShot() {
	  // Only fire if boss is rotating
	  if (!bossFight || gamePaused) return;

	  // BigBoi Override: if the player has been stationary, fire a large orange shot.
	  if (overrideNextBossShot) {
		let bossCenterX = boss.x + boss.size / 2;
		let bossCenterY = boss.y + boss.size / 2;
		fireBossShotOrange("large", bossCenterX, bossCenterY);
		lastPlayerMoveTime = Date.now(); // Reset timer
		overrideNextBossShot = false;  // Reset override flag for subsequent shots.
		scheduleNextBossShot();
		return;
	  }
	  
	  // Decide shot type based on probability:
	  // 50% chance for orange, 25% for red, 25% for green (or blue if progress>=9)
	  let rand = Math.random();
	  let shotType;
	  if (rand < 0.5) {
		shotType = "orange";
	  } else if (rand < 0.75) {
		shotType = "red";
	  } else {
		shotType = "green";  // will convert to blue later if progress>=9
	  }
	  
	  // Check limits:
	  // Only 1 green/blue shot allowed.
	  let greenCount = bossShots.filter(s => s.type === "green" || s.type === "blue").length;
	  if (shotType === "green" && greenCount >= 1) {
		shotType = "orange";
	  }
	  // Only 2 red shots allowed.
	  let redCount = bossShots.filter(s => s.type === "red").length;
	  if (shotType === "red" && redCount >= 2) {
		shotType = "orange";
	  }
	  
	  // For green shots, if progress >= 9 then they become blue.
	  if (shotType === "green" && progress >= 9) {
		  let chosenColor = (Math.random() < 0.5) ? "blue" : "green";
		shotType = chosenColor;
	  }
	  
	  // Determine firing position: assume boss center.
	  let bossCenterX = boss.x + boss.size / 2;
	  let bossCenterY = boss.y + boss.size / 2;
	  
	  // For orange shots, further choose one of four styles.
		if (shotType === "orange") {
		  let r = Math.random();
		  if (r < 0.0) {
			// Large: 0% chance (unless stationary).
			fireBossShotOrange("large", bossCenterX, bossCenterY);
		  } else if (r < 0.4) {
			// Line: next 30% chance.
			for (let i = 0; i < 5; i++) {
			  setTimeout(() => {
				fireBossShotOrange("single", bossCenterX, bossCenterY);
			  }, i * 50);
			}
		  } else if (r < 0.6) {
			// Spray: next 20% chance.
			let baseAngle = Math.atan2(player.y + player.size/2 - bossCenterY, player.x + player.size/2 - bossCenterX);
			let angles = [
			  baseAngle,
			  baseAngle + 5 * Math.PI/180,
			  baseAngle - 5 * Math.PI/180,
			  baseAngle + 10 * Math.PI/180,
			  baseAngle - 10 * Math.PI/180
			];
			angles.forEach(angle => {
			  fireBossShotOrange("single", bossCenterX, bossCenterY, angle);
			});
		  } else {
			// Single: remaining 40% chance.
			fireBossShotOrange("single", bossCenterX, bossCenterY);
		  }
		}
	  
	  else if (shotType === "red") {
		// Fire a red shot with a random ±30° offset relative to the player.
		let baseAngle = Math.atan2(player.y + player.size/2 - bossCenterY, player.x + player.size/2 - bossCenterX);
		let offset = (Math.random() < 0.5 ? -30 : 30) * Math.PI/180;
		let angle = baseAngle + offset;
		let speed = 4.5;
		let shot = {
		  type: "red",
		  x: bossCenterX,
		  y: bossCenterY,
		  vx: Math.cos(angle) * speed,
		  vy: Math.sin(angle) * speed,
		  size: 10, // boss shot diameter
		  bounceCount: 0,
		  firedTime: Date.now(), // for tracking phase
		  homing: false  // will switch to homing after 0.5-1 sec
		};
		// Random straight travel duration between 500 and 1000 ms.
		shot.straightDuration = 500 + Math.random() * 500;
		bossShots.push(shot);
	  }
	  else if (shotType === "green" || shotType === "blue") {
		// Fire a green/blue shot at speed 3 in a random direction.
		let angle = getRandomAngle();
		let shot = {
		  type: (shotType === "green" ? "green" : "blue"),
		  x: bossCenterX,
		  y: bossCenterY,
		  vx: Math.cos(angle) * 3,
		  vy: Math.sin(angle) * 3,
		  size: 10,
		  bounceCount: 0
		};
		bossShots.push(shot);
	  }
	  scheduleNextBossShot();
	}

	// Creates a triShot projectile
	function spawnTriShot(angle) {
		let triShot = {
			x: boss.x + boss.size / 2,  // Start from boss center
			y: boss.y + boss.size / 2,
			vx: Math.cos(angle) * 2,    // Initial speed of 2
			vy: Math.sin(angle) * 2,
			homing: false,
			spawnedAt: Date.now(),
			size: 10,
			type: "triShot" // Marks it for collision detection
		};
		triShots.push(triShot);
	}

	// Updates triShots each frame
	function updateTriShots() {
		triShots.forEach((triShot, index) => {
			// Store previous positions for the trail
			if (!triShot.trail) triShot.trail = [];
			triShot.trail.push({ x: triShot.x, y: triShot.y });
			if (triShot.trail.length > 20) triShot.trail.shift();

			// Check for collision with other triShots
			triShots.forEach((otherShot, otherIndex) => {
				if (index !== otherIndex && checkCollision(triShot, otherShot)) {
					handleTriShotCollision(triShot, otherShot);
				}
			});

			// If bouncing, move in opposite directions for 2 seconds
			if (triShot.bouncing) {
				if (Date.now() - triShot.bounceStart < 2000) {
					triShot.x += triShot.vx;
					triShot.y += triShot.vy;
					return; // Prevents homing from overriding bounce movement
				} else {
					// After 2 seconds, refocus on player
					triShot.bouncing = false;
				}
			}

			// Homing logic should only apply if the shot is NOT bouncing
			if (!triShot.bouncing && Date.now() - triShot.spawnedAt > 3000) {
				let dx = (player.x + player.size / 2) - triShot.x;
				let dy = (player.y + player.size / 2) - triShot.y;
				let distance = Math.sqrt(dx * dx + dy * dy);
				triShot.vx = (dx / distance) * 2;
				triShot.vy = (dy / distance) * 2;
			}

			// Move triShot
			triShot.x += triShot.vx;
			triShot.y += triShot.vy;

			// Tri Shot collision with player.
			if (checkCollision(triShot, player)) {
			  if (player.shieldCount > 0) {
				// Shield case:
				player.shieldCount--;               // Consume one shield hit
				triShotShieldCount++;               // Increment the triShot shield counter
				triShots.splice(index, 1);          // Remove only the collided triShot

				// When triShotShieldCount reaches 2 or more, remove the boss:
				if (triShotShieldCount >= 2) {
				  // Remove the boss from the game (adjust as needed for your game’s boss removal routine)
				  triGreen.x = canvas.width / 2 - triGreen.size / 2;
				  triGreen.y = canvas.height / 2 - (triGreen.size * 1.2) / 2; // if height = triGreen.size * 1.2
				  boss = null;
				  triPurple.active = true;
				  triShotShieldCount = 0;             // Reset the triShot shield counter
				}
			  } else {
				// No-shield case:
				bossFail = 1;
				triShots = [];                      // Remove both triShots
				if (boss) {
				  bossState = "yellow";             // Reset boss state to yellow mode
				}
				triShotShieldCount = 0;             // Reset the triShot shield counter
				// Trigger player hit (which will decrement lives and handle respawn)
				handlePlayerHit();
				// (Optionally, break out of the loop if necessary to avoid further processing)
			  }
			}

		});
	}

	// Simple collision detection (adjust the numbers if needed)
	function checkCollision(a, b) {
		// Standard AABB (Axis-Aligned Bounding Box) collision check
		if (
			a.x < b.x + b.size &&
			a.x + a.size > b.x &&
			a.y < b.y + b.size &&
			a.y + a.size > b.y
		) {
			return true;
		}

		// Additional check for triShot collision (if both are triShots)
		if (a.type === "triShot" && b.type === "triShot") {
			let dx = a.x - b.x;
			let dy = a.y - b.y;
			let distance = Math.sqrt(dx * dx + dy * dy);
			return distance < 16; // Collision if within 16 pixels
		}

		return false;
	}

	function handleTriShotCollision(shotA, shotB) {
		if (shotA.bouncing || shotB.bouncing) return; // Ignore if already bouncing

		// Calculate direction between the two shots
		let angle = Math.atan2(shotA.y - shotB.y, shotA.x - shotB.x);

		// Apply opposite velocities for bouncing
		let speed = 3;
		shotA.vx = Math.cos(angle) * speed;
		shotA.vy = Math.sin(angle) * speed;
		shotB.vx = -Math.cos(angle) * speed;
		shotB.vy = -Math.sin(angle) * speed;

		// Mark them as bouncing and set the bounce start time
		shotA.bouncing = true;
		shotB.bouncing = true;
		shotA.bounceStart = Date.now();
		shotB.bounceStart = Date.now();
	}

	// Fire an orange boss shot.
	function fireBossShotOrange(style, startX, startY, angle, speedMod = 1) {
	  let speed, size;
	  if (style === "large") {
		speed = 3;
		size = 20; // twice the normal shot size
	  } else { // single
		speed = 4.5;
		size = 10;
	  }
	  speed *= speedMod;
	  // If angle not provided, fire directly at player.
	  if (angle === undefined) {
		angle = Math.atan2(player.y + player.size/2 - startX, player.x + player.size/2 - startX);
		// Alternatively, use: 
		angle = Math.atan2(player.y + player.size/2 - startY, player.x + player.size/2 - startX);
	  }
	  let shot = {
		type: "orange",
		style: style,
		x: startX,
		y: startY,
		vx: Math.cos(angle) * speed,
		vy: Math.sin(angle) * speed,
		size: size,
		bounceCount: 0
	  };
	  bossShots.push(shot);
	}
	
	// Update boss shots movement, collision with boss rocks, shield rings, moat, and player.
	function updateBossShots() {
	  for (let i = bossShots.length - 1; i >= 0; i--) {
		let shot = bossShots[i];
		if (!shot) continue;  // Skip undefined entries.
		
		// For red shots, check if it's time to switch to homing.
		if (shot.type === "red" && !shot.homing) {
		  let elapsed = Date.now() - shot.firedTime;
		  if (elapsed >= shot.straightDuration) {
			shot.homing = true;
		  }
		}
		// If homing, adjust velocity to chase the player.
		if (shot.type === "red" && shot.homing) {
		  let centerPlayerX = player.x + player.size/2;
		  let centerPlayerY = player.y + player.size/2;
		  let dx = centerPlayerX - shot.x;
		  let dy = centerPlayerY - shot.y;
		  let dist = Math.sqrt(dx*dx + dy*dy);
		  if (dist > 0) {
			shot.vx = (dx / dist) * 4.5;
			shot.vy = (dy / dist) * 4.5;
		  }
		}
		
		// Update position.
		shot.x += shot.vx;
		shot.y += shot.vy;
		
		// Boss Shot collision with Moat
		if (shot.x - shot.size/2 < 20 || shot.y - shot.size/2 < 20 ||
			shot.x + shot.size/2 > canvas.width - 20 || shot.y + shot.size/2 > canvas.height - 20) {
		  shot.remove = true;
		  continue;
		}
		
		// Shot collision with boss rocks.
		for (let j = bossRocks.length - 1; j >= 0; j--) {
		  let rock = bossRocks[j];
		  if (bossShotRockCollision(shot, rock)) {
			if (shot.type === "red") {
			  shot.remove = true;
			  break;
			} else if (shot.type === "orange") {
			  if (shot.style === "large") {
				shot.remove = true;
				bossRocks.splice(j, 1);
				break;
			  } else {
				let closestX = clamp(shot.x, rock.x, rock.x + rock.width);
				let closestY = clamp(shot.y, rock.y, rock.y + rock.height);
				let dx = shot.x - closestX;
				let dy = shot.y - closestY;
				let mag = Math.sqrt(dx*dx + dy*dy);
				if (mag > 0) {
				  let nx = dx / mag;
				  let ny = dy / mag;
				  let reflected = reflectVector(shot.vx, shot.vy, nx, ny);
				  shot.vx = reflected.vx;
				  shot.vy = reflected.vy;
				  shot.bounceCount++;
				}
			  }
			} else if (shot.type === "green" || shot.type === "blue") {
			  let closestX = clamp(shot.x, rock.x, rock.x + rock.width);
			  let closestY = clamp(shot.y, rock.y, rock.y + rock.height);
			  let dx = shot.x - closestX;
			  let dy = shot.y - closestY;
			  let mag = Math.sqrt(dx*dx + dy*dy);
			  if (mag > 0) {
				let nx = dx / mag;
				let ny = dy / mag;
				let reflected = reflectVector(shot.vx, shot.vy, nx, ny);
				shot.vx = reflected.vx;
				shot.vy = reflected.vy;
				shot.bounceCount++;
			  }
			}
		  }
		}
		
		// Remove shot if bounce count exceeds 25.
		if (shot.bounceCount > 25) {
		  shot.remove = true;
		}
		
		// Boss Shot collision with player.
		if (circlePlayerCollision(shot.x, shot.y, shot.size/2, player)) {
		  if (shot.type === "green") {
			orbActive = false;
			progress++;
			if (progress >= 10) {nextLevel()};
			shot.remove = true;
		  }
		  else if (shot.type === "blue") {
			orbActive = false;
			player.lives = Math.min(player.lives + 1, 999);
			progress++;
			if (progress >= 10) {nextLevel()};
			shot.remove = true;
		  }
		  else if (shot.type === "red" || shot.type === "orange") {
			shot.remove = true;
			// If the player has a shield, reduce the shield count instead of triggering a hit.
			if (player.shieldCount > 0) {
			  player.shieldCount--;
			  console.log("Boss shot absorbed by shield. New shield count: " + player.shieldCount);
			} else {
			  handlePlayerHit();
			}
		  }
		}

	  }
	  bossShots = bossShots.filter(s => s && !s.remove);
	}

	// Draw boss shots.
	function drawBossShots() {
	  bossShots.forEach(shot => {
		ctx.beginPath();
		ctx.arc(shot.x, shot.y, shot.size/2, 0, Math.PI*2);
		if (shot.type === "orange") {
		  ctx.fillStyle = "orange";
		} else if (shot.type === "red") {
		  ctx.fillStyle = "red";
		} else if (shot.type === "green") {
		  ctx.fillStyle = "green";
		} else if (shot.type === "blue") {
		  ctx.fillStyle = "blue";
		}
		ctx.fill();
	  });
	}
	// Draw tri shots as red isosceles triangles pointing in the direction of travel
	function drawTriShots() {
		triShots.forEach(triShot => {
		
			// Draw the purple trail
			ctx.globalAlpha = 0.25; // Semi-transparent effect
			ctx.fillStyle = "purple"; // Trail color

			triShot.trail.forEach((pos, index) => {
				let sizeFactor = (index / triShot.trail.length) * 0.7 + 0.3; // Fades out
				let size = 8 * sizeFactor; // Smaller towards the end
				ctx.beginPath();
				ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
				ctx.fill();
			});

			ctx.globalAlpha = 1.0; // Reset transparency		
		
			let { x, y, vx, vy } = triShot;

			// Triangle size
			let base = 16;   // Width of the base
			let height = 24; // Length from base to tip

			// Calculate the angle of movement
			let angle = Math.atan2(vy, vx);

			// Calculate triangle points
			let tipX = x + Math.cos(angle) * height;
			let tipY = y + Math.sin(angle) * height;
			let leftX = x + Math.cos(angle + Math.PI * 2 / 3) * base;
			let leftY = y + Math.sin(angle + Math.PI * 2 / 3) * base;
			let rightX = x + Math.cos(angle - Math.PI * 2 / 3) * base;
			let rightY = y + Math.sin(angle - Math.PI * 2 / 3) * base;

			// Draw the triangle
			ctx.fillStyle = "red";
			ctx.beginPath();
			ctx.moveTo(tipX, tipY);
			ctx.lineTo(leftX, leftY);
			ctx.lineTo(rightX, rightY);
			ctx.closePath();
			ctx.fill();
		});
	}
    
	// ========== The Orb Collision Function ==========
	function orbCollision(orbColor, orbShape, colliderType, sqr, index) {
	  // Validate input
	  const validColors = ["green", "blue", PURPLE_COLOUR, ICE_COLOUR, "orange", "red"];
	  const validShapes = ["circle", "hex"];
	  const validColliders = ["player", "sqr", "shot"];

	  if (!validColors.includes(orbColor) || !validShapes.includes(orbShape) || !validColliders.includes(colliderType)) {
		// Invalid parameters – handle error accordingly.
		return;
	  }

	  // Process collision based on collider type
	  switch(colliderType) {
		// ===== Player Collisions with Orbs =====
		case "player":
		  switch(orbColor) {
			case "green":
			  if (orbShape === "circle") {
				// Player collided with a green circle orb
				progress++;                                             // Add progress
				if (progress >= 5) {nextLevel()};                       // If  5, next level
			  } else if (orbShape === "hex") {
				// Player collided with a green hex orb
				progress = 5;                                           // Set progress to 5
				initiateBossFight();                                    // Start Boss Fight
			  }
			  break;
			case "blue":
			  if (orbShape === "circle") {
				// Player collided with a blue circle orb
				progress++;                                             // Add progress
				player.lives = Math.min(player.lives + 1, 999);         // Add a life (upto 999)
				if (progress >= 5) {nextLevel()}; // If 5, next level
			  } else if (orbShape === "hex") {
				// Player collided with a blue hex orb
				player.lives = Math.min(player.lives + 1, 999);         // Add a life (upto 999)
				progress = 5;                                           // Set progress to 5
				initiateBossFight();                                    // Start Boss Fight
			  }
			  break;
			case PURPLE_COLOUR:
			  if (orbShape === "circle") {
				// Player collided with a purple circle orb
				activatePurplePower();                                  // Do Purple Power
			  } else if (orbShape === "hex") {
				// Player collided with a purple hex orb
			  }
			  break;
			case ICE_COLOUR:
			  if (orbShape === "circle") {
				// Player collided with a light blue circle orb
				activateIcePower();                                     // Do Ice Power
			  } else if (orbShape === "hex") {
				// Player collided with a light blue hex orb
			  }
			  break;
			case "orange":
			  if (orbShape === "circle") {
				// Player collided with an orange circle orb
			  } else if (orbShape === "hex") {
				// Player collided with an orange hex orb
			  }
			  break;
			case "red":
			  if (orbShape === "circle") {
				// Player collided with a red circle orb
			  } else if (orbShape === "hex") {
				// Player collided with a red hex orb
			  }
			  break;
			default:
			  // Player collision with an unhandled orb type
		  }
		  break;
		  
		// ===== Sqr Collisions with Orbs =====
		case "sqr":
		  switch(orbColor) {
			case "green":
			  if (orbShape === "circle") {
				// Sqr collided with a green circle orb
				if (sqr.color === "yellow") {                           // Yellow evolve to Orange
					sqr.color = "orange";
					sqr.size = ORANGE_SIZE;
					let angle = Math.atan2(sqr.speedY, sqr.speedX);
					sqr.speedX = Math.cos(angle) * ORANGE_SPEED;
					sqr.speedY = Math.sin(angle) * ORANGE_SPEED;
				} else if (sqr.color === "orange") {                    // Orange evolve to Red
					sqr.color = "red";
					sqr.size = RED_SIZE;
					let angle = Math.atan2(sqr.speedY, sqr.speedX);
					sqr.speedX = Math.cos(angle) * RED_SPEED;
					sqr.speedY = Math.sin(angle) * RED_SPEED;
				} else if (sqr.color === "red") {                       // Reduce Progress
					progress = Math.max(0, progress - 1);
				}							
			  } else if (orbShape === "hex") {
				// Sqr collided with a green hex orb
			  }
			  break;
			case "blue":
			  if (orbShape === "circle") {
				// Sqr collided with a blue circle orb
				let newSqr = {                                          // Spawn New Yellow Sqr
					x: sqr.x,
					y: sqr.y,
					size: YELLOW_SIZE,
					color: "yellow",
					speedX: Math.cos(getRandomAngle()) * YELLOW_SPEED,
					speedY: Math.sin(getRandomAngle()) * YELLOW_SPEED
				};
				// Add the new sqr to the enemy list
				sqrs.push(newSqr);				
			  } else if (orbShape === "hex") {
				// Sqr collided with a blue hex orb
				let newSqr = {                               			// Spawn New Yellow Sqr
					x: sqr.x,
					y: sqr.y,
					size: YELLOW_SIZE,
					color: "yellow",
					speedX: Math.cos(getRandomAngle()) * YELLOW_SPEED,
					speedY: Math.sin(getRandomAngle()) * YELLOW_SPEED
				};				
			  }
			  break;
			case PURPLE_COLOUR:
			  if (orbShape === "circle") {
				// Sqr collided with a purple circle orb
				sqrs.splice(index, 1);					                // Kill the square
				hudorbIndicator.style.backgroundColor = PURPLE_COLOUR;  // Set the indicator
			  } else if (orbShape === "hex") {
				// Sqr collided with a purple hex orb
			  }
			  break;
			case ICE_COLOUR:
			  if (orbShape === "circle") {
				// Sqr collided with a light blue circle orb
				sqr.color = ICE_COLOUR;                                 // Semi-Permanent Ice
				sqr.temporarilyFrozen = true;
			  } else if (orbShape === "hex") {
				// Sqr collided with a light blue hex orb
			  }
			  break;
			case "orange":
			  if (orbShape === "circle") {
				// Sqr collided with an orange circle orb
			  } else if (orbShape === "hex") {
				// Sqr collided with an orange hex orb
			  }
			  break;
			case "red":
			  if (orbShape === "circle") {
				// Sqr collided with a red circle orb
			  } else if (orbShape === "hex") {
				// Sqr collided with a red hex orb
			  }
			  break;
			default:
			  // Sqr collision with an unhandled orb type
		  }
		  break;

		// ===== Shot Collisions with Orbs =====
		case "shot":
		  switch(orbColor) {
			case "green":
			  if (orbShape === "circle") {
				// Shot collided with a green circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a green hex orb
			  }
			  break;
			case "blue":
			  if (orbShape === "circle") {
				// Shot collided with a blue circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a blue hex orb
			  }
			  break;
			case PURPLE_COLOUR:
			  if (orbShape === "circle") {
				// Shot collided with a purple circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a purple hex orb
			  }
			  break;
			case ICE_COLOUR:
			  if (orbShape === "circle") {
				// Shot collided with a light blue circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a light blue hex orb
			  }
			  break;
			case "orange":
			  if (orbShape === "circle") {
				// Shot collided with an orange circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with an orange hex orb
			  }
			  break;
			case "red":
			  if (orbShape === "circle") {
				// Shot collided with a red circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a red hex orb
			  }
			  break;
			default:
			  // Shot collision with an unhandled orb type
		  }
		  break;

		default:
		  // Handle unhandled collider types
	  }
	  // Do these to all collided orbs
	  orbActive = false;            // Remove the orb
	  setTimeout(spawnorb, 1000);   // Schedule a new orb spawn after 1s
	}
    
    function resetAllEnemySpeeds() {
      sqrs.forEach(enemy => {
        if (enemy.color === "red") {
          enemy.speedX = Math.sign(enemy.speedX) * RED_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * RED_SPEED;
        } else if (enemy.color === "orange") {
          enemy.speedX = Math.sign(enemy.speedX) * ORANGE_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * ORANGE_SPEED;
        } else {
          enemy.speedX = Math.sign(enemy.speedX) * YELLOW_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * YELLOW_SPEED;
        }
      });
    }
    
    function updateHUD() {
      hudLife.textContent = player.lives;
      hudLevelElem.textContent = "Level " + player.level;
      // Display progress with denominator 10 during boss fight, else 5.
      if (bossFight) {
        hudLevelProg.textContent = `${progress}/10`;
      } else {
        hudLevelProg.textContent = `${progress}/5`;
      }
      hudLevelProg.appendChild(hudorbIndicator);
      if (player.level > highScore) {
        highScore = player.level;
		localStorage.setItem("highScore", highScore); // Save new high score
      }
      hudHighScore.textContent = highScore;
	  triHud();
    }
    
    // PlayerHit mechanic.
	function handlePlayerHit() {
	  if (!gamePaused) {
	    // Clear trail on death
	    playerTrail = [];
		if (player.shieldCount > 0) {
		  // Shield case: reduce shield count and display "Shield Lost" in purple.
		  player.shieldCount--;
		  bossHitColour = "purple";
		  bossHitText = "Shield Lost";
		} else {
		  // No shield available: subtract a life.
		  player.lives--;
		  shieldRings = [];
		  // Only display "Life Lost" if the player still has lives remaining.
		  if (player.lives > 0) {
			bossHitColour = "orange";
			bossHitText = "Life Lost";
		  }
		}
		
		if (player.lives >= 1) {
		setPause(true, bossHitColour, bossHitText);
		  hitCooldown = true;
		  let pos;
		  if (bossFight) {
			let obstacles = [];
			if (boss) obstacles.push({ x: boss.x, y: boss.y, size: boss.size });
			bossRocks.forEach(br => {
			  obstacles.push({ x: br.x, y: br.y, size: br.size });
			});
			pos = getValidBossFightSpawnPosition(player.size, obstacles);
		  } else {
			pos = getValidSpawnPosition(player.size, rocks.concat(sqrs, [orb]));
		  }
		  player.x = pos.x;
		  player.y = pos.y;
		  setTimeout(() => { hitCooldown = false; }, 1000);
		}		
		if (bossFight) {
			if (bossState === "orange") {
				bossFail = 1;
				bossState = "yellow"; // Reset boss state to yellow mode
			}	
		    bossShots = [];
		}
	  }
	}
    
    // Draw the Boss
    function drawBoss(cx, cy, size, rotation, color) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rotation);
      ctx.beginPath();
      let r = size / 2;
      for (let i = 0; i < 6; i++) {
        let angle = i * Math.PI / 3;
        let x = r * Math.cos(angle);
        let y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();
    }
	// Draw triangle centered at (cx,cy).
	function drawTriangle(cx, cy, width, height, color) {
	  ctx.beginPath();
	  ctx.moveTo(cx, cy - height / 2);         // Top vertex
	  ctx.lineTo(cx - width / 2, cy + height / 2); // Bottom left
	  ctx.lineTo(cx + width / 2, cy + height / 2); // Bottom right
	  ctx.closePath();
	  ctx.fillStyle = color;
	  ctx.fill();
	}
	function drawGlowingTriangle(cx, cy, width, height, fillColor, glowColor, glowBlur) {
	  ctx.save();
	  ctx.shadowColor = glowColor;
	  ctx.shadowBlur = glowBlur;
	  ctx.shadowOffsetX = 0;
	  ctx.shadowOffsetY = 0;
	  drawTriangle(cx, cy, width, height, fillColor);
	  ctx.restore();
	}
	
	function drawJoystickOverlay() {
	  if (!touchActive) return;
	  
	  // Convert the initial touch point to canvas coordinates.
	  const rect = canvas.getBoundingClientRect();
	  const centerX = touchStartX - rect.left;
	  const centerY = touchStartY - rect.top;
	  
	  // Joystick parameters
	  const joystickRadius = 75; // outer circle radius
	  const halfRadius = joystickRadius / 2; // cross arm length
	  
	  // Draw the filled circle (75% transparent grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, joystickRadius, 0, Math.PI * 2);
	  ctx.fillStyle = "rgba(64,64,64,0.25)"; // 75% transparent grey
	  ctx.fill();
	  
	  // Draw the circumference stroke (50% transparent dark grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, joystickRadius, 0, Math.PI * 2);
	  ctx.strokeStyle = "rgba(64,64,64,0.5)"; // 50% transparent dark grey
	  ctx.lineWidth = 2;
	  ctx.stroke();
	  
	  // Draw the cross:
	  ctx.beginPath();
	  // Horizontal line
	  ctx.moveTo(centerX - halfRadius, centerY);
	  ctx.lineTo(centerX + halfRadius, centerY);
	  // Vertical line
	  ctx.moveTo(centerX, centerY - halfRadius);
	  ctx.lineTo(centerX, centerY + halfRadius);
	  ctx.strokeStyle = "rgba(64,64,64,0.5)";
	  ctx.lineWidth = 2;
	  ctx.stroke();
	  
	  // Draw the center dot (25% transparent dark grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
	  ctx.fillStyle = "rgba(64,64,64,0.25)";
	  ctx.fill();
	}
	
	// Shop!
	function openShop() {
		shop = true;
		// CLear the level.
		sqrs = [];
		rocks = [];
		mud = [];
		orbActive = false;
		// Center the player
		player.x = canvas.width / 2 - player.size / 2;
		player.y = canvas.height / 2 - player.size / 2 + 50;
		playerTrail = [];
		// Pause game and display text until the player moves.
		setPause(true, "#444", "Secret Shop");
	}
	// If the player tries to wrap in the shop - Exit	
	function exitShop() {
		if (isWrapping && shop) {
			pos = getValidSpawnPosition(player.size, rocks.concat(sqrs, [orb]));
		    player.x = pos.x;
		    player.y = pos.y;
			nextLevel();
		}
	};
    
    // Initiate boss fight by clearing entities, repositioning the player,
    // and creating the boss, bossMoat and bossRocks.
    function initiateBossFight() {
      bossFight = true;
	  bossFail = 0;
	  bossState = "yellow";
	  hasSpiralFired = false;  // Reset spiral flag for new boss fight
       // Destroy all enemies and obstacles.
      sqrs = [];
      rocks = [];
      mud = [];
      // Create boss in the center.
      boss = {
        x: canvas.width / 2 - 50,
        y: canvas.height / 2 - 50,
        size: 100,
        color: "yellow",
        rotation: 0
      };
      // Create bossRocks.
      bossRocks = [];
      let numBossRocks = Math.floor(Math.random() * 6) + 5; // between 5 and 10
      let bossCenterX = canvas.width / 2;
      let bossCenterY = canvas.height / 2;
      let sizes = [{w:25, h:50}, {w:25, h:75}, {w:50, h:25}, {w:75, h:25}];
      for (let i = 0; i < numBossRocks; i++) {
        let angle = Math.random() * 2 * Math.PI;
        let distance = 175 + Math.random() * (225 - 175);
        let rockPosX = bossCenterX + distance * Math.cos(angle);
        let rockPosY = bossCenterY + distance * Math.sin(angle);
        let chosen = sizes[Math.floor(Math.random() * sizes.length)];
        let corners = getRandomCornerPattern();
        let bossRock = {
          x: rockPosX,
          y: rockPosY,
          width: chosen.w,
          height: chosen.h,
          size: Math.max(chosen.w, chosen.h),
          color: "#222",
          corners: corners
        };
        bossRocks.push(bossRock);
      }
      // Reposition the player so he doesn't start overlapping boss elements.
      let obstacles = [];
      obstacles.push({ x: boss.x, y: boss.y, size: boss.size });
      bossRocks.forEach(br => { obstacles.push({ x: br.x, y: br.y, size: br.size }); });
      let pos = getValidBossFightSpawnPosition(player.size, obstacles);
      player.x = pos.x;
      player.y = pos.y;
	  // Clear the trail when the player is moved.
	  playerTrail = [];
      
      // Pause game and display "Boss Fight" until the player moves.
      setPause(true, "orange", "Boss Fight");
    }
    
	// ========== Update Sqr behaviour ==========
	
	function updateEnemies() {
	    // First: Update each square's velocity based on its behavior.
		sqrs.forEach(sqr => {
		  // Preserve the square's original behavior.
		  const baseColor = sqr.originalColor || sqr.color;

		  // Calculate centers for the square and player.
		  const centerPlayerX = player.x + player.size / 2;
		  const centerPlayerY = player.y + player.size / 2;
		  const centerSqrX = sqr.x + sqr.size / 2;
		  const centerSqrY = sqr.y + sqr.size / 2;
		  const dx = centerPlayerX - centerSqrX;
		  const dy = centerPlayerY - centerSqrY;
		  const distance = Math.hypot(dx, dy);

		  // Determine the base speed from the original behavior.
		  let fixedSpeed = 0;
		  if (baseColor === "yellow") {
			fixedSpeed = YELLOW_SPEED;
		  } else if (baseColor === "orange") {
			fixedSpeed = ORANGE_SPEED;
			if (sqr.inMud) fixedSpeed *= MUD_SLOW;
		  } else if (baseColor === "red") {
			fixedSpeed = RED_SPEED;
			if (sqr.inMud) fixedSpeed *= MUD_SLOW;
		  } else {
			fixedSpeed = YELLOW_SPEED;
		  }

		  // ICE_COLOUR squares override their speed.
		  if (sqr.color === ICE_COLOUR) {
			fixedSpeed = ICE_SPEED;
		  }

		  // Determine if this square is running away.
		  const runningAway = (sqr.color === PURPLE_COLOUR || sqr.color === FLASH_COLOUR);

		  // If originally yellow and not running away, use wandering.
		  if (baseColor === "yellow" && !runningAway) {
			// Apply a random perturbation for wandering.
			sqr.speedX += (Math.random() - 0.5) * 0.2;
			sqr.speedY += (Math.random() - 0.5) * 0.2;
			
			// Normalize the speed.
			const currentSpeed = Math.hypot(sqr.speedX, sqr.speedY);
			if (currentSpeed > 0) {
			  sqr.speedX = (sqr.speedX / currentSpeed) * fixedSpeed;
			  sqr.speedY = (sqr.speedY / currentSpeed) * fixedSpeed;
			}
		  } else {
			// For chasing or running away:
			let moveX = 0, moveY = 0;
			if (distance > 0) {
			  if (runningAway) {
				// Reverse the vector: move away from the player.
				moveX = (centerSqrX - centerPlayerX) / distance;
				moveY = (centerSqrY - centerPlayerY) / distance;
			  } else {
				// Otherwise, move toward the player.
				moveX = dx / distance;
				moveY = dy / distance;
			  }
			}
			sqr.speedX = moveX * fixedSpeed;
			sqr.speedY = moveY * fixedSpeed;
		  }
		});

	    // Second: Update position and handle collisions.
	  sqrs.forEach((sqr, index) => {
		// Reset rock collision flag at start of update.
		sqr.collidedWithRock = false;

		// Check for collision with an active orb.
		if (
		  orbActive &&
		  sqr.x < orb.x + orb.size &&
		  sqr.x + sqr.size > orb.x &&
		  sqr.y < orb.y + orb.size &&
		  sqr.y + sqr.size > orb.y
		) {
		  orbCollision(orb.color, orb.shape, "sqr", sqr, index);
		}

		// Determine if the square is in a mud zone.
		let inMud = false;
		for (let zone of mud) {
		  if (isIntersecting({ x: sqr.x, y: sqr.y, size: sqr.size }, zone)) {
			inMud = true;
			break;
		  }
		}
		sqr.inMud = inMud;
		
		// Apply the mud slowdown.
		const slowdownMultiplier = sqr.inMud ? MUD_SLOW : 1;
		let effectiveSpeedX = sqr.speedX * slowdownMultiplier;
		let effectiveSpeedY = sqr.speedY * slowdownMultiplier;
		
		// Store previous position before moving.
		let prevX = sqr.x, prevY = sqr.y;
		sqr.x += effectiveSpeedX;
		sqr.y += effectiveSpeedY;

		// Check collision with rocks.
		for (let obs of rocks) {
		  if (
			sqr.x < obs.x + obs.width &&
			sqr.x + sqr.size > obs.x &&
			sqr.y < obs.y + obs.height &&
			sqr.y + sqr.size > obs.y
		  ) {
			// Revert to previous position.
			sqr.x = prevX;
			sqr.y = prevY;
			// Mark that this square collided with a rock.
			sqr.collidedWithRock = true;
			
			if (sqr.color === "yellow") {
			  // For yellow sqrs, choose a new random direction on bounce.
			  let newAngle = getRandomAngle();
			  sqr.speedX = Math.cos(newAngle) * YELLOW_SPEED;
			  sqr.speedY = Math.sin(newAngle) * YELLOW_SPEED;
			} else {
			  // For orange/red, simply reverse the current direction.
			  sqr.speedX = -sqr.speedX;
			  sqr.speedY = -sqr.speedY;
			}
			
			// Ensure speed is not below half the base speed.
			let baseSpeed = (sqr.color === "red") ? RED_SPEED : (sqr.color === "orange" ? ORANGE_SPEED : YELLOW_SPEED);
			if (Math.abs(sqr.speedX) < baseSpeed * 0.5) {
			  sqr.speedX = baseSpeed * Math.sign(sqr.speedX || 1);
			}
			if (Math.abs(sqr.speedY) < baseSpeed * 0.5) {
			  sqr.speedY = baseSpeed * Math.sign(sqr.speedY || 1);
			}
			
			// Update position with the adjusted speed.
			sqr.x += sqr.speedX;
			sqr.y += sqr.speedY;
			break;
		  }
		}
		
		// Bounce off the canvas edges.
		if (sqr.x <= 0 || sqr.x >= canvas.width - sqr.size) {
		  sqr.speedX = -sqr.speedX;
		  sqr.x += sqr.speedX;
		}
		if (sqr.y <= 0 || sqr.y >= canvas.height - sqr.size) {
		  sqr.speedY = -sqr.speedY;
		  sqr.y += sqr.speedY;
		}
		
		// Sqr collision with the player.
		if (
		  player.x < sqr.x + sqr.size &&
		  player.x + player.size > sqr.x &&
		  player.y < sqr.y + sqr.size &&
		  player.y + player.size > sqr.y
) {
  // If the square is temporarily frozen, remove it on collision.
  if (sqr.temporarilyFrozen) {
    sqr.toRemove = true;
  }
		  if (sqr.temporarilyPurple) {
			sqr.toRemove = true;
		  } else if (player.shieldCount > 0) {
			// Consume one shield and remove the square.
			player.shieldCount--;
			sqr.toRemove = true;
			console.log("Sqr collision - Shield count: " + player.shieldCount);
		  } else {
			// Process a normal hit.
			handlePlayerHit();
		  }
		}
	  });


	  // Clear the rock collision flags for the next frame.
	  sqrs.forEach(sqr => {
		sqr.collidedWithRock = false;
	  });
	}

	// ==================== Main Update loop ====================
	
    function update() {
      // Save player's previous position for collision rollback.
      let playerPrevX = player.x;
      let playerPrevY = player.y;
	  
	if (player.x !== lastPlayerX || player.y !== lastPlayerY) {
	  // The player moved – update the last move time and store new position.
	  lastPlayerMoveTime = Date.now();
	  lastPlayerX = player.x;
	  lastPlayerY = player.y;
	} else {
	  // The player hasn't moved – if more than 6 seconds have passed, set override.
	  if (Date.now() - lastPlayerMoveTime >= 6000) {
		overrideNextBossShot = true;
	  }
	}	  
	  
       if (player.lives < 1) {
        if (!gameOver) {
          player.lives = 0;
          gameOver = true;
        }
        if (!gameOverPrompted) {
          gameOverPrompted = true;
          setTimeout(() => {
            messageOverlay.innerHTML += "<br><span style='font-size: 24px; color: blue;'>Try again?</span>";
            tryAgainAvailable = true;
          }, 1000);
        }
        return;
      }
      if (gameOver) return;
      if (gamePaused) return;
	  
	// Determine if the player is wrapping.
	if (
	  player.x < 0 ||
	  player.y < 0 ||
	  player.x + player.size > canvas.width ||
	  player.y + player.size > canvas.height
	) {
	  isWrapping = true;
	} else {
	  isWrapping = false;
	}
	  
	  // Update boss rotation if the boss exists.
	  if (boss) {
		boss.rotation += bossRotationSpeed; // bossRotationSpeed is set in updateBossState()
	  }
  
      // Award a shield ring if the temporary purple effect is active,
      // there are no enemies left, a shield hasn't been awarded this level,
      if (purplePower && sqrs.length === 0 && !shieldAwardedForCurrentTempPurple) {
        player.shieldCount = Math.min(player.shieldCount + 1, 6);
        shieldAwardedForCurrentTempPurple = true;
		console.log("Area clear - Shield gained: " + player.shieldCount);
      }
      // Recalculate shield ring radii using desired values.
      recalcShieldRadii();
      
	  // Purple Triangle Stuff & purpleOrb Power
		let effectivePlayerSpeed = player.speed;
		let addTrail = false;

		if (hasTriPurple === 1 && player.shieldCount >= 1) {
		  // When the purple triangle is active and the player has one or more shields:
		  // Increase speed by 0.5 per shield.
		  effectivePlayerSpeed = Math.min(player.speed + player.shieldCount * 0.5, player.speed + 3);
		  // Bypass mud slowdown.
		  addTrail = true;
		} else if (purplePower) {
		  // Temporary purple orb effect: no mud slowdown.
		  effectivePlayerSpeed = player.speed;
		  addTrail = true;
		} else {
		  // Player in mud slowdown.
		  for (let zone of mud) {
			if (isIntersecting(player, zone)) {
			  effectivePlayerSpeed = player.speed * 0.2;
			  break;
			}
		  }
		}
		
		// Do the Enemy Updates
		updateEnemies();
		// Do the Rock Updates
		checkRockCollision();
		rockFakeUpdate();
		exitShop();

		// Add the purple trail if either purple effect is active.
		if (addTrail) {
		  playerTrail.push({ x: player.x, y: player.y });
		  if (playerTrail.length > TRAIL_LENGTH) {
			playerTrail.shift();
		  }
		} else {
		  // Otherwise, clear the trail.
		  playerTrail = [];
		}
		
      let dx = 0, dy = 0;
      if (keys["ArrowUp"] || keys["w"]) dy -= effectivePlayerSpeed;
      if (keys["ArrowDown"] || keys["s"]) dy += effectivePlayerSpeed;
      if (keys["ArrowLeft"] || keys["a"]) dx -= effectivePlayerSpeed;
      if (keys["ArrowRight"] || keys["d"]) dx += effectivePlayerSpeed;

		// Touch controls: override keyboard input if touch is active
		if (touchActive) {
			// Calculate the magnitude of the touch displacement.
			let mag = Math.sqrt(touchDx * touchDx + touchDy * touchDy);
			// Set a small deadzone to avoid jittering.
			const deadzone = 5;
			if (mag > deadzone) {
				// Normalize the touch vector (direction only).
				let normX = touchDx / mag;
				let normY = touchDy / mag;
				// Move the player at fixed speed.
				dx = normX * effectivePlayerSpeed;
				dy = normY * effectivePlayerSpeed;
			} else {
				dx = 0;
				dy = 0;
			}
		}
		// End Touch Controls
			  
			  let oldX = player.x;
			  player.x += dx;
			  
				// Clyde Mode [2505]
				if (cheatNoWrap) {
				  // Clamp player's x so they cannot move past the canvas edges
				  if (player.x < 0) player.x = 0;
				  if (player.x + player.size > canvas.width) player.x = canvas.width - player.size;
				}	
				
				// Screen Wrap ability
				// Horizontal wrapping: when half of the player is off the canvas
				if (player.x >= canvas.width - player.size / 2) {
					player.x = -player.size / 2;
				}
				if (player.x < -player.size / 2) {
					player.x = canvas.width - player.size / 2;
				}

				// Vertical wrapping: when half of the player is off the canvas
				if (player.y >= canvas.height - player.size / 2) {
					player.y = -player.size / 2;
				}
				if (player.y < -player.size / 2) {
					player.y = canvas.height - player.size / 2;
				}
				

      
      let oldY = player.y;
      player.y += dy;
		if (cheatNoWrap) {
		  // Clamp player's y so they cannot move past the canvas edges
		  if (player.y < 0) player.y = 0;
		  if (player.y + player.size > canvas.height) player.y = canvas.height - player.size;
		}	  
      if (player.y > canvas.height) player.y = -player.size;
      if (player.y + player.size < 0) player.y = canvas.height;

        // Player collision with Rocks.
		// Handle Rock collisions separately along each axis.
		let tentativeX = player.x; // player.x has been updated by dx already.
		let tentativeY = player.y; // player.y has been updated by dy already.
		// First, check horizontal collision by testing new x with previous y.
		if (isCollidingWithObstacle({ x: tentativeX, y: playerPrevY, size: player.size }, rocks)) {
		  tentativeX = playerPrevX;
		}
		// Next, check vertical collision using the (possibly adjusted) x and new y.
		if (isCollidingWithObstacle({ x: tentativeX, y: tentativeY, size: player.size }, rocks)) {
		  tentativeY = playerPrevY;
		}
		player.x = tentativeX;
		player.y = tentativeY;
      
		// Player collision with orbs
		if (orbActive &&
		player.x < orb.x + orb.size &&
		player.x + player.size > orb.x &&
		player.y < orb.y + orb.size &&
		player.y + player.size > orb.y) {
			orbCollision(orb.color, orb.shape, "player");
		};
      
      // Remove any enemies marked for removal.
      sqrs = sqrs.filter(enemy => !enemy.toRemove);
      
      // Boss fight collisions.
      if (bossFight) {
	  if (!gamePaused) {
		// If no boss rocks remain, set boss color to orange.
		if (bossRocks.length === 0) {

		  	updateBossState();
		}
	  }
        // Player collision with Boss (using bounding box).
        if (boss &&
            player.x < boss.x + boss.size &&
            player.x + player.size > boss.x &&
            player.y < boss.y + boss.size &&
            player.y + player.size > boss.y) {
			if (bossState !== "yellow") {
				bossFail = 1;
				bossState = "yellow";
				triShots = [];
			}
          handlePlayerHit();
        }
        // Player collision with bossMoat.
        if (player.x < 20 ||
            player.y < 20 ||
            player.x + player.size > canvas.width - 20 ||
            player.y + player.size > canvas.height - 20) {
			if (bossState !== "yellow") {
				bossFail = 1;
				bossState = "yellow";
				triShots = [];
			}			
            handlePlayerHit();
        }
        // Player collision with bossRocks.
		// Handle bossRock collisions separately along each axis.
		let tentativeX = player.x; // player.x has been updated by dx already.
		let tentativeY = player.y; // player.y has been updated by dy already.
		// Check horizontal collision by testing new x with previous y.
		if (isCollidingWithObstacle({ x: tentativeX, y: playerPrevY, size: player.size }, bossRocks)) {
		  tentativeX = playerPrevX;
		}
		// Check vertical collision using the (possibly adjusted) x and new y.
		if (isCollidingWithObstacle({ x: tentativeX, y: tentativeY, size: player.size }, bossRocks)) {
		  tentativeY = playerPrevY;
		}
		player.x = tentativeX;
		player.y = tentativeY;
	  
		// Fire a new boss shot if the timer has expired.
		if (bossState === "yellow") {
		  let currentTime = Date.now();
		  if (currentTime - lastBossShotTime >= bossShotInterval) {
			fireBossShot();
			scheduleNextBossShot();
		  }
		}
		// Update existing boss shots.
		updateBossShots();
		updateTriShots();
      }
		checkTriGreenCollision();
		checkTriBlueCollision();
		checkTriPurpleCollision();
    }  // ===== End main update loop=====
    
    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
    
	function drawrock(obs) {
	  // Destructure properties.
	  const { x, y, width, height } = obs;
	  let corners = obs.corners;
	  // Use a default radius based on rock size.
	  let radius = Math.min(width, height) / 4;
	  
	  // If this rock is flagged as rockFake, override its corners and fill style.
	  if (obs.rockFake) {
		// Force all sides to be curved.
		corners = [true, true, true, true];
		// Use the rock's original colour (set in spawnrocks) normally,
		// but if the player is inside (after 500ms collision), switch to a darker colour.
		ctx.fillStyle = obs.inside ? "#1A1A1A" : obs.color;
	  } else {
		// For normal rocks, use their defined colour.
		ctx.fillStyle = obs.color;
	  }
	  
	  // Begin drawing using the (possibly overridden) corners.
	  ctx.beginPath();
	  if (corners[0]) {
		ctx.moveTo(x + radius, y);
	  } else {
		ctx.moveTo(x, y);
	  }
	  if (corners[1]) {
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	  } else {
		ctx.lineTo(x + width, y);
	  }
	  if (corners[2]) {
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	  } else {
		ctx.lineTo(x + width, y + height);
	  }
	  if (corners[3]) {
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	  } else {
		ctx.lineTo(x, y + height);
	  }
	  if (corners[0]) {
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
	  } else {
		ctx.lineTo(x, y);
	  }
	  ctx.closePath();
	  ctx.fill();
	}
    
    function draw() { // Main Draw Loop
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      mud.forEach(zone => {
        ctx.fillStyle = zone.color;
        drawRoundedRect(zone.x, zone.y, zone.width, zone.height, 20);
      });
      rocks.forEach(obs => {
        ctx.fillStyle = obs.color;
        drawrock(obs);
      });
      if (gameOver) {
        ctx.textAlign = "center";
        ctx.font = "bold 30px Arial";
        ctx.fillStyle = "red";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "black";
        ctx.strokeText("GAME OVER", canvas.width / 2, canvas.height / 2);
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
        return;
      }
	  
		// Draw player trail if purple power-up is active
		if (purplePower || (hasTriPurple === 1 && player.shieldCount >= 1)) {
		  ctx.globalAlpha = 0.25; // Semi-transparent effect
		  ctx.fillStyle = PURPLE_COLOUR; // Use the same purple as the power-up

		  playerTrail.forEach((pos, index) => {
			let size = player.size * ((index / TRAIL_LENGTH) * 0.7 + 0.3);
			ctx.fillRect(pos.x + (player.size - size) / 2, pos.y + (player.size - size) / 2, size, size);
		  });

		  ctx.globalAlpha = 1.0; // Reset transparency
		}
		
		ctx.fillStyle = playerIsPink ? "#FFB7CE" : "white";
		ctx.fillRect(player.x, player.y, player.size, player.size);
		
      if (orbActive) {
        if (orb.shape === "hex") {
          // Draw hex orb as a blue hexagon.
          drawBoss(orb.x + orb.size / 2, orb.y + orb.size / 2, orb.size, 0, orb.color);
        } else {
          ctx.fillStyle = orb.color;
          ctx.beginPath();
          ctx.arc(orb.x + orb.size / 2, orb.y + orb.size / 2, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
	    // Draw sqrs
		sqrs.forEach(sqr => {
		  // Set the color based on whether the square is frozen or not
		  if (sqr.frozen) {
			// If frozen, use the ice color
			ctx.fillStyle = ICE_COLOUR;
		  } else {
			// Otherwise, use the normal color
			ctx.fillStyle = sqr.color;
		  }

		  // Draw the sqr
		  ctx.fillRect(sqr.x, sqr.y, sqr.size, sqr.size);

		  // Handle Green Arrow Power
		  if (hasGreenArrow === 1) {
			const centerX = sqr.x + sqr.size / 2;
			const centerY = sqr.y + sqr.size / 2;
			const angle = Math.atan2(sqr.speedY, sqr.speedX);
			const arrowLength = sqr.size / 2;

			// Draw the line indicating direction
			ctx.strokeStyle = "green";
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(centerX, centerY);
			ctx.lineTo(centerX + arrowLength * Math.cos(angle), centerY + arrowLength * Math.sin(angle));
			ctx.stroke();

			// Draw the arrowhead
			const arrowHeadLength = 5; // Increase for a larger arrowhead
			const arrowSpread = Math.PI / 2.5; // Make the arrowhead wider (e.g., 45 degrees)

			ctx.beginPath();
			ctx.moveTo(centerX + arrowLength * Math.cos(angle), centerY + arrowLength * Math.sin(angle));
			ctx.lineTo(centerX + (arrowLength - arrowHeadLength) * Math.cos(angle + arrowSpread), 
					   centerY + (arrowLength - arrowHeadLength) * Math.sin(angle + arrowSpread));
			ctx.lineTo(centerX + (arrowLength - arrowHeadLength) * Math.cos(angle - arrowSpread), 
					   centerY + (arrowLength - arrowHeadLength) * Math.sin(angle - arrowSpread));
			ctx.closePath();
			ctx.fillStyle = "green";
			ctx.fill();
		  }
		});
	  
	  drawTriPower() // Draw Power Triangles
	  
		// Draw shield rings around the player based on player.shieldCount.
		// There are up to 3 rings; each ring gets "activated" at an odd count and "lighter" at the next even count.
		const centerX = player.x + player.size / 2;
		const centerY = player.y + player.size / 2;
		for (let i = 0; i < 3; i++) {
		  // The i-th ring is activated if shieldCount is at least (i*2 + 1)
		  if (player.shieldCount >= i * 2 + 1) {
			// If shieldCount is at least (i*2 + 2), the ring is drawn in dark purple; otherwise, in normal purple.
			let ringColor = (player.shieldCount >= i * 2 + 2) ? PURPLE_COLOUR : DARK_PURPLE;
			ctx.strokeStyle = ringColor;
			ctx.lineWidth = shieldThickness;  // Use your defined shieldThickness
			ctx.beginPath();
			ctx.arc(centerX, centerY, desiredRadii[i], 0, Math.PI * 2);
			ctx.stroke();
		  }
		}
      
      // Draw boss fight elements if active.
      if (bossFight) {
        // Draw bossMoat: a 20px red border around the canvas.
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, canvas.width, 20); // Top border
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20); // Bottom border
        ctx.fillRect(0, 0, 20, canvas.height); // Left border
        ctx.fillRect(canvas.width - 20, 0, 20, canvas.height); // Right border
  
        // Draw Boss.
        if (boss) {
			drawBoss(boss.x + boss.size / 2, boss.y + boss.size / 2, boss.size, boss.rotation, boss.color);
			}		
		}
	
       	// Draw bossShots and triShots.
		drawBossShots();
		drawTriShots();
		
        // Draw bossRocks.
        bossRocks.forEach(br => {
          ctx.fillStyle = br.color;
          drawrock(br);
        });
      }
    
	let lastUpdateTime = 0;
	function gameLoop(timestamp) {
	  if (!lastUpdateTime) {
		lastUpdateTime = timestamp;
	  }
	  const delta = timestamp - lastUpdateTime;
	  
	  // Only update if at least ~16.67ms have passed (about 60fps)
	  if (delta >= 15) {
		update();
		draw();
		updateHUD();
		lastUpdateTime = timestamp;
	  }
	  
	  // Draw joystick overlay
	  if (touchActive) {
		drawJoystickOverlay();
	  }	  
	  requestAnimationFrame(gameLoop);
	}
    
	// Restart Game function
    function restartGame() {
      hudorbIndicator.style.backgroundColor = "grey";
      let pos = getValidSpawnPosition(player.size);
      player = { x: pos.x, y: pos.y, size: 20, speed: basePlayerSpeed, lives: 1, level: 1, shieldCount: 0 };
      progress = 0;
	  setPause(true, "blue", "Level " + player.level);
      gameOver = false;
      gameOverPrompted = false;
      tryAgainAvailable = false;
      orbActive = true;
      controlsLocked = true;
      setTimeout(() => { controlsLocked = false; }, 1000);
      // Reset shield-related variables.
      shieldRings = [];
      shieldAwardedForCurrentTempPurple = false;
      purplePower = false;
      // Reset boss fight state if any.
      bossFight = false;
      boss = null;
      bossRocks = [];
      spawnmud();
	  recalcRockValues();
      spawnrocks();
	  spawnsqrs();
      spawnorb();
	  // Reset boss fight state if any.
	  bossFight = false;
	  boss = null;
	  bossRocks = [];
	  bossShots = [];
    }
	
	// Clear Local Data
	function resetGameData() {
		localStorage.clear();
		location.reload(); // Refresh the game to apply changes
	}
    
    restartGame();
    gameLoop();
    
    let keys = {};
	document.addEventListener("keydown", (event) => {
	  // If in a boss fight and waiting for input, allow movement keys to unpause
	  if (
		bossFight &&
		gamePaused &&
		["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(event.key) &&
		!event.repeat
	  ) {
		resumeGame();
	  } else if (controlsLocked) {
		return;
	  }

	  keys[event.key] = true;

	  const leftKey = keys["ArrowLeft"] || keys["a"];
	  const rightKey = keys["ArrowRight"] || keys["d"];

		// Manual Pause after holding keys for 1 second
		if (!gamePaused && leftKey && rightKey && !boss) {
		  if (!manualPauseTimer) {
			manualPauseTimer = setTimeout(() => {
			  setPause(true, "blue", "Paused");
			  manualPauseTimer = null; // Reset timer after firing
			}, 1000);
		  }
		} else {
		  // If keys are released before the timeout, clear the timer.
		  if (manualPauseTimer) {
			clearTimeout(manualPauseTimer);
			manualPauseTimer = null;
		  }
		}

	  if (gamePaused && (keys["ArrowUp"] || keys["w"] || keys["ArrowDown"] || keys["s"] || leftKey || rightKey)) {
		if (!manualPauseLocked) {
		  resumeGame();
		}
	  }

	  if (gameOver && tryAgainAvailable) {
		if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(event.key)) {
		  restartGame();
		  return;
		}
	  }

	  // Cheat code detection
	  // 0000 - Clear Local
	  // 2505 - Clyde Walls
	  // 3712 - Sophie Pink
	  if ("0123456789".includes(event.key)) {
		cheatCodeBuffer += event.key;
		// Keep only the last 4 digits
		if (cheatCodeBuffer.length > 4) {
		  cheatCodeBuffer = cheatCodeBuffer.slice(-4);
		}
		if (cheatCodeBuffer === "0000") {
		  resetGameData();
		  console.log("Cleared local data");
		}
		if (cheatCodeBuffer === "2505") {
		  cheatNoWrap = true;
		  console.log("Player wrapping disabled!");
		}
		if (cheatCodeBuffer === "3712") {
		  playerIsPink = true;
		  console.log("You are now pink!");
		}
	  }
	});

    document.addEventListener("keyup", (event) => {
      delete keys[event.key];
      if ((event.key === "ArrowLeft" || event.key === "a" || event.key === "ArrowRight" || event.key === "d") && manualPauseTimer) {
        clearTimeout(manualPauseTimer);
        manualPauseTimer = null;
      }
      if (
        !keys["ArrowLeft"] && !keys["ArrowRight"] && !keys["ArrowUp"] && !keys["ArrowDown"] &&
        !keys["w"] && !keys["a"] && !keys["s"] && !keys["d"]
      ) {
        manualPauseLocked = false;
      }
    });
    
	// ========== Mouse Stuff - Debug Tools ==========

	let leftClickTimer = null;
	let leftClickStartTime = 0;
	let middleClickTimer = null;
	let middleClickStartTime = 0;
	
	canvas.addEventListener('mousedown', function(event) {
		let rect = canvas.getBoundingClientRect();
		let mouseX = event.clientX - rect.left;
		let mouseY = event.clientY - rect.top;
	  
		// ========== Left Click Stuff ==========
		if (event.button === 0 && debug) {
		  // If left click is on the player, start the long click timer.
		  if (mouseX >= player.x && mouseX <= player.x + player.size &&
			  mouseY >= player.y && mouseY <= player.y + player.size) {
			leftClickStartTime = Date.now();
			leftClickTimer = setTimeout(() => {
			  player.lives = 999;
			  console.log("Lives set to 999");
			  leftClickTimer = null;
			}, 1000);
			event.preventDefault();
			return;
		  }
		  // Debug-only: Check if orb is clicked to trigger debugSkipLevels(1)
		  if (orbActive && debug) {
			let orbCenterX = orb.x + orb.size / 2;
			let orbCenterY = orb.y + orb.size / 2;
			let dx = mouseX - orbCenterX;
			let dy = mouseY - orbCenterY;
			if (Math.sqrt(dx * dx + dy * dy) <= orb.size / 2) {
			  console.log("Level skipped");
			  debugSkipLevels(1);
			  event.preventDefault();
			  return;
			}
		  }
		  // Debug-only: Process clicks on enemy squares (sqrs)
		  if (debug) {
			let enemyFound = false;
			for (let i = 0; i < sqrs.length; i++) {
			  let enemy = sqrs[i];
			  if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
				  mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
				enemyFound = true;
				console.log("Evolved Enemy");
				if (enemy.color === "yellow") {
				  enemy.color = "orange";
				  enemy.size = ORANGE_SIZE;
				  let angle = Math.atan2(enemy.speedY, enemy.speedX);
				  enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
				  enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
				} else if (enemy.color === "orange") {
				  enemy.color = "red";
				  enemy.size = RED_SIZE;
				  let angle = Math.atan2(enemy.speedY, enemy.speedX);
				  enemy.speedX = Math.cos(angle) * RED_SPEED;
				  enemy.speedY = Math.sin(angle) * RED_SPEED;
				} else if (enemy.color === "red") {
				  console.log("Removed enemy");
				  sqrs.splice(i, 1);
				}
				break;
			  }
			}
		  }
		  event.preventDefault();
		  // ========== Right Click Stuff ==========
		} else if (event.button === 2 && debug) { 
				if (orbActive && debug) {
				  let orbCenterX = orb.x + orb.size / 2;
				  let orbCenterY = orb.y + orb.size / 2;
				  let dx = mouseX - orbCenterX;
				  let dy = mouseY - orbCenterY;
				  if (Math.sqrt(dx * dx + dy * dy) <= orb.size / 2) {
					console.log("Jumped 10 levels");
					debugSkipLevels(10);
					event.preventDefault();
					return;
				  }
				}
				if (debug && mouseX >= player.x && mouseX <= player.x + player.size &&
					mouseY >= player.y && mouseY <= player.y + player.size) {
				  console.log("Life removed");
				  player.lives--; 
				  event.preventDefault();
				  return;
				}
				// Debug-only: Process rock removal, mud removal, and enemy modifications.
				if (debug) {
				  for (let i = 0; i < rocks.length; i++) {
					let rock = rocks[i];
					if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						mouseY >= rock.y && mouseY <= rock.y + rock.height) {
					  console.log("Removed rock");
					  rocks.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < bossRocks.length; i++) {
					let rock = bossRocks[i];
					if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						mouseY >= rock.y && mouseY <= rock.y + rock.height) {
					  console.log("Removed boss rock");
					  bossRocks.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < mud.length; i++) {
					let m = mud[i];
					if (mouseX >= m.x && mouseX <= m.x + m.width &&
						mouseY >= m.y && mouseY <= m.y + m.height) {
					  console.log("Removed mud");
					  mud.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < sqrs.length; i++) {
					let enemy = sqrs[i];
					if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
						mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
					  console.log("Devolved enemy");
					  if (enemy.color === "red") {
						enemy.color = "orange";
						enemy.size = ORANGE_SIZE;
						let angle = Math.atan2(enemy.speedY, enemy.speedX);
						enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
						enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
					  } else if (enemy.color === "orange") {
						enemy.color = "yellow";
						enemy.size = YELLOW_SIZE;
						let angle = Math.atan2(enemy.speedY, enemy.speedX);
						enemy.speedX = Math.cos(angle) * YELLOW_SPEED;
						enemy.speedY = Math.sin(angle) * YELLOW_SPEED;
					  } else if (enemy.color === "yellow") {
						console.log("Removed enemy");
						sqrs.splice(i, 1);
					  }
					  event.preventDefault();
					  return;
					}
				  }
				  // Debug-only: If no enemy was clicked, spawn a new enemy.
				  console.log("Spawned an enemy");
				  let angle = getRandomAngle();
				  let newEnemy = {
					x: mouseX - YELLOW_SIZE / 2,
					y: mouseY - YELLOW_SIZE / 2,
					size: YELLOW_SIZE,
					color: "yellow",
					speedX: Math.cos(angle) * YELLOW_SPEED,
					speedY: Math.sin(angle) * YELLOW_SPEED
				  };
				  sqrs.push(newEnemy);
				  event.preventDefault();
				}
						
				// ========== Middle Click Stuff ==========
				} else if (event.button === 1) {
				  if (!debug) { return }; // Only execute debug features when debug === 1.
					// If middle click is on the player, start a long click timer.
					if (mouseX >= player.x && mouseX <= player.x + player.size &&
						mouseY >= player.y && mouseY <= player.y + player.size) {
					  middleClickStartTime = Date.now();
					  middleClickTimer = setTimeout(() => {
						player.shieldCount = 999;
						console.log("Shields to full! - Shield count: " + player.shieldCount);
						middleClickTimer = null;
					  }, 1000);
					  event.preventDefault();
					  return;
					}
					
					// Debug Middle Click: Orb Cycler.
					if (!orbActive) return;

					const orbCenterX = orb.x + orb.size / 2;
					const orbCenterY = orb.y + orb.size / 2;
					const dx = mouseX - orbCenterX;
					const dy = mouseY - orbCenterY;
					const radius = orb.size / 2;

					if (dx * dx + dy * dy <= radius * radius) {
					  console.log("Cycled orb colour");
					  
					  // Define the cycle states:
					  const cycleStates = [
						{ color: "green", shape: "circle" },
						{ color: "blue", shape: "circle" },
						{ color: PURPLE_COLOUR, shape: "circle" },
						{ color: ICE_COLOUR, shape: "circle" },
						{ color: "green", shape: "hex" },
						{ color: "blue", shape: "hex" }
					  ];
					  
					  // Determine the current state index.
					  const currentIndex = cycleStates.findIndex(
						state => state.color === orb.color && state.shape === orb.shape
					  );
					  
					  // If not found, default to the first state; otherwise, move to the next state.
					  const nextState =
						currentIndex === -1
						  ? cycleStates[0]
						  : cycleStates[(currentIndex + 1) % cycleStates.length];
						  
					  orb.color = nextState.color;
					  orb.shape = nextState.shape;
					  
					  event.preventDefault();
					  return;
					}
					// Debug-only: Process middle click on enemy squares (sqrs) to remove all enemies.
					for (let i = 0; i < sqrs.length; i++) {
					  let enemy = sqrs[i];
					  if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
						  mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
						console.log("Removed all enemies");
						sqrs = [];
						event.preventDefault();
						return;
					  }
					}
					// If middle click is on a rock or boss rock, remove all rocks and boss rocks.
					let hitRock = false;
					for (let i = 0; i < rocks.length; i++) {
					    let rock = rocks[i];
					    if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						    mouseY >= rock.y && mouseY <= rock.y + rock.height) {
						    hitRock = true;
						    break;
					    }
					}
					for (let i = 0; i < bossRocks.length; i++) { // This isn't working for unknown reason
						let bossRock = bossRocks[i];
						if (mouseX >= bossRock.x && mouseX <= bossRock.x + bossRock.width &&
							mouseY >= bossRock.y && mouseY <= bossRock.y + bossRock.height) {
						    hitRock = true;
						    break;
						}
					}
					
					if (hitRock) {
					  console.log("Removed all rocks");
					  rocks = [];
					  bossRocks = [];
					  event.preventDefault();
					  return;
					}
				  event.preventDefault();
				}
		});
		// End of Main Debug Click Features
		
		// Boss debug clicks
		function evolveBoss() {
			if (debug || !boss || !bossFight) return; // No boss to evolve

			if (bossState === "yellow") {
				bossState = "orange";
				updateBossState();
				console.log("Boss evolved to orange!");
			} else if (bossState === "orange") {
				bossState = "red";
				updateBossState();
				console.log("Boss evolved to red!");
			} else if (bossState === "red") {
				console.log("Boss defeated!");
				boss = null;
				bossState = null;
				bossFight = false;
				bossRocks = [];
				bossShots = [];
				setPause(true);
				messageOverlay.textContent = "";
			}
		}

		canvas.addEventListener("click", function(event) {
			if (!boss || !bossFight) return; // Do nothing if no boss is present

			let rect = canvas.getBoundingClientRect();
			let mouseX = event.clientX - rect.left;
			let mouseY = event.clientY - rect.top;

			// Check if the click is inside the boss
			if (
				mouseX >= boss.x &&
				mouseX <= boss.x + boss.size &&
				mouseY >= boss.y &&
				mouseY <= boss.y + boss.size
			) {
				evolveBoss();
			}
		});
	
	canvas.addEventListener("mouseup", function(event) {
	  if (event.button === 0 && debug) {
		if (leftClickTimer) {
		  clearTimeout(leftClickTimer);
		  leftClickTimer = null;
		  player.lives = Math.min(player.lives + 1, 999);
		  console.log("Life added");
		  event.preventDefault();
		}
	  }
	});
	
	canvas.addEventListener("mouseup", function(event) {
	  if (event.button === 1 && debug) {
		if (middleClickTimer) {
		  clearTimeout(middleClickTimer);
		  middleClickTimer = null;
		  player.shieldCount++;
		  console.log("Shields up! - Shield count: " + player.shieldCount);
		  event.preventDefault();
		}
	  }
	});
    
	function debugSkipLevels(levelsToSkip) {
	  if (levelsToSkip === 10) {
		// Calculate the next multiple of 10.
		// (player.level + 1) ensures that if you're exactly on a multiple (e.g., 10),
		// you will jump to the next one (20).
		player.level = Math.ceil((player.level + 1) / 10) * 10;
	  } else {
		player.level += levelsToSkip;
	  }
	  clearLevel();
	  spawnLevel();
	  setPause(true, "green", "Skip to level " + player.level);
	}
	triHud(); // Ensure the HUD updates with saved values
  </script>
</body>
</html>
