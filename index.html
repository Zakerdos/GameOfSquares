<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A Game of Squares</title>
  <style>
    body {
      margin: 0;
      background-color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Title Styles */
    #title {
      text-align: center;
      margin-top: 20px;
      margin-bottom: 10px;
      width: 800px;
    }
    #titleTop {
      color: grey;
      font-size: 24px;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    #titleBottom {
      color: white;
      font-size: 48px;
      font-weight: bold;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    /* HUD Container */
    #hudContainer {
      width: 800px;
      background-color: #333;
      border-radius: 8px;
      padding: 5px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: Arial, sans-serif;
    }
    /* HUD elements */
    .hud-label {
      color: grey;
      font-size: 20px;
    }
    /* Lives: Fixed blue circle that stays the same size */
    #hudLife {
      background-color: blue;
      color: white;
      font-size: 20px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 5px;
    }
    /* Center HUD: Level in white, no extra colon, larger font */
    #hudLevel {
      color: white;
      font-size: 26px;
      font-weight: bold;
      margin: 0 2px 0 0;
    }
    /* Level progression inside a green circle (same size as lives) with white text (no brackets) */
    #hudLevelProg {
      background-color: green;
      color: white;
      font-size: 16px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 2px;
    }
    /* High Score: fixed width for the number */
    #hudHighScore {
      color: white;
      font-size: 20px;
      font-weight: bold;
      width: 30px;
      text-align: center;
      display: inline-block;
      margin-left: 1px;
    }
    /* Containers for left, center, and right parts */
    #hudLeft, #hudCenter, #hudRight {
      display: flex;
      align-items: center;
    }
    /* Game container and canvas */
    #gameContainer {
      position: relative;
      width: 800px;
      height: 600px;
      margin-top: 10px;
    }
    canvas {
      background-color: #111;
      display: block;
    }
    /* Overlay for in-canvas messages */
    #messageOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: Arial, sans-serif;
      font-size: 48px;
      font-weight: bold;
      z-index: 5;
      pointer-events: none;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="title">
    <div id="titleTop">Dave Longhurst presents</div>
    <div id="titleBottom">A Game of Squares</div>
  </div>
  <div id="hudContainer">
    <div id="hudLeft">
      <span class="hud-label">Lives:</span>
      <span id="hudLife">1</span>
    </div>
    <div id="hudCenter">
      <span id="hudLevel">Level 1</span>
      <span id="hudLevelProg">0/5</span>
    </div>
    <div id="hudRight">
      <span class="hud-label">High Score:</span>
      <span id="hudHighScore">1</span>
    </div>
  </div>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="messageOverlay"></div>
  </div>
  <script>
    // Game Version v1.2 – Added purple goal and debug features.
    let debug = 0;
    let highScore = 1;
    // Define our cool purple (slightly more blue than red)
    const PURPLE_COLOR = "#7F00FF";
    // Flag to ensure purple goal only appears once per level.
    let purpleGoalUsed = false;
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const messageOverlay = document.getElementById("messageOverlay");
    const hudLife = document.getElementById("hudLife");
    const hudLevelElem = document.getElementById("hudLevel");
    const hudLevelProg = document.getElementById("hudLevelProg");
    const hudHighScore = document.getElementById("hudHighScore");
    const zoneSize = 250;
    let tryAgainAvailable = false;
    
    let goalActive = true;
    let manualPause = false;
    let manualPauseTimer = null;
    let manualPauseLocked = false;
    let controlsLocked = false;
    
    const YELLOW_SPEED = 1, ORANGE_SPEED = 2, RED_SPEED = 4;
    const YELLOW_SIZE = 20, ORANGE_SIZE = 25, RED_SIZE = 30;
    
    const safeMargin = 30;
    function isTooClose(a, b, margin) {
      return (
        a.x < b.x + b.size + margin &&
        a.x + a.size > b.x - margin &&
        a.y < b.y + b.size + margin &&
        a.y + a.size > b.y - margin
      );
    }
    function getValidSpawnPosition(entitySize, existingEntities = []) {
      let x, y, valid = false;
      let candidate = { x: 0, y: 0, size: entitySize };
      while (!valid) {
        x = Math.random() * (canvas.width - entitySize);
        y = Math.random() * (canvas.height - entitySize);
        candidate.x = x;
        candidate.y = y;
        valid = true;
        for (let ent of existingEntities) {
          if (isTooClose(candidate, ent, safeMargin)) {
            valid = false;
            break;
          }
        }
      }
      return { x, y };
    }
    function getValidEnemySpawnPosition(entitySize) {
      let pos;
      let tries = 0;
      do {
        pos = getValidSpawnPosition(entitySize, obstacles.concat(dangers, [player]));
        tries++;
      } while (
        obstacles.some(obs =>
          pos.x < obs.x + obs.size &&
          pos.x + entitySize > obs.x &&
          pos.y < obs.y + obs.size &&
          pos.y + entitySize > obs.y
        ) && tries < 1000
      );
      return pos;
    }
    function getRandomAngle() {
      return Math.random() * 2 * Math.PI;
    }
    
    const basePlayerSpeed = 5;
    let player = { x: 50, y: 50, size: 20, speed: basePlayerSpeed, lives: 1, level: 1 };
    let progress = 0;
    let goal = { x: 200, y: 200, size: 20, color: "green" };
    let dangers = [];
    let obstacles = [];
    let slowZones = [];
    
    let paused = true;
    let levelPaused = true;
    let hitCooldown = false;
    let gameOver = false;
    let hasScored = false;
    
    function isIntersecting(entity, zone) {
      return !(entity.x + entity.size < zone.x ||
               entity.x > zone.x + zone.width ||
               entity.y + entity.size < zone.y ||
               entity.y > zone.y + zone.height);
    }
    function isCollidingWithObstacles(entity) {
      for (let obs of obstacles) {
        if (
          entity.x < obs.x + obs.width &&
          entity.x + entity.size > obs.x &&
          entity.y < obs.y + obs.height &&
          entity.y + entity.size > obs.y
        ) {
          return true;
        }
      }
      return false;
    }
    
    function getRandomCornerPattern() {
      let pattern;
      do {
        pattern = [
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5
        ];
      } while (pattern.filter(c => c).length === 0 || pattern.filter(c => c).length === 4);
      return pattern;
    }
    
    function spawnSlowZones() {
      slowZones = [];
      if (player.level === 1) return;
      let count = 1;
      if (player.level >= 50) count = 5;
      else if (player.level >= 40) count = 4;
      else if (player.level >= 30) count = 3;
      else if (player.level >= 20) count = 2;
      count = Math.min(count, 5);
      for (let i = 0; i < count; i++) {
        slowZones.push({
          x: Math.random() * (canvas.width - zoneSize),
          y: Math.random() * (canvas.height - zoneSize),
          width: zoneSize,
          height: zoneSize,
          color: "#5D3A1A"
        });
      }
    }
    
    function spawnObstacles() {
      obstacles = [];
      if (player.level === 1) return;
      let count = Math.floor(Math.random() * Math.floor(player.level / 2)) + 1;
      const shapes = [
        { width: 50, height: 50 },
        { width: 50, height: 100 },
        { width: 100, height: 50 },
        { width: 75, height: 75 }
      ];
      for (let i = 0; i < count; i++) {
        let shape = shapes[Math.floor(Math.random() * shapes.length)];
        let obstacleSize = Math.max(shape.width, shape.height);
        let pos = getValidSpawnPosition(obstacleSize, obstacles.concat([player]));
        let corners = getRandomCornerPattern();
        obstacles.push({ 
          x: pos.x, 
          y: pos.y, 
          width: shape.width, 
          height: shape.height, 
          size: obstacleSize, 
          color: "#222",
          corners: corners
        });
      }
    }
    
    function spawnDangers() {
      dangers = [];
      let totalEnemies = player.level;
      let redCount = Math.floor(player.level / 25);
      let orangeCount = Math.floor(player.level / 10);
      for (let i = 0; i < totalEnemies; i++) {
        let enemy = { x: 0, y: 0, size: YELLOW_SIZE, speedX: 0, speedY: 0, color: "yellow" };
        if (i < redCount) {
          enemy.color = "red";
          enemy.size = RED_SIZE;
        } else if (i < redCount + orangeCount) {
          enemy.color = "orange";
          enemy.size = ORANGE_SIZE;
        } else {
          enemy.color = "yellow";
          enemy.size = YELLOW_SIZE;
        }
        let pos = getValidEnemySpawnPosition(enemy.size);
        enemy.x = pos.x;
        enemy.y = pos.y;
        let angle = getRandomAngle();
        if (enemy.color === "red") {
          enemy.speedX = Math.cos(angle) * RED_SPEED;
          enemy.speedY = Math.sin(angle) * RED_SPEED;
        } else if (enemy.color === "orange") {
          enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
          enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
        } else {
          enemy.speedX = Math.cos(angle) * YELLOW_SPEED;
          enemy.speedY = Math.sin(angle) * YELLOW_SPEED;
        }
        dangers.push(enemy);
      }
    }
    
    function spawnGoal() {
      goalActive = true;
      const minDistance = 250;
      let pos, distance;
      const playerCenterX = player.x + player.size / 2;
      const playerCenterY = player.y + player.size / 2;
      do {
        pos = getValidSpawnPosition(goal.size, obstacles.concat(dangers, [player]));
        const goalCenterX = pos.x + goal.size / 2;
        const goalCenterY = pos.y + goal.size / 2;
        const dx = goalCenterX - playerCenterX;
        const dy = goalCenterY - playerCenterY;
        distance = Math.sqrt(dx * dx + dy * dy);
      } while (distance < minDistance);
      goal.x = pos.x;
      goal.y = pos.y;
      if (progress === 4) {
        goal.color = "blue";
      } else if (progress >= 1 && progress <= 3 && !purpleGoalUsed) {
        if (Math.random() < 0.1) {
          goal.color = PURPLE_COLOR;
          purpleGoalUsed = true;
        } else {
          goal.color = "green";
        }
      } else {
        goal.color = "green";
      }
    }
    
    function resetAllEnemySpeeds() {
      dangers.forEach(enemy => {
        if (enemy.color === "red") {
          enemy.speedX = Math.sign(enemy.speedX) * RED_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * RED_SPEED;
        } else if (enemy.color === "orange") {
          enemy.speedX = Math.sign(enemy.speedX) * ORANGE_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * ORANGE_SPEED;
        } else {
          enemy.speedX = Math.sign(enemy.speedX) * YELLOW_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * YELLOW_SPEED;
        }
      });
    }
    
    function updateHUD() {
      hudLife.textContent = player.lives;
      hudLevelElem.textContent = "Level " + player.level;
      hudLevelProg.textContent = `${progress}/5`;
      if (player.level > highScore) {
        highScore = player.level;
      }
      hudHighScore.textContent = highScore;
    }
    
    function processGoalCollision() {
      goalActive = false;
      resetAllEnemySpeeds();
      if (goal.color === PURPLE_COLOR) {
        // Purple goal: do not increase progress.
        // Make all enemies temporarily purple.
        dangers.forEach(enemy => {
          if (!enemy.temporarilyPurple) {
            enemy.originalColor = enemy.color;
            enemy.color = PURPLE_COLOR;
            enemy.temporarilyPurple = true;
          }
        });
        // Revert enemy colors after 5 seconds.
        setTimeout(() => {
          dangers.forEach(enemy => {
            if (enemy.temporarilyPurple) {
              enemy.color = enemy.originalColor || enemy.color;
              delete enemy.temporarilyPurple;
              delete enemy.originalColor;
            }
          });
        }, 5000);
        setTimeout(spawnGoal, 1000);
      } else if (goal.color === "blue") {
        progress++;
        player.lives++;
        hasScored = true;
        if (progress >= 5) {
          player.level++;
          purpleGoalUsed = false;
          spawnDangers();
          spawnSlowZones();
          spawnObstacles();
          progress = 0;
          levelPaused = true;
          paused = true;
          messageOverlay.style.color = "blue";
          messageOverlay.textContent = `Level ${player.level}`;
          controlsLocked = true;
          setTimeout(() => { controlsLocked = false; }, 1000);
          spawnGoal();
        } else {
          setTimeout(spawnGoal, 1000);
        }
      } else { // Green goal
        progress++;
        if (progress >= 5) {
          player.level++;
          purpleGoalUsed = false;
          spawnDangers();
          spawnSlowZones();
          spawnObstacles();
          progress = 0;
          levelPaused = true;
          paused = true;
          messageOverlay.style.color = "blue";
          messageOverlay.textContent = `Level ${player.level}`;
          controlsLocked = true;
          setTimeout(() => { controlsLocked = false; }, 1000);
          spawnGoal();
        } else {
          setTimeout(spawnGoal, 1000);
        }
      }
    }
    
    // Debug function to skip levels.
    function debugSkipLevels(levelsToSkip) {
      player.level += levelsToSkip;
      purpleGoalUsed = false;
      spawnDangers();
      spawnSlowZones();
      spawnObstacles();
      progress = 0;
      levelPaused = true;
      paused = true;
      messageOverlay.style.color = "blue";
      messageOverlay.textContent = `Level ${player.level}`;
      controlsLocked = true;
      setTimeout(() => { controlsLocked = false; }, 1000);
      spawnGoal();
    }
    
    let keys = {};
    document.addEventListener("keydown", (event) => {
      if (controlsLocked) return;
      keys[event.key] = true;
      
      const leftKey = keys["ArrowLeft"] || keys["a"];
      const rightKey = keys["ArrowRight"] || keys["d"];
      if (!manualPause && leftKey && rightKey) {
        if (!manualPauseTimer) {
          manualPauseTimer = setTimeout(() => {
            if ((keys["ArrowLeft"] || keys["a"]) && (keys["ArrowRight"] || keys["d"])) {
              manualPause = true;
              paused = true;
              messageOverlay.style.color = "blue";
              messageOverlay.textContent = "Paused";
              manualPauseTimer = null;
              manualPauseLocked = true;
            }
          }, 1000);
        }
      }
      
      if (manualPause && (keys["ArrowUp"] || keys["w"] || keys["ArrowDown"] || keys["s"] || leftKey || rightKey)) {
        if (!manualPauseLocked) {
          manualPause = false;
          paused = false;
          messageOverlay.textContent = "";
        }
      }
      
      if (gameOver && tryAgainAvailable) {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(event.key)) {
          restartGame();
          return;
        }
      }
      if (!manualPause && (levelPaused || (paused && !hitCooldown)) && !gameOver) {
        levelPaused = false;
        paused = false;
        messageOverlay.textContent = "";
      }
    });
    document.addEventListener("keyup", (event) => {
      delete keys[event.key];
      if ((event.key === "ArrowLeft" || event.key === "a" || event.key === "ArrowRight" || event.key === "d") && manualPauseTimer) {
        clearTimeout(manualPauseTimer);
        manualPauseTimer = null;
      }
      if (
        !keys["ArrowLeft"] && !keys["ArrowRight"] && !keys["ArrowUp"] && !keys["ArrowDown"] &&
        !keys["w"] && !keys["a"] && !keys["s"] && !keys["d"]
      ) {
        manualPauseLocked = false;
      }
    });
    
    function handlePlayerHit() {
      if (!paused) {
        if (player.lives <= 1) {
          player.lives = 0;
          gameOver = true;
          setTimeout(() => {
            messageOverlay.innerHTML += "<br><span style='font-size: 24px;'>Try again?</span>";
            tryAgainAvailable = true;
          }, 1000);
          return;
        }
        paused = true;
        hitCooldown = true;
        player.lives--;
        messageOverlay.style.color = "orange";
        messageOverlay.textContent = "Life Lost";
        let pos = getValidSpawnPosition(player.size, obstacles.concat(dangers, [goal]));
        player.x = pos.x;
        player.y = pos.y;
        setTimeout(() => { hitCooldown = false; }, 1000);
      }
    }
    
    function update() {
      if (gameOver) return;
      if (paused) return;
      
      let effectivePlayerSpeed = player.speed;
      for (let zone of slowZones) {
        if (isIntersecting(player, zone)) {
          effectivePlayerSpeed = player.speed * 0.25;
          break;
        }
      }
      
      let dx = 0, dy = 0;
      if (keys["ArrowUp"] || keys["w"]) dy -= effectivePlayerSpeed;
      if (keys["ArrowDown"] || keys["s"]) dy += effectivePlayerSpeed;
      if (keys["ArrowLeft"] || keys["a"]) dx -= effectivePlayerSpeed;
      if (keys["ArrowRight"] || keys["d"]) dx += effectivePlayerSpeed;
      
      let oldX = player.x;
      player.x += dx;
      if (player.x > canvas.width) player.x = -player.size;
      if (player.x + player.size < 0) player.x = canvas.width;
      if (isCollidingWithObstacles(player)) {
        player.x = oldX;
      }
      
      let oldY = player.y;
      player.y += dy;
      if (player.y > canvas.height) player.y = -player.size;
      if (player.y + player.size < 0) player.y = canvas.height;
      if (isCollidingWithObstacles(player)) {
        player.y = oldY;
      }
      
      if (goalActive &&
          player.x < goal.x + goal.size &&
          player.x + player.size > goal.x &&
          player.y < goal.y + goal.size &&
          player.y + player.size > goal.y) {
        processGoalCollision();
      }
      
      dangers.forEach(danger => {
        // Check enemy-goal collisions.
        if (goalActive &&
            danger.x < goal.x + goal.size &&
            danger.x + danger.size > goal.x &&
            danger.y < goal.y + goal.size &&
            danger.y + danger.size > goal.y) {
          goalActive = false;
          resetAllEnemySpeeds();
          if (goal.color === PURPLE_COLOR) {
            // When the goal is purple, do nothing (no progression change)
          } else if (danger.color === "yellow") {
            danger.color = "orange";
            danger.size = ORANGE_SIZE;
            let angle = Math.atan2(danger.speedY, danger.speedX);
            danger.speedX = Math.cos(angle) * ORANGE_SPEED;
            danger.speedY = Math.sin(angle) * ORANGE_SPEED;
          } else if (danger.color === "orange") {
            danger.color = "red";
            danger.size = RED_SIZE;
            let angle = Math.atan2(danger.speedY, danger.speedX);
            danger.speedX = Math.cos(angle) * RED_SPEED;
            danger.speedY = Math.sin(angle) * RED_SPEED;
          } else if (danger.color === "red") {
            // If red enemy collides with a non-purple goal, decrease progress.
            progress = Math.max(0, progress - 1);
            goal.color = "green";
          }
          setTimeout(spawnGoal, 1000);
        }
        
        // Update enemy movement.
        if (danger.color === "red") {
          let centerPlayerX = player.x + player.size / 2;
          let centerPlayerY = player.y + player.size / 2;
          let centerEnemyX = danger.x + danger.size / 2;
          let centerEnemyY = danger.y + danger.size / 2;
          let dxTarget = centerPlayerX - centerEnemyX;
          let dyTarget = centerPlayerY - centerEnemyY;
          let dist = Math.sqrt(dxTarget * dxTarget + dyTarget * dyTarget);
          if (dist > 0) {
            let speedMag = Math.sqrt(danger.speedX * danger.speedX + danger.speedY * danger.speedY);
            danger.speedX = speedMag * (dxTarget / dist);
            danger.speedY = speedMag * (dyTarget / dist);
          }
        } else if (danger.color === "orange") {
          let centerPlayerX = player.x + player.size / 2;
          let centerPlayerY = player.y + player.size / 2;
          let centerEnemyX = danger.x + danger.size / 2;
          let centerEnemyY = danger.y + danger.size / 2;
          let dxTarget = centerPlayerX - centerEnemyX;
          let dyTarget = centerPlayerY - centerEnemyY;
          let dist = Math.sqrt(dxTarget * dxTarget + dyTarget * dyTarget);
          if (dist > 0) {
            let speedMag = Math.sqrt(danger.speedX * danger.speedX + danger.speedY * danger.speedY);
            let targetSpeedX = (dxTarget / dist) * speedMag;
            let targetSpeedY = (dyTarget / dist) * speedMag;
            danger.speedX = danger.speedX * 0.5 + targetSpeedX * 0.5;
            danger.speedY = danger.speedY * 0.5 + targetSpeedY * 0.5;
          }
        }
      
        let slowdownMultiplier = 1;
        for (let zone of slowZones) {
          if (isIntersecting({ x: danger.x, y: danger.y, size: danger.size }, zone)) {
            slowdownMultiplier = 0.25;
            break;
          }
        }
        let effectiveSpeedX = danger.speedX * slowdownMultiplier;
        let effectiveSpeedY = danger.speedY * slowdownMultiplier;
      
        let prevX = danger.x, prevY = danger.y;
        danger.x += effectiveSpeedX;
        danger.y += effectiveSpeedY;
      
        for (let obs of obstacles) {
          if (
            danger.x < obs.x + obs.width &&
            danger.x + danger.size > obs.x &&
            danger.y < obs.y + obs.height &&
            danger.y + danger.size > obs.y
          ) {
            danger.x = prevX;
            danger.y = prevY;
            danger.speedX = -danger.speedX;
            danger.speedY = -danger.speedY;
            let baseSpeed = (danger.color === "red") ? RED_SPEED : ((danger.color === "orange") ? ORANGE_SPEED : YELLOW_SPEED);
            if (Math.abs(danger.speedX) < baseSpeed * 0.5) {
              danger.speedX = baseSpeed * Math.sign(danger.speedX || 1);
            }
            if (Math.abs(danger.speedY) < baseSpeed * 0.5) {
              danger.speedY = baseSpeed * Math.sign(danger.speedY || 1);
            }
            danger.x += danger.speedX;
            danger.y += danger.speedY;
            break;
          }
        }
        if (danger.x <= 0 || danger.x >= canvas.width - danger.size) {
          danger.speedX = -danger.speedX;
          danger.x += danger.speedX;
        }
        if (danger.y <= 0 || danger.y >= canvas.height - danger.size) {
          danger.speedY = -danger.speedY;
          danger.y += danger.speedY;
        }
        // Player collision with enemy.
        if (
          player.x < danger.x + danger.size &&
          player.x + player.size > danger.x &&
          player.y < danger.y + danger.size &&
          player.y + player.size > danger.y
        ) {
          if (danger.temporarilyPurple) {
            danger.toRemove = true;
          } else {
            handlePlayerHit();
          }
        }
      });
      // Remove any enemies marked for removal.
      dangers = dangers.filter(enemy => !enemy.toRemove);
    }
    
    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
    
    function drawObstacle(obs) {
      const { x, y, width, height, corners } = obs;
      const radius = Math.min(width, height) / 4;
      ctx.beginPath();
      if (corners[0]) {
        ctx.moveTo(x + radius, y);
      } else {
        ctx.moveTo(x, y);
      }
      if (corners[1]) {
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      } else {
        ctx.lineTo(x + width, y);
      }
      if (corners[2]) {
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      } else {
        ctx.lineTo(x + width, y + height);
      }
      if (corners[3]) {
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      } else {
        ctx.lineTo(x, y + height);
      }
      if (corners[0]) {
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
      } else {
        ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      slowZones.forEach(zone => {
        ctx.fillStyle = zone.color;
        drawRoundedRect(zone.x, zone.y, zone.width, zone.height, 20);
      });
      obstacles.forEach(obs => {
        ctx.fillStyle = obs.color;
        drawObstacle(obs);
      });
      if (gameOver) {
        ctx.textAlign = "center";
        ctx.font = "bold 30px Arial";
        ctx.fillStyle = "red";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "black";
        ctx.strokeText("GAME OVER", canvas.width / 2, canvas.height / 2);
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
        return;
      }
      ctx.fillStyle = "white";
      ctx.fillRect(player.x, player.y, player.size, player.size);
      if (goalActive) {
        ctx.fillStyle = goal.color;
        ctx.beginPath();
        ctx.arc(goal.x + goal.size / 2, goal.y + goal.size / 2, goal.size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
      dangers.forEach(danger => {
        ctx.fillStyle = danger.color;
        ctx.fillRect(danger.x, danger.y, danger.size, danger.size);
      });
    }
    
    function gameLoop() {
      update();
      draw();
      updateHUD();
      requestAnimationFrame(gameLoop);
    }
    
    function restartGame() {
      let pos = getValidSpawnPosition(player.size);
      player = { x: pos.x, y: pos.y, size: 20, speed: basePlayerSpeed, lives: 1, level: 1 };
      progress = 0;
      hasScored = false;
      paused = true;
      levelPaused = true;
      gameOver = false;
      tryAgainAvailable = false;
      goalActive = true;
      manualPause = false;
      manualPauseTimer = null;
      manualPauseLocked = false;
      messageOverlay.style.color = "blue";
      messageOverlay.textContent = `Level ${player.level}`;
      controlsLocked = true;
      setTimeout(() => { controlsLocked = false; }, 1000);
      spawnObstacles();
      spawnDangers();
      spawnSlowZones();
      spawnGoal();
    }
    
    restartGame();
    gameLoop();
    
    setInterval(resetAllEnemySpeeds, 1000);
    
    // Debug mouse click handler.
    canvas.addEventListener('mousedown', function(event) {
      if (debug !== 1 || !manualPause) return;
      let rect = canvas.getBoundingClientRect();
      let mouseX = event.clientX - rect.left;
      let mouseY = event.clientY - rect.top;
      
      // Left click
      if (event.button === 0) {
        if (mouseX >= player.x && mouseX <= player.x + player.size &&
            mouseY >= player.y && mouseY <= player.y + player.size) {
          player.lives++;
          event.preventDefault();
          return;
        }
        if (goalActive) {
          let goalCenterX = goal.x + goal.size / 2;
          let goalCenterY = goal.y + goal.size / 2;
          let dx = mouseX - goalCenterX;
          let dy = mouseY - goalCenterY;
          if (Math.sqrt(dx * dx + dy * dy) <= goal.size / 2) {
            // Debug: left click on goal → skip 1 level.
            debugSkipLevels(1);
            event.preventDefault();
            return;
          }
        }
        // Existing enemy click handling remains.
        let enemyFound = false;
        for (let i = 0; i < dangers.length; i++) {
          let enemy = dangers[i];
          if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
              mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
            enemyFound = true;
            if (enemy.color === "yellow") {
              enemy.color = "orange";
              enemy.size = ORANGE_SIZE;
              let angle = Math.atan2(enemy.speedY, enemy.speedX);
              enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
              enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
            } else if (enemy.color === "orange") {
              enemy.color = "red";
              enemy.size = RED_SIZE;
              let angle = Math.atan2(enemy.speedY, enemy.speedX);
              enemy.speedX = Math.cos(angle) * RED_SPEED;
              enemy.speedY = Math.sin(angle) * RED_SPEED;
            }
            break;
          }
        }
        if (!enemyFound) {
          let angle = getRandomAngle();
          let newEnemy = {
            x: mouseX - YELLOW_SIZE / 2,
            y: mouseY - YELLOW_SIZE / 2,
            size: YELLOW_SIZE,
            color: "yellow",
            speedX: Math.cos(angle) * YELLOW_SPEED,
            speedY: Math.sin(angle) * YELLOW_SPEED
          };
          dangers.push(newEnemy);
        }
      } else if (event.button === 2) { // Right click
        if (goalActive) {
          let goalCenterX = goal.x + goal.size / 2;
          let goalCenterY = goal.y + goal.size / 2;
          let dx = mouseX - goalCenterX;
          let dy = mouseY - goalCenterY;
          if (Math.sqrt(dx * dx + dy * dy) <= goal.size / 2) {
            // Debug: right click on goal → skip 10 levels.
            debugSkipLevels(10);
            event.preventDefault();
            return;
          }
        }
        if (mouseX >= player.x && mouseX <= player.x + player.size &&
            mouseY >= player.y && mouseY <= player.y + player.size) {
          player.lives--;
          if (player.lives <= 0) {
            player.lives = 0;
            gameOver = true;
            messageOverlay.style.color = "red";
            messageOverlay.textContent = "GAME OVER";
          }
          event.preventDefault();
          return;
        }
        for (let i = 0; i < dangers.length; i++) {
          let enemy = dangers[i];
          if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
              mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
            if (enemy.color === "red") {
              enemy.color = "orange";
              enemy.size = ORANGE_SIZE;
              let angle = Math.atan2(enemy.speedY, enemy.speedX);
              enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
              enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
            } else if (enemy.color === "orange") {
              enemy.color = "yellow";
              enemy.size = YELLOW_SIZE;
              let angle = Math.atan2(enemy.speedY, enemy.speedX);
              enemy.speedX = Math.cos(angle) * YELLOW_SPEED;
              enemy.speedY = Math.sin(angle) * YELLOW_SPEED;
            } else if (enemy.color === "yellow") {
              dangers.splice(i, 1);
            }
            break;
          }
        }
      } else if (event.button === 1) { // Middle click
        if (goalActive) {
          let goalCenterX = goal.x + goal.size / 2;
          let goalCenterY = goal.y + goal.size / 2;
          let dx = mouseX - goalCenterX;
          let dy = mouseY - goalCenterY;
          if (Math.sqrt(dx * dx + dy * dy) <= goal.size / 2) {
            // Toggle goal color between green and purple.
            if (goal.color === "green") {
              goal.color = PURPLE_COLOR;
            } else if (goal.color === PURPLE_COLOR) {
              goal.color = "green";
            }
            event.preventDefault();
            return;
          }
        }
      }
      event.preventDefault();
    });
    canvas.addEventListener('contextmenu', function(event) {
      if (debug === 1) event.preventDefault();
    });
  </script>
</body>
</html>
