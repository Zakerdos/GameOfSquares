<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=800, initial-scale=1.0" />
  <title>A Game of Squares</title>
  <style>
	html, body {
	  touch-action: none;  /* Disables default touch actions like scrolling and zooming */
	}
    body {
      margin: 0;
      background-color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Title Styles */
    #title {
      text-align: center;
      margin-top: 20px;
      margin-bottom: 10px;
      width: 800px;
	  text-shadow: 0 0 2px rgba(0, 0, 0, 1);
    }
    #titleTop {
      color: grey;
      font-size: 24px;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    #titleBottom {
      color: white;
      font-size: 48px;
      font-weight: bold;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    /* HUD Container */
    #hudContainer {
      width: 800px;
      background-color: #333;
      border-radius: 8px;
      padding: 5px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: Arial, sans-serif;
	  position: relative;
	  text-shadow: 0 0 2px rgba(0, 0, 0, 1);
	  box-shadow: 0 0 2px rgba(0, 0, 0, 1);
    }
	#hudTriangles {
	  position: absolute;
	  right: 180px;  /* adjust this value as needed so it sits nicely between Level and High Score */
	  top: 50%;
	  transform: translateY(-50%);
	  display: flex;
	  gap: 10px;  /* gap between triangles */
	}
	.triangle.green {
	  box-shadow: 0 0 2px rgba(0, 0, 0, 1);
	}
	.triangle.blue {
	  box-shadow: 0 0 2px rgba(0, 0, 0, 1);
	}
	.triangle.purple {
	  box-shadow: 0 0 2px rgba(0, 0, 0, 1);
	}	

	/* Ensure your HUD triangles have the basic triangle shape */
	#hudTriangles .triangle {
	  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
	  position: relative; /* Needed for pseudo-element positioning */
	}

	/* For the green triangle with an internal stroke */
	#hudTriangles .triangle.withInnerStroke.green {
	  /* This element will serve as the background stroke, so use the darker version */
	  background-color: #04632d; 
	}
	
		/* For the blue triangle with an internal stroke */
	#hudTriangles .triangle.withInnerStroke.blue {
	  /* This element will serve as the background stroke, so use the darker version */
	  background-color: #0202eb; 
	}
	
	/* For the purple triangle with an internal stroke */
	#hudTriangles .triangle.withInnerStroke.purple {
	  /* This element will serve as the background stroke, so use the darker version */
	  background-color: #6A00E6; 
	}

	/* The pseudo-element creates the inner triangle in the main color */
	#hudTriangles .triangle.withInnerStroke.green::after {
	  content: "";
	  position: absolute;
	  /* Offset on all sides */
	  top: 7px;
	  left: 5px;
	  right: 5px;
	  bottom: 3px;
	  background-color: #008000; /* main green colour */
	  clip-path: inherit; /* same triangle shape */
	  pointer-events: none; /* so it doesn't interfere with clicks */
	  box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.8);
	}

	/* The pseudo-element creates the inner triangle in the main color */
	#hudTriangles .triangle.withInnerStroke.blue::after {
	  content: "";
	  position: absolute;
	  /* Offset on all sides */
	  top: 7px;
	  left: 5px;
	  right: 5px;
	  bottom: 3px;
	  background-color: #0000FF; /* main blue colour */
	  clip-path: inherit; /* same triangle shape */
	  pointer-events: none; /* so it doesn't interfere with clicks */
	  box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.8);
	}
	
	/* The pseudo-element creates the inner triangle in the main color */
	#hudTriangles .triangle.withInnerStroke.purple::after {
	  content: "";
	  position: absolute;
	  /* Offset on all sides */
	  top: 7px;
	  left: 5px;
	  right: 5px;
	  bottom: 3px;
	  background-color: #7F00FF; /* main purple colour */
	  clip-path: inherit; /* same triangle shape */
	  pointer-events: none; /* so it doesn't interfere with clicks */
	  box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.8);
	}

	/* Creating an equilateral triangle pointing upward. */
	.triangle {
	  width: 41px; /* approximates the base of an equilateral triangle with 35px height */
	  height: 35px;
	  background-color: #202020;
	  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
	  box-shadow: inset -10px -5px 5px rgba(0, 0, 0, 0.5); /* adjust shadow as needed */
	}
    /* HUD elements */
    .hud-label {
      color: grey;
      font-size: 20px;
    }
    /* Lives: Fixed blue circle that stays the same size */
    #hudLife {
      background-color: blue;
      color: white;
      font-size: 18px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 5px;
	  text-shadow: 0 0 2px rgba(0, 0, 0, 1);
	  box-shadow: 0 0 2px rgba(0, 0, 0, 1);
    }
	#hudLife.shielded {
	  box-shadow: 0 0 0 3px #7F00FF;
	}
	#hudShield {
	  display: block;
	  color: grey;
	  font-size: 12px;
	  font-weight: bold;
	  border-radius: 50%;
	  width: 40px;
	  height: 40px;
	  text-align: center;
	  line-height: 40px;
	  transform: translateY(14px);
	  margin-left: -40px;
	  text-shadow: 0 0 2px rgba(0, 0, 0, 1);
	}
    /* Center HUD */
    #hudLevel {
      color: white;
      font-size: 26px;
      font-weight: bold;
      margin: 0 2px 0 0;
    }
    /* Level progression */
    #hudLevelProg {
      background-color: green;
      color: white;
      font-size: 16px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 2px;
      display: inline-block;
      position: relative;
	  text-shadow: 0 0 2px rgba(0, 0, 0, 1);
	  box-shadow: 0 0 2px rgba(0, 0, 0, 1);
    }
    /* The tiny indicator inside the green circle */
    #hudorbIndicator {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background-color: grey;
      border-radius: 50%;
	  box-shadow: 0 0 2px rgba(0, 0, 0, 1);
    }
    /* High Score: fixed width for the number */
    #hudHighScore {
      color: white;
      font-size: 20px;
      font-weight: bold;
      width: 30px;
      text-align: center;
      display: inline-block;
      margin-left: 1px;
    }
    /* Containers for left, center, and right parts */
    #hudLeft, #hudCenter, #hudRight {
      display: flex;
      align-items: center;
    }
    /* Game container and canvas */
    #gameContainer {
      position: relative;
      width: 800px;
      height: 600px;
      margin-top: 10px;
    }
    canvas {
      background-color: #111;
      display: block;
    }
    /* Overlay for in-canvas messages */
    #messageOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: Arial, sans-serif;
      font-size: 48px;
      font-weight: bold;
      z-index: 5;
      pointer-events: none;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      text-align: center;
    }
	#bottomBar {
	  width: 800px;
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  font-family: Arial, sans-serif;
	  font-size: 12px;
	  margin-top: 2px;
	}

	#debugModeIndicator {
	  text-align: left;
	  color: blue;
	}

	#devVersion {
	  text-align: right;
	  color: #2a2a2a;
	}
	.glow {
	  animation: glowEffect 1s infinite alternate;
	}
	
	.frozen {
	  position: relative;
	  background-color: rgba(19, 200, 207, 0.5); /* ICE_COLOUR with 50% transparency */
	  pointer-events: none; /* Prevents interaction while frozen */
	  z-index: 10; /* Ensures it sits on top of the square */
	}

	.frozen::before {
	  content: '';
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  bottom: 0;
	  background-color: rgba(19, 200, 207, 0.5); /* Icy overlay */
	  pointer-events: none; /* Ensures overlay doesn't block interactions */
	}	

	@keyframes glowEffect {
	  from {
		filter: brightness(1);
	  }
	  to {
		filter: brightness(1.5);
	  }
	}
  </style>
</head>
<body>
  <div id="title">
    <div id="titleTop">Dave Longhurst presents</div>
    <div id="titleBottom">A Game of Squares</div>
  </div>
	<div id="hudContainer">
	  <div id="hudLeft">
		<span class="hud-label">Lives</span>
		<span id="hudLife">1</span>
		<span id="hudShield"></span>		
	  </div>
	  <div id="hudCenter">
		<span id="hudLevel">Level 1</span>
		<span id="hudLevelProg">0/5
		  <div id="hudorbIndicator"></div>
		</span>
	  </div>
	  <div id="hudTriangles">
		<div class="triangle"></div>
		<div class="triangle"></div>
		<div class="triangle"></div>
	  </div>
	  <div id="hudRight">
		<span class="hud-label">High Score</span>
		<span id="hudHighScore">1</span>
	  </div>
	</div>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="messageOverlay"></div>
  </div>
  <div id="bottomBar">
    <div id="debugModeIndicator"></div>
    <div id="devVersion">v1.5.2</div>
  </div>
  <script>
    let debug = 0;
	if (debug) {
	  document.getElementById("debugModeIndicator").textContent = "Debug Mode";
	} else {
	  document.getElementById("debugModeIndicator").textContent = "";
	}
	
	// Click HUD triangles
	if (debug) {
	  const triangles = document.querySelectorAll("#hudTriangles .triangle");
	  if (triangles.length >= 3) {
		// Left triangle toggles hasTriGreen
		triangles[0].addEventListener("click", () => {
		  hasTriGreen = hasTriGreen === 1 ? 0 : 1;
		  triHud();
		  if (debug) { console.log("TriGreen",hasTriGreen);}
		});
		// Middle triangle toggles hasTriBlue
		triangles[1].addEventListener("click", () => {
		  hasTriBlue = hasTriBlue === 1 ? 0 : 1;
		  triHud();
		  if (debug) { console.log("TriBlue",hasTriBlue);}
		});
		// Right triangle toggles hasTriPurple
		triangles[2].addEventListener("click", () => {
		  hasTriPurple = hasTriPurple === 1 ? 0 : 1;
		  triHud();
		  if (debug) { console.log("TriPurple",hasTriPurple);}
		});
	  }
	}

	function darkenColour(hex, amount) {
	  // Remove the '#' if present.
	  hex = hex.replace(/^#/, '');
	  // Convert 3-digit hex to 6-digit.
	  if (hex.length === 3) {
		hex = hex.split('').map(c => c + c).join('');
	  }
	  let num = parseInt(hex, 16);
	  let r = (num >> 16) - amount;
	  let g = ((num >> 8) & 0x00FF) - amount;
	  let b = (num & 0x0000FF) - amount;
	  // Clamp each value between 0 and 255.
	  r = r < 0 ? 0 : r;
	  g = g < 0 ? 0 : g;
	  b = b < 0 ? 0 : b;
	  // Convert back to hex string.
	  let rHex = r.toString(16).padStart(2, '0');
	  let gHex = g.toString(16).padStart(2, '0');
	  let bHex = b.toString(16).padStart(2, '0');
	  return "#" + rHex + gHex + bHex;
	}

	function drawTriPower() {
	  // Draw each triangle only if it's active
	  if (shop) {
		drawTriObj(triGreen, "#008000");
		drawTriGreenShield();
	  }
	  drawTriObj(triBlue, "#0000FF");
	  drawTriObj(triPurple, PURPLE_COLOUR);
	}

	function drawTriObj(tri, activeColor) {
	  if (!tri.active) return;
	  
	  ctx.save();
	  ctx.shadowColor = "transparent";
	  ctx.fillStyle = activeColor;
	  
	  // Use default dimensions if not provided.
	  let x = tri.x;
	  let y = tri.y;
	  let width = tri.width || 41;
	  let height = tri.height || 35;
	  
	  // Create the triangle path.
	  ctx.beginPath();
	  ctx.moveTo(x + width / 2, y);       // Top vertex.
	  ctx.lineTo(x, y + height);          // Bottom left.
	  ctx.lineTo(x + width, y + height);  // Bottom right.
	  ctx.closePath();
	  
	  // Fill the triangle.
	  ctx.fill();
	  
	  // Set stroke properties.
	  ctx.lineWidth = 7;
	  ctx.strokeStyle = darkenColour(activeColor, 30); // Darken Border
	  
	  // Set drop shadow properties for the stroke.
	  ctx.shadowColor = "rgba(0, 0, 0, 0.75)"; // semi-transparent black shadow
	  ctx.shadowBlur = 5;                   // Adjust blur intensity as needed
	  ctx.shadowOffsetX = 0;                 // Horizontal offset
	  ctx.shadowOffsetY = 0;                 // Vertical offset
	  
	  // Clip to the triangle so the stroke appears internal.
	  ctx.clip();
	  
	  // Redraw the same triangle path and stroke it.
	  ctx.beginPath();
	  ctx.moveTo(x + width / 2, y);
	  ctx.lineTo(x, y + height);
	  ctx.lineTo(x + width, y + height);
	  ctx.closePath();
	  ctx.stroke();
	  
	  ctx.restore();
	}
	
	function drawTriGreenShield() {
	  // Only draw shields if the shop is open and triGreen is active.
	  if (!shop || !triGreen.active) return;
	  
	  let centerX = triGreen.x + triGreen.size / 2;
	  let centerY = triGreen.y + triGreen.size / 2;
	  
	  for (let i = 0; i < 4; i++) {
		let radius = TRI_GREEN_SHIELD_RADII[i];
		ctx.beginPath();
		ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
		ctx.lineWidth = SHIELD_THICKNESS;
		
		// Use the active color if the shield is true; otherwise use a darkened (inactive) version.
		if (triGreen.shields[i]) {
		  ctx.strokeStyle = BROWN_COLOR;  
		} else {
		  ctx.strokeStyle = "#222";
		}
		ctx.stroke();
	  }
	}

	function convertToHex(colour) {
	  if (colour[0] === "#") return colour; // Already hex.
	  // Create a temporary canvas context.
	  const ctx = document.createElement("canvas").getContext("2d");
	  ctx.fillStyle = colour;
	  return ctx.fillStyle; // This returns the colour in hex format.
	}
	// Helper function to darken a hex color by a specified amount.
	function darkenColour(hex, amount) {
	  // Remove the '#' if present.
	  hex = hex.replace(/^#/, '');
	  // Expand shorthand form (e.g. "03F") to full form ("0033FF")
	  if (hex.length === 3) {
		hex = hex.split('').map(c => c + c).join('');
	  }
	  let num = parseInt(hex, 16);
	  let r = Math.max((num >> 16) - amount, 0);
	  let g = Math.max(((num >> 8) & 0x00FF) - amount, 0);
	  let b = Math.max((num & 0x0000FF) - amount, 0);
	  // Convert each channel back to a 2-digit hex string.
	  let rHex = r.toString(16).padStart(2, '0');
	  let gHex = g.toString(16).padStart(2, '0');
	  let bHex = b.toString(16).padStart(2, '0');
	  return "#" + rHex + gHex + bHex;
	}

	// Player collision with TriGreen
	function checkTriGreenCollision() {
	  // Only perform the check if triGreen is active.
	  if (!triGreen.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triGreen area.
	  if (player.x < triGreen.x + triangleWidth &&
		  player.x + player.size > triGreen.x &&
		  player.y < triGreen.y + triangleHeight &&
		  player.y + player.size > triGreen.y) {
		// When collision occurs, remove triGreen and set hasTriGreen.
		triGreen.active = false;
		hasTriGreen = 1;	
	  }
	}

	function checkTriGreenShieldCollision() {
	  if (!shop || !triGreen.active) return;
	  
	  let centerX = triGreen.x + triGreen.size / 2;
	  let centerY = triGreen.y + triGreen.size / 2;
	  let playerCenterX = player.x + player.size / 2;
	  let playerCenterY = player.y + player.size / 2;
	  
	  let dx = playerCenterX - centerX;
	  let dy = playerCenterY - centerY;
	  let distance = Math.sqrt(dx * dx + dy * dy);
	  
	  // Check collision only for active shields.
	  for (let i = 0; i < 4; i++) {
		if (!triGreen.shields[i]) continue; // Skip inactive rings
		
		let ringRadius = TRI_GREEN_SHIELD_RADII[i];
		if (Math.abs(distance - ringRadius) <= SHIELD_THICKNESS / 2 + player.size / 2) {
		  let overlap = (SHIELD_THICKNESS / 2 + player.size / 2) - Math.abs(distance - ringRadius);
		  let norm = Math.sqrt(dx * dx + dy * dy) || 1;
		  player.x += (dx / norm) * overlap;
		  player.y += (dy / norm) * overlap;
		}
	  }
	}

	// Player collision with TriBlue
	function checkTriBlueCollision() {
	  // Only perform the check if triBlue is active.
	  if (!triBlue.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triBlue area.
	  if (player.x < triBlue.x + triangleWidth &&
		  player.x + player.size > triBlue.x &&
		  player.y < triBlue.y + triangleHeight &&
		  player.y + player.size > triBlue.y) {
		// When collision occurs, remove triBlue and set hasTriBlue.
		triBlue.active = false;
		hasTriBlue = 1;
	  }
	}
	// Player collision with TriPurple
	function checkTriPurpleCollision() {
	  // Only perform the check if triPurple is active.
	  if (!triPurple.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triPurple area.
	  if (player.x < triPurple.x + triangleWidth &&
		  player.x + player.size > triPurple.x &&
		  player.y < triPurple.y + triangleHeight &&
		  player.y + player.size > triPurple.y) {
		// When collision occurs, remove triPurple and set hasTriPurple.
		triPurple.active = false;
		hasTriPurple = 1;
		nextLevel();		
	  }
	}

    let highScore = 1;
	// Load saved values from localStorage (default to 0 if not found)
	highScore = localStorage.getItem("highScore") ? parseInt(localStorage.getItem("highScore")) : 1;
	
    let gameOverPrompted = false;
    const PURPLE_COLOUR = "#7F00FF";
	const DARK_PURPLE = "#4B0082"; 
    const FLASH_COLOUR = "#c78fff";	
    const ICE_COLOUR = "#13c8cf";
    let purpleorbUsed = false;
	
	const BROWN_COLOR = "#5D3A1A";  // Brown color matching the token triangles
	const TRI_GREEN_SHIELD_RADII = [40, 50, 60, 70];  // Radii for the 4 concentric shield rings
	const SHIELD_THICKNESS = 5;  // Stroke width for drawing each shield ring
    
    // Use fixed shield rings (up to 3).
    let shieldRings = [];
    // Flag to prevent awarding multiple shields in one temporary purple cycle.
    let shieldAwardedForCurrentTempPurple = false;
    // Indicates that the temporary purple effect is active.
	let purplePower = false;
	let purplePowerTimeout = null;
	let purplePowerEndTime = 0;  // Timestamp when the purple power should end
    let flashIntervalTimeout = null;
	let flashInterval = null;
	let loggingInterval = null;
	
	let icePower = false;
	let icePowerTimeout = null;
	let icePowerEndTime = 0;
    
    // Constants for shield ring drawing.
    // Desired radii: first ring = 20, second = 25, third = 30.
    const desiredRadii = [20, 25, 30];
    const shieldThickness = 3;  // Stroke width is 3 pixels.
    
    // Recalculate each shield ring's radius based on its index.
    function recalcShieldRadii() {
      for (let i = 0; i < shieldRings.length; i++) {
        shieldRings[i].ringRadius = desiredRadii[i];
      }
    }
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
	
	// Touch variables
	let touchStartX = null;
	let touchStartY = null;
	let touchActive = false;
	let touchDx = 0;
	let touchDy = 0;

	// Touch event listeners
	canvas.addEventListener('touchstart', function(e) {
	  if (!gamePaused && 'ontouchstart' in window) {
		e.preventDefault();
	  } // Prevent scrolling when unpaused
		  if (gamePaused) {
			// Allow unpause only if 1 second (1000 ms) has passed since pausing
			if (Date.now() - pauseTimestamp >= 1000) {
			resumeGame()
			} else {
			  // Not enough time has passed; ignore the input
			  return;
			}
		  }
		  // Check if game over and try again is available
		  if (gameOver && tryAgainAvailable) {
			restartGame();
			return;
		  }	  
			  if (e.touches.length > 0) {
				  touchActive = true;
				  if (touchStartX === null && touchStartY === null) {
					  touchStartX = e.touches[0].clientX;
					  touchStartY = e.touches[0].clientY;
				  }
				  touchDx = 0;
				  touchDy = 0;
			  }
	}, {passive: false});

	canvas.addEventListener('touchmove', function(e) {
	  if (!gamePaused && 'ontouchstart' in window) {
		e.preventDefault();
	  } // Prevent scrolling when unpaused
	  if (touchActive && e.touches.length > 0) {
		  let currentX = e.touches[0].clientX;
		  let currentY = e.touches[0].clientY;
		  touchDx = currentX - touchStartX;
		  touchDy = currentY - touchStartY;
	  }
	}, {passive: false});

	canvas.addEventListener('touchend', function(e) {
	  e.preventDefault();
	  touchActive = false;
	  touchStartX = null; // Reset initial touch point for next touch event
	  touchStartY = null;
	  touchDx = 0;
	  touchDy = 0;
	}, {passive: false});
	
	// Stop right click of Canvas
    canvas.addEventListener('contextmenu', function(event) {
    event.preventDefault();
    });
    const messageOverlay = document.getElementById("messageOverlay");
    const hudLife = document.getElementById("hudLife");
    const hudLevelElem = document.getElementById("hudLevel");
    const hudLevelProg = document.getElementById("hudLevelProg");
    const hudorbIndicator = document.getElementById("hudorbIndicator");
    const hudHighScore = document.getElementById("hudHighScore");
    const zoneSize = 250;
    let tryAgainAvailable = false;
    
    let orbActive = true;
    let manualPauseTimer = null;
    let manualPauseLocked = false;
    let controlsLocked = false;
	let playerIsPink = false;
	let inputNoWrap = false;
	let inputCodeBuffer = "";
	let bossRotationSpeed = 0.04;
	let bossFail = 0;
	
	let spiralTimer;
	let triShotTimer;
	
	// --------------------
	// GLOBAL ROCK VALUES
	// --------------------
	let rockValues = [];

	function recalcRockValues() {
	  rockValues = []; // Reset the array.
	  for (let i = 0; i < 99; i++) {
		if (i === 3) {
		  rockValues.push(42);
		} else {
		  // Each value is 10 * (i+1) plus a random number between 1 and 9.
		  rockValues.push(10 * (i + 1) + (Math.floor(Math.random() * 9) + 1));
		}
	  }
	  //if (debug) { console.log("rockValues", rockValues);}
	}

	
	// Trail Effect
	let playerTrail = [];
	const TRAIL_LENGTH = 20;  
	
	let hasTriGreen = 0;
	let hasTriBlue = 0;
	let hasTriPurple = 0;
	
	// Load saved values from localStorage (default to 0 if not found)
	hasTriPurple = localStorage.getItem("hasTriPurple") ? parseInt(localStorage.getItem("hasTriPurple")) : 0;
	hasTriBlue = localStorage.getItem("hasTriBlue") ? parseInt(localStorage.getItem("hasTriBlue")) : 0;
	hasTriGreen = localStorage.getItem("hasTriGreen") ? parseInt(localStorage.getItem("hasTriGreen")) : 0;
	let triGreen = {
	  active: false,  // Indicates if the triGreen is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40,      // Adjust this size as needed
	  shields: [true, true, true, true]
	};
	let triBlue = {
	  active: false,  // Indicates if the triBlue is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	let triPurple = {
	  active: false,  // Indicates if the triPurple is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	
	function triHud() {
	  // Get the three triangle elements in order: left, middle, right.
	  let triangles = document.querySelectorAll("#hudTriangles .triangle");
	  if (triangles.length < 3) return; // Ensure all three exist

	  // Left triangle (green)
	  if (hasTriGreen === 1) {
		  // Set the background color via CSS, so leave style.backgroundColor empty.
		  triangles[0].style.backgroundColor = "";
		  triangles[0].classList.add("green", "withInnerStroke");
		  localStorage.setItem("hasTriGreen", hasTriGreen);
		  
		  if (progress > 10) { // Arbitrary reason for glow until I think of a better one
			triangles[0].classList.add("glow");
		  } else {
			triangles[0].classList.remove("glow");
		  }
		} else {
		  triangles[0].classList.remove("green", "withInnerStroke", "glow");
		  triangles[0].style.backgroundColor = "#202020";
		  triangles[0].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
		}

	  // Middle triangle (blue)
	  if (hasTriBlue === 1) {
		  // Set the background color via CSS, so leave style.backgroundColor empty.
		  triangles[1].style.backgroundColor = "";
		  triangles[1].classList.add("blue", "withInnerStroke");
		  localStorage.setItem("hasTriBlue", hasTriBlue);
		  
		  if (player.lives >= 100) { // Arbitrary reason for glow until I think of a better one
			triangles[1].classList.add("glow");
		  } else {
			triangles[1].classList.remove("glow");
		  }
		} else {
		  triangles[1].classList.remove("blue", "withInnerStroke", "glow");
		  triangles[1].style.backgroundColor = "#202020";
		  triangles[1].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
		}

		// Right triangle (purple)
		if (hasTriPurple === 1) {
		  // Set the background color via CSS, so leave style.backgroundColor empty.
		  triangles[2].style.backgroundColor = "";
		  triangles[2].classList.add("purple", "withInnerStroke");
		  localStorage.setItem("hasTriPurple", hasTriPurple);
		  
		  if (player.shieldCount >= 1) {
			triangles[2].classList.add("glow");
		  } else {
			triangles[2].classList.remove("glow");
		  }
		} else {
		  triangles[2].classList.remove("purple", "withInnerStroke", "glow");
		  triangles[2].style.backgroundColor = "#202020";
		  triangles[2].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
		}


	}
	
	//Purple Power
	function activatePurplePower() {
	  const extension = Math.max(10000, Math.min(20000, player.level * 1000)); //Purple Power Duration
	  const now = Date.now();

	  if (!purplePower) {
		//clearIcePower();
		icePowerEndTime = Date.now();
		purplePower = true;
		// Apply the purple effect to sqrs
		sqrs.forEach(sqr => {
		  if (!sqr.temporarilyPurple) {
			sqr.storedColor = sqr.color;
			sqr.storedSpeed = sqr.speed;
			sqr.color = PURPLE_COLOUR;
			sqr.temporarilyPurple = true;
			if (debug) { console.log("Purple power activated!");}
		  }
		});
		hudorbIndicator.style.backgroundColor = PURPLE_COLOUR;
		purplePowerEndTime = now + extension;
	  } else {
		// Extend the power duration
		purplePowerEndTime = Math.max(purplePowerEndTime, now) + extension;
		if (debug) { console.log("Purple power extended!");}
	  }

	  // Clear any existing timeouts/intervals
	  if (purplePowerTimeout) {
		clearTimeout(purplePowerTimeout);
	  }
	  if (flashIntervalTimeout) {
		clearTimeout(flashIntervalTimeout);
	  }
	  if (flashInterval) {
		clearInterval(flashInterval);
		flashInterval = null;
	  }

	  const remainingTime = purplePowerEndTime - now;

	  // Start flashing 2 seconds before purple power expires
	  if (remainingTime > 2000) {
		flashIntervalTimeout = setTimeout(() => {
		  // Start the flash interval
		  flashInterval = setInterval(() => {
			sqrs.forEach(sqr => {
			  if (sqr.temporarilyPurple) {
				sqr.color = (sqr.color === PURPLE_COLOUR) ? FLASH_COLOUR : PURPLE_COLOUR;
			  }
			});
		  }, 100); // Flash rate
		}, remainingTime - 2000);
	  }

	  // Schedule deactivation of purple power
	  purplePowerTimeout = setTimeout(clearPurplePower, remainingTime);
	}

	function clearPurplePower() {
	  // Stop flashing if it's still active
	  if (flashInterval) {
		clearInterval(flashInterval);
		flashInterval = null;
	  }

	  // Restore each sqr's original properties.
	  sqrs.forEach(sqr => {
		if (sqr.temporarilyPurple) {
		  sqr.color = sqr.storedColor;
		  sqr.speed = sqr.storedSpeed;
		  sqr.temporarilyPurple = false;
		}
	  });
	  // if (debug) { console.log("Purple power ended!");}
	  purplePower = false;
	  playerTrail = [];
	}
	
	function activateIcePower() {
	  const extension = 10000; // Fixed extension: 10 seconds
	  const now = Date.now();

	  if (!icePower) {
	    clearPurplePower();
		purplePowerEndTime = Date.now();
		icePower = true;
		// Apply the ice effect to sqrs
		sqrs.forEach(sqr => {
		  if (!sqr.temporarilyFrozen) {
			sqr.storedColor = sqr.color;
			sqr.storedSpeed = sqr.speed;
			sqr.color = ICE_COLOUR;
			sqr.temporarilyFrozen = true;
			sqr.temporarilyPurple = false;
						
			if (debug) { console.log("Ice power activated!");}
		  }
		});
		icePowerEndTime = now + extension;
	  } else {
		// If already active, reset the timer to 10 seconds from now.
		icePowerEndTime = Date.now() + extension;
		if (debug) { console.log("Ice power extended!");}
	  }

	  // Clear any existing timeout and schedule clearIcePower.
	  if (icePowerTimeout) clearTimeout(icePowerTimeout);
	  icePowerTimeout = setTimeout(() => {
		if (Date.now() >= icePowerEndTime) {
		  clearIcePower();
		}
	  }, icePowerEndTime - Date.now());
	}

	function clearIcePower() {	  
	  // Restore each sqr's original properties.
	  sqrs.forEach(sqr => {
		if (sqr.temporarilyFrozen) {
		  sqr.color = sqr.storedColor;
		  sqr.speed = sqr.storedSpeed;
		  sqr.temporarilyFrozen = false;
		}
	  });
	  //if (debug) { console.log("Ice power ended!");}
	  icePower = false;
	}

	// Boss state variables and triShot counter
	let bossState = "yellow"; // Possible states: "yellow", "orange", "red"
	let triShotShieldCount = 0; // Counts the number of triShot that have hit a Shield
	let triShots = [];  // Array for triShot projectiles

	// updateBossState, colour and rotation
	function updateBossState() {
	if (boss){
		if (bossState === "yellow") { boss.color = "yellow", bossRotationSpeed = 0.03;}
		if (bossState === "orange") { boss.color = "orange", bossRotationSpeed = 0.06;}
		if (bossState === "red") { boss.color = "red", bossRotationSpeed = 0.09;}
	}
		
		if (bossState === "yellow" && !bossFail) {
		    bossShots = []; // Delete all existing boss shots
			bossState = "orange";
		}
		if (bossState === "orange") {
			spiralTimer = setTimeout(() => {
			fireSpiral() // Oooh pretty spiral
			}, 3000);    // How long before the Spiral comes
			triShotTimer = setTimeout(() => {
				if (bossState === "orange") {
					bossShots = []; // Delete all existing boss shots
					fireTriShots(); // Fires two triShots in opposite random directions
					bossState = "red"; // Change boss state to red
				}
			}, 18000); // How long before the triShots come
		}
	}

	// Fires two triShots at opposite directions
	function fireTriShots() {
	if (triShots.length > 0) return; // Don't fire if they exist.
		if (bossState === "orange") {
						
			// Calculate the vector from the boss to the player
			let dx = (player.x + player.size / 2) - (boss.x + boss.size / 2);
			let dy = (player.y + player.size / 2) - (boss.y + boss.size / 2);

			// Compute perpendicular vectors (90-degree rotation)
			let angle1 = Math.atan2(dy, dx) + Math.PI / 2;  // 90 degrees counterclockwise
			let angle2 = Math.atan2(dy, dx) - Math.PI / 2;  // 90 degrees clockwise

			// Spawn the two triShots moving perpendicularly
			spawnTriShot(angle1);
			spawnTriShot(angle2);
			bossState = "red";
		}
	}
	// Fire spiral
	let isSpiralActive = false;
	let hasSpiralFired = false;
	
	function fireSpiral() {
	  if (hasSpiralFired || isSpiralActive || !boss || !bossFight || gamePaused) return;
	  hasSpiralFired = true;  // Mark the spiral as fired for this boss fight
	  isSpiralActive = true;
	  let spiralStartTime = Date.now(); // Record start time
	  let spiralInitialLives = player.lives; // Store player's lives at the start
	  let bossCenterX = boss.x + boss.size / 2;
	  let bossCenterY = boss.y + boss.size / 2;
	  let initialAngleDeg = -90; // Starting angle for the first spiral (straight upward)
	  let totalShots = 11400; // Duration of spiral in ms or use shot count
	  let currentShot = 0;
	  let spiralSpeed = 0.75; // How tight the spiral is
	  let spiralDelay = 20;  // Delay between shots in milliseconds
	  
	  // Randomize spin direction: +1 for clockwise, -1 for anticlockwise.
	  let spinDirection = Math.random() < 0.5 ? 1 : -1;
	  
	  function shootNext() {
		// Stop condition: if time, shot count, game paused/over, or player lives drop
		if (Date.now() - spiralStartTime >= totalShots ||
			currentShot >= totalShots ||
			gamePaused ||
			gameOver ||
			player.lives < spiralInitialLives) {
		  isSpiralActive = false;
		  return;
		}
		
		// Compute the current offset angle (in degrees) based on the shot count and spin direction.
		let offset = currentShot * 2 * spinDirection;
		let angleDeg1 = initialAngleDeg + offset;
		let angleRad1 = angleDeg1 * Math.PI / 180;
		
		// For the second spiral, add 180 degrees.
		let angleDeg2 = angleDeg1 + 180;
		let angleRad2 = angleDeg2 * Math.PI / 180;
		
		// Fire two shots simultaneously using the computed angles.
		fireBossShotOrange("single", bossCenterX, bossCenterY, angleRad1, spiralSpeed);
		fireBossShotOrange("single", bossCenterX, bossCenterY, angleRad2, spiralSpeed);
		
		currentShot++;
		setTimeout(shootNext, spiralDelay);
	  }
	  
	  shootNext();
	}
    
    const safeMargin = 30;
    function isTooClose(a, b, margin) {
      return (
        a.x < b.x + b.size + margin &&
        a.x + a.size > b.x - margin &&
        a.y < b.y + b.size + margin &&
        a.y + a.size > b.y - margin
      );
    }
    function getValidSpawnPosition(entitySize, existingEntities = []) {
      let x, y, valid = false;
      let candidate = { x: 0, y: 0, size: entitySize };
      while (!valid) {
        x = Math.random() * (canvas.width - entitySize);
        y = Math.random() * (canvas.height - entitySize);
        candidate.x = x;
        candidate.y = y;
        valid = true;
        for (let ent of existingEntities) {
          if (isTooClose(candidate, ent, safeMargin)) {
            valid = false;
            break;
          }
        }
      }
      return { x, y };
    }
    // Player spawn positioning during Boss Fight.
    function getValidBossFightSpawnPosition(entitySize, obstacles) {
      let x, y, valid = false;
      let candidate;
      while (!valid) {
        // Ensure the spawn is within the canvas excluding the 20px moat border.
        x = 20 + Math.random() * (canvas.width - entitySize - 40);
        y = 20 + Math.random() * (canvas.height - entitySize - 40);
        candidate = { x: x, y: y, size: entitySize };
        valid = true;
        for (let obs of obstacles) {
          if (isTooClose(candidate, obs, safeMargin)) {
            valid = false;
            break;
          }
        }
      }
      return { x, y };
    }
    function getValidsqrSpawnPosition(entitySize) {
      let pos;
      let tries = 0;
      do {
        pos = getValidSpawnPosition(entitySize, rocks.concat(sqrs, [player]));
        tries++;
      } while (
        rocks.some(obs =>
          pos.x < obs.x + obs.size &&
          pos.x + entitySize > obs.x &&
          pos.y < obs.y + obs.size &&
          pos.y + entitySize > obs.y
        ) && tries < 1000
      );
      return pos;
    }
    function getRandomAngle() {
      return Math.random() * 2 * Math.PI;
    }
	// Clamp a value between min and max.
	function clamp(val, min, max) {
	  return Math.max(min, Math.min(max, val));
	}

	// Compute reflection vector.
	function reflectVector(vx, vy, nx, ny) {
	  let dot = vx * nx + vy * ny;
	  return { vx: vx - 2 * dot * nx, vy: vy - 2 * dot * ny };
	}

	// Collision between circle and rectangle.
	function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
	  let closestX = clamp(cx, rx, rx + rw);
	  let closestY = clamp(cy, ry, ry + rh);
	  let dx = cx - closestX;
	  let dy = cy - closestY;
	  return (dx * dx + dy * dy) < (radius * radius);
	}

	// Collision between circle and player's rectangle.
	function circlePlayerCollision(cx, cy, radius, player) {
	  return circleRectCollision(cx, cy, radius, player.x, player.y, player.size, player.size);
	}

	// Collision between circle (boss shot) and a boss rock (rectangle).
	function bossShotRockCollision(shot, rock) {
	  return circleRectCollision(shot.x, shot.y, shot.size / 2, rock.x, rock.y, rock.width, rock.height);
	}

	// Returns a random boss shot interval between 1 and 3 seconds.
	function getRandomBossShotInterval() {
	  return 1000 + Math.random() * 2000;
	}

	// Schedules next boss shot interval.
	function scheduleNextBossShot() {
	  lastBossShotTime = Date.now();
	  bossShotInterval = getRandomBossShotInterval();
	}
    
	// Player Setup
    const basePlayerSpeed = 5;
    let player = { x: 50, y: 50, size: 20, speed: basePlayerSpeed, lives: 1, level: 1, shieldCount: 0 };
    let progress = 0;
    let orb = { x: 200, y: 200, size: 20, color: "green", isHex: false };
    let sqrs = [];
    let rocks = [];
    let mud = [];
	
	let lastPlayerMoveTime = Date.now();
	let overrideNextBossShot = false;
	let lastPlayerX = player.x;
	let lastPlayerY = player.y;	
	// Green Powers	
	let hasGreenArrow = 0;
	let hasSuperOrb = 0;
	// Blue Powers
	let hasDoubleLife = 0;

	let bossDead = 0;
	let bossSkip = 0;
	let bossReward = 0;
	
	// boss fight globals
	let bossFight = false;
	let boss = null;
	let bossRocks = [];
	// boss shot globals
	let bossShots = [];
	let lastBossShotTime = Date.now();
	let bossShotInterval = getRandomBossShotInterval(); // initial interval

	let miniBoss = false;

    let hitCooldown = false;
    let gameOver = false;
	
	// Global variables for pause state.
	let gamePaused = false;
	let pauseTimestamp = 0
	let pauseReason = ''; 
	
 	function setPause(paused, colour = '', reason = '') {
	  gamePaused = paused;
	  pauseColour = colour;
	  pauseReason = paused ? reason : '';
	  if (gamePaused) {
	    messageOverlay.style.color = pauseColour;
		messageOverlay.textContent = pauseReason;
		pauseTimestamp = Date.now(); // Record the time when the game is paused
	  } else {
		messageOverlay.textContent = '';
	  }
	}
	
	// Function to resume the game.
	function resumeGame() {
		if (Date.now() - pauseTimestamp >= 1000) {
		  setPause(false);
		  controlsLocked = false;
		  messageOverlay.textContent = "";
		  
		}
	} 
 
    function isIntersecting(entity, zone) {
      return !(entity.x + entity.size < zone.x ||
               entity.x > zone.x + zone.width ||
               entity.y + entity.size < zone.y ||
               entity.y > zone.y + zone.height);
    }
	function isCollidingWithObstacle(entity, obstacles) {
	  for (let obs of obstacles) {
		let collision;
		// If obstacle is a rockFake, use checkRockCollision to include timer logic.
		if (obs.rockFake) {
		  collision = checkRockCollision(obs);
		} else {
		  collision = (
			entity.x < obs.x + obs.width &&
			entity.x + entity.size > obs.x &&
			entity.y < obs.y + obs.height &&
			entity.y + entity.size > obs.y
		  );
		}
		if (collision) return true;
	  }
	  return false;
	}
	
	function checkRockCollision(rock) {
	  if (!rock) return false;  // If rock is undefined, return false.

	  const collision = (
		player.x < rock.x + rock.width &&
		player.x + player.size > rock.x &&
		player.y < rock.y + rock.height &&
		player.y + player.size > rock.y
	  );
	  
	  if (rock.rockFake) {
		if (collision) {
		  if (!rock.fakeCollisionStart) {
			// Start timer on first collision.
			rock.fakeCollisionStart = Date.now();
		  } else if (Date.now() - rock.fakeCollisionStart >= 500) { // After 0.5s of continuous collision, go inside.
			rock.inside = true;
		  }
		} else {
		  // Reset timer and inside flag when collision stops.
		  rock.fakeCollisionStart = null;
		  rock.inside = false;
		}
		// When the rockFake is in its "inside" (darker) state, ignore collision.
		if (rock.inside) return false;
	  }
	  return collision;
				 
	}
	
	// rockFake stuff
	// Global variables for tracking entry time and last player position.
	let rockFakeEntryTime = null;
	let lastPlayerPos = { x: null, y: null };
	
	// Shop vars
	let shop = false;
	let shopToken = null;
	let isWrapping = false;
	let shopTokens = [];
	let shopsPatronised = {};
	let currentShopId = null;

	function enterShop() {
	  // Calculate shop id by taking the tens digit (i.e., level 10-19 becomes 1, 20-29 becomes 2, etc.)
	  let shopId = Math.floor(player.level / 10);

	  // Initialize this shop as not yet patronised if it hasn't been recorded.
	  if (!(shopId in shopsPatronised)) {
		shopsPatronised[shopId] = false;
	  }
	  
	  currentShopId = shopId;
	  //if (debug) { console.log("Entered shop with shopId:", shopId);}
	}

	function rockFakeUpdate() {
	  let insideRockFake = false;
	  // Loop through all rocks to check for a rockFake with the 'inside' flag.
	  for (let rock of rocks) {
		if (rock.rockFake && rock.inside) {
		  // Check if the player's rectangle intersects this rock.
		  if (
			player.x < rock.x + rock.width &&
			player.x + player.size > rock.x &&
			player.y < rock.y + rock.height &&
			player.y + player.size > rock.y
		  ) {
			insideRockFake = true;
			break; // Found one; no need to check further.
		  }
		}
	  }
	  
	  // Adjust player's speed accordingly.
	  if (insideRockFake) {
		player.speed = basePlayerSpeed * 0.1;
		
		// If this is the first frame we detect the player inside, record the time and position.
		if (rockFakeEntryTime === null) {
		  rockFakeEntryTime = Date.now();
		  lastPlayerPos = { x: player.x, y: player.y };
		} else {
		  // Check if the player has moved.
		  if (player.x !== lastPlayerPos.x || player.y !== lastPlayerPos.y) {
			// Player moved, so reset the timer and update the position.
			rockFakeEntryTime = Date.now();
			lastPlayerPos = { x: player.x, y: player.y };
		  } else {
			// Player hasn't moved; check if 3 seconds have passed.
			if (Date.now() - rockFakeEntryTime >= 3000) {
			  openShop();
			}
		  }
		}
	  } else {
		// If not inside, reset the timer and last position.
		player.speed = basePlayerSpeed;
		rockFakeEntryTime = null;
		lastPlayerPos = { x: null, y: null };
	  }
	}
   
    function getRandomCornerPattern() {
      let pattern;
      do {
        pattern = [
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5
        ];
      } while (pattern.filter(c => c).length === 0 || pattern.filter(c => c).length === 4);
      return pattern;
    }
    
    function spawnmud() {
      mud = [];
      if (player.level === 1) return;
      let count = 1;
      if (player.level >= 50) count = 5;
      else if (player.level >= 40) count = 4;
      else if (player.level >= 30) count = 3;
      else if (player.level >= 20) count = 2;
      count = Math.min(count, 5);
      for (let i = 0; i < count; i++) {
        mud.push({
          x: Math.random() * (canvas.width - zoneSize),
          y: Math.random() * (canvas.height - zoneSize),
          width: zoneSize,
          height: zoneSize,
          color: "#5D3A1A"
        });
      }
    }
    
	function spawnrocks() {
	  rocks = [];
	  if (player.level === 1) return;
	  
	  // Determine number of rocks (example logic)
	  let count = Math.floor(Math.random() * Math.floor(player.level / 2)) + 1;
	  count = Math.min(count, 10);
	  
	  const shapes = [
		{ width: 50, height: 50 },
		{ width: 50, height: 75 },
		{ width: 50, height: 100 },
		{ width: 75, height: 50 },
		{ width: 75, height: 75 },
		{ width: 75, height: 100 },
		{ width: 100, height: 50 },
		{ width: 100, height: 75 },
		{ width: 100, height: 100 }
	  ];
	  
	  for (let i = 0; i < count; i++) {
		let shape = shapes[Math.floor(Math.random() * shapes.length)];
		let rockSize = Math.max(shape.width, shape.height);
		let pos = getValidSpawnPosition(rockSize, rocks.concat([player]));
		// Assume getRandomCornerPattern() returns an array for the default (sharp) corners.
		let corners = getRandomCornerPattern();
		
		let rock = {
		  x: pos.x, 
		  y: pos.y, 
		  width: shape.width, 
		  height: shape.height, 
		  size: rockSize, 
		  color: "#222",          // default rock colour
		  corners: corners,       // Used for drawing (sharp corners by default)
		  rockFake: false,        // Flag to mark the special rock
		  fakeCollisionStart: null, // Timer for collision duration
		  inside: false           // Becomes true when player collides for 500ms
		};
		rocks.push(rock);
	  }
	  
	  // Flag one rock as rockFake if the player's level matches one of the rockValues.
	  if (rockValues.includes(player.level) && rocks.length > 0) {
		let index = Math.floor(Math.random() * rocks.length);
		rocks[index].rockFake = true;
	  }
	}

  
    const ICE_SPEED = 0.1, YELLOW_SPEED = 1, ORANGE_SPEED = 2, RED_SPEED = 4;
    const YELLOW_SIZE = 20, ORANGE_SIZE = 25, RED_SIZE = 30;
	const MUD_SLOW = 0.5;
  
	function spawnsqrs() {
	  sqrs = [];
	  const redCount = Math.floor(player.level / 25);
	  const orangeCount = Math.floor(player.level / 10);
	  const yellowCount = Math.max(0, player.level - (redCount + orangeCount));
	  const intendedTotal = redCount + orangeCount + yellowCount;
	  const totalsqrs = Math.min(intendedTotal, 30); 	            // Cap total sqrs
	  
	  // Mapping sqr types to their properties
	  const sqrConfig = {
		red:    { size: RED_SIZE,    speed: RED_SPEED },
		orange: { size: ORANGE_SIZE, speed: ORANGE_SPEED },
		yellow: { size: YELLOW_SIZE, speed: YELLOW_SPEED }
	  };
	  
	  // Build an array of sqr types based on counts
	  let sqrTypes = [];
	  for (let i = 0; i < redCount; i++) {
		sqrTypes.push("red");
	  }
	  for (let i = 0; i < orangeCount; i++) {
		sqrTypes.push("orange");
	  }
	  for (let i = 0; i < yellowCount; i++) {
		sqrTypes.push("yellow");
	  }
	  // Apply the total sqrs cap
	  sqrTypes = sqrTypes.slice(0, totalsqrs);

	  sqrTypes.forEach(type => {
		let sqr = {
		  x: 0,
		  y: 0,
		  size: sqrConfig[type].size,
		  speedX: 0,
		  speedY: 0,
		  color: type,
		  // Store base speeds for later use
		  baseSpeedX: 0,
		  baseSpeedY: 0
		};

		// Find a valid spawn position, but avoid an infinite loop
		let validSpawn = false;
		let pos;
		let iterations = 0;
		while (!validSpawn && iterations < 100) {
		  pos = getValidsqrSpawnPosition(sqr.size);
		  validSpawn = true;
		  for (let rock of rocks) {
			if (
			  pos.x < rock.x + rock.width &&
			  pos.x + sqr.size > rock.x &&
			  pos.y < rock.y + rock.height &&
			  pos.y + sqr.size > rock.y
			) {
			  validSpawn = false;
			  break;
			}
		  }
		  iterations++;
		}
		// If no valid position is found, skip this sqr spawn
		if (!validSpawn) {
		  console.warn("Failed to spawn sqr of type " + type + " due to no valid position found.");
		  return; // Skip adding this sqr
		}
		sqr.x = pos.x;
		sqr.y = pos.y;
		let angle = getRandomAngle();
		sqr.speedX = Math.cos(angle) * sqrConfig[type].speed;
		sqr.speedY = Math.sin(angle) * sqrConfig[type].speed;
		sqr.baseSpeedX = sqr.speedX;
		sqr.baseSpeedY = sqr.speedY;
		
		sqrs.push(sqr);
	  });
	}
    // Main Orb Spawning function
	function spawnorb() {
	  if (bossFight || miniBoss || shop) return;                        // Prevent orb spawning during boss fights and shopping.

	  orbActive = true;
	  const minDistance = 250;                                          // Minimum spawn distance from Player
	  const playerCenterX = player.x + player.size / 2;
	  const playerCenterY = player.y + player.size / 2;
	  let pos, distance;

	  // Ensure the orb spawns far enough from the player.
	  do {
		pos = getValidSpawnPosition(orb.size, rocks.concat(sqrs, [player]));
		const orbCenterX = pos.x + orb.size / 2;
		const orbCenterY = pos.y + orb.size / 2;
		const dx = orbCenterX - playerCenterX;
		const dy = orbCenterY - playerCenterY;
		distance = Math.sqrt(dx * dx + dy * dy);
	  } while (distance < minDistance);

	  orb.x = pos.x;
	  orb.y = pos.y;
	  
	  // Determine the orb's color and shape.
	  let orbData;
	  if (progress === 0) {
		// Always green when progress is 0.
		orbData = { color: "green", shape: "circle" };
		} else if (progress === 4) {
			if (player.level < 10) {
			  orbData = { color: "blue", shape: "circle" };
			} else {
			  let chosenColor = (Math.random() < 0.5) ? "blue" : "green";
			  let orbShape = "circle";
			  if ( player.level % 10 === 0 && bossSkip === 0 ) {
				orbShape = "hex";
			  }
			  orbData = { color: chosenColor, shape: orbShape };
			}
		} else {
		// Otherwise, use the function to determine the orb.
		orbData = getRandomOrb(
		  0.1, PURPLE_COLOUR, "circle",                     // Probablilty of Purple Orb
		  (sqrs.length > 0 ? 0.2 : 0), ICE_COLOUR, "circle" // If no sqrs, don't spawn an Ice Orb
		);
	  }  
	  orb.color = orbData.color;
	  orb.shape = orbData.shape;
	  // if (debug) { console.log("Spawned orb:", orb.color, orb.shape);}
	}

	// Parameters should be  in groups of three: [threshold, color, shape]
	function getRandomOrb(...params) {
	  const defaultOption = { color: "green", shape: "circle" }; 	    // Default orb option if no condition is met.
	  
	  // Build an array of options from the parameters. Each option is an object with a threshold, color, and shape.
	  let options = [];
	  for (let i = 0; i < params.length; i += 3) {
		options.push({
		  threshold: params[i],
		  color: params[i + 1],
		  shape: params[i + 2]
		});
	  }	  
	  // Generate a random number between 0 and 1.
	  const rand = Math.random();	  
	  // Check each option in order.
	  for (let option of options) {
		if (rand < option.threshold) {
		  // Special case: if the option is purple, only allow one per level.
		  if (option.color === PURPLE_COLOUR) {
			if (!purpleorbUsed) {
			  purpleorbUsed = true;
			  return { color: PURPLE_COLOUR, shape: option.shape };
			} else {
			  // Purple orb already used; choose default.
			  return defaultOption;
			}
		  }
		  // For any other option, return it.
		  return { color: option.color, shape: option.shape };
		}
	  }	  
	  return defaultOption; 	                                        // If no thresholds are met, return default.
	}
	
	// Level functions
	function clearLevel() {
		bossFight = false;
		bossDead = false;
		shop = false;
		boss = null;
		//shot.remove = true;
		bossRocks = [];
		bossShots = [];
		clearPurplePower();
		clearIcePower();
		shieldAwardedForCurrentTempPurple = false;
	    purpleorbUsed = false;
		hudorbIndicator.style.backgroundColor = "grey";
		clearIcePower();
		progress = 0;
	}

	function spawnLevel() {
		spawnmud();
		spawnrocks();
		spawnsqrs();
		spawnorb();
	}		

	function nextLevel() {
		player.level++;
		if (player.level % 10 === 1) { bossSkip = 0 };
		setPause(true, "blue", "Level " + player.level);
		clearLevel();
		spawnLevel();
		if (debug) {
			const index = Math.floor(player.level / 10);
			console.log("fakeRock ", rockValues[index]);
		}
	}	

	// Function to fire a boss shot (or bursts) based on probabilities and limits.
	function fireBossShot() {
	  // Only fire if boss is rotating
	  if (!bossFight || gamePaused) return;

	  // BigBoi Override: if the player has been stationary, fire a large orange shot.
	  if (overrideNextBossShot) {
		let bossCenterX = boss.x + boss.size / 2;
		let bossCenterY = boss.y + boss.size / 2;
		fireBossShotOrange("large", bossCenterX, bossCenterY);
		lastPlayerMoveTime = Date.now(); // Reset timer
		overrideNextBossShot = false;  // Reset override flag for subsequent shots.
		scheduleNextBossShot();
		return;
	  }
	  
	  // Decide shot type based on probability:
	  // 50% chance for orange, 25% for red, 25% for green (or blue if progress>=9)
	  let rand = Math.random();
	  let shotType;
	  if (rand < 0.5) {
		shotType = "orange";
	  } else if (rand < 0.75) {
		shotType = "red";
	  } else {
		shotType = "green";  // will convert to blue later if progress>=9
	  }
	  
	  // Check limits:
	  // Only 1 green/blue shot allowed.
	  let greenCount = bossShots.filter(s => s.type === "green" || s.type === "blue").length;
	  if (shotType === "green" && greenCount >= 1) {
		shotType = "orange";
	  }
	  // Only 2 red shots allowed.
	  let redCount = bossShots.filter(s => s.type === "red").length;
	  if (shotType === "red" && redCount >= 2) {
		shotType = "orange";
	  }
	  
	  // For green shots, if progress >= 9 then they become blue.
	  if (shotType === "green" && progress >= 9) {
		  let chosenColor = (Math.random() < 0.5) ? "blue" : "green";
		shotType = chosenColor;
	  }
	  
	  // Determine firing position: assume boss center.
	  let bossCenterX = boss.x + boss.size / 2;
	  let bossCenterY = boss.y + boss.size / 2;
	  
	  // For orange shots, further choose one of four styles.
		if (shotType === "orange") {
		  let r = Math.random();
		  if (r < 0.0) {
			// Large: 0% chance (unless stationary).
			fireBossShotOrange("large", bossCenterX, bossCenterY);
		  } else if (r < 0.4) {
			// Line: next 30% chance.
			for (let i = 0; i < 5; i++) {
			  setTimeout(() => {
				fireBossShotOrange("single", bossCenterX, bossCenterY);
			  }, i * 50);
			}
		  } else if (r < 0.6) {
			// Spray: next 20% chance.
			let baseAngle = Math.atan2(player.y + player.size/2 - bossCenterY, player.x + player.size/2 - bossCenterX);
			let angles = [
			  baseAngle,
			  baseAngle + 5 * Math.PI/180,
			  baseAngle - 5 * Math.PI/180,
			  baseAngle + 10 * Math.PI/180,
			  baseAngle - 10 * Math.PI/180
			];
			angles.forEach(angle => {
			  fireBossShotOrange("single", bossCenterX, bossCenterY, angle);
			});
		  } else {
			// Single: remaining 40% chance.
			fireBossShotOrange("single", bossCenterX, bossCenterY);
		  }
		}
	  
	  else if (shotType === "red") {
		// Fire a red shot with a random 30 offset relative to the player.
		let baseAngle = Math.atan2(player.y + player.size/2 - bossCenterY, player.x + player.size/2 - bossCenterX);
		let offset = (Math.random() < 0.5 ? -30 : 30) * Math.PI/180;
		let angle = baseAngle + offset;
		let speed = 4.5;
		let shot = {
		  type: "red",
		  x: bossCenterX,
		  y: bossCenterY,
		  vx: Math.cos(angle) * speed,
		  vy: Math.sin(angle) * speed,
		  size: 10, // boss shot diameter
		  bounceCount: 0,
		  firedTime: Date.now(), // for tracking phase
		  homing: false  // will switch to homing after 0.5-1 sec
		};
		// Random straight travel duration between 500 and 1000 ms.
		shot.straightDuration = 500 + Math.random() * 500;
		bossShots.push(shot);
	  }
	  else if (shotType === "green" || shotType === "blue") {
		// Fire a green/blue shot at speed 3 in a random direction.
		let angle = getRandomAngle();
		let shot = {
		  type: (shotType === "green" ? "green" : "blue"),
		  x: bossCenterX,
		  y: bossCenterY,
		  vx: Math.cos(angle) * 3,
		  vy: Math.sin(angle) * 3,
		  size: 10,
		  bounceCount: 0
		};
		bossShots.push(shot);
	  }
	  scheduleNextBossShot();
	}

	// Creates a triShot projectile
	function spawnTriShot(angle) {
		if (hasTriPurple === 1) {triShotShieldCount = 2; return;}
		let triShot = {
			x: boss.x + boss.size / 2,  // Start from boss center
			y: boss.y + boss.size / 2,
			vx: Math.cos(angle) * 2,    // Initial speed of 2
			vy: Math.sin(angle) * 2,
			homing: false,
			spawnedAt: Date.now(),
			size: 10,
			type: "triShot" // Marks it for collision detection
		};
		triShots.push(triShot);
	}

	// Updates triShots each frame
	function updateTriShots() {
		triShots.forEach((triShot, index) => {
			// Store previous positions for the trail
			if (!triShot.trail) triShot.trail = [];
			triShot.trail.push({ x: triShot.x, y: triShot.y });
			if (triShot.trail.length > 20) triShot.trail.shift();

			// Check for collision with other triShots
			triShots.forEach((otherShot, otherIndex) => {
				if (index !== otherIndex && checkCollision(triShot, otherShot)) {
					handleTriShotCollision(triShot, otherShot);
				}
			});

			// If bouncing, move in opposite directions for 2 seconds
			if (triShot.bouncing) {
				if (Date.now() - triShot.bounceStart < 2000) {
					triShot.x += triShot.vx;
					triShot.y += triShot.vy;
					return; // Prevents homing from overriding bounce movement
				} else {
					// After 2 seconds, refocus on player
					triShot.bouncing = false;
				}
			}

			// Homing logic should only apply if the shot is NOT bouncing
			if (!triShot.bouncing && Date.now() - triShot.spawnedAt > 3000) {
				let dx = (player.x + player.size / 2) - triShot.x;
				let dy = (player.y + player.size / 2) - triShot.y;
				let distance = Math.sqrt(dx * dx + dy * dy);
				triShot.vx = (dx / distance) * 2;
				triShot.vy = (dy / distance) * 2;
			}

			// Move triShot
			triShot.x += triShot.vx;
			triShot.y += triShot.vy;

			// Tri Shot collision with player.
			if (checkCollision(triShot, player)) {
			  if (player.shieldCount > 0) {
				// Shield case:
				player.shieldCount--;               // Consume one shield hit
				triShotShieldCount++;               // Increment the triShot shield counter
				triShots.splice(index, 1);          // Remove only the collided triShot
			  } else {
				// No-shield case:
				bossFail = 1;
				triShots = [];                      // Remove both triShots
				if (boss) {
				  bossState = "yellow";             // Reset boss state to yellow mode
				}
				triShotShieldCount = 0;             // Reset the triShot shield counter
				// Trigger player hit (which will decrement lives and handle respawn)
				playerHit();
				// (Optionally, break out of the loop if necessary to avoid further processing)
			  }
			}

		});
		
		// When triShotShieldCount reaches 2 or more, remove the boss:
		if (triShotShieldCount >= 2) {
		  // Remove the boss from the game
		  boss = null;
		  bossFight = false;
		  bossDead = true;
		  if (hasTriPurple === 1) {
			triPurple.active = false;
			bossReward = true;
			shop = true;
			updateShopStock();
		  } else {
			triPurple.active = true;
		  }
		  triShotShieldCount = 0;                   // Reset the triShot shield counter
		}		
	
	}

	// Simple collision detection (adjust the numbers if needed)
	function checkCollision(a, b) {
		// Standard AABB (Axis-Aligned Bounding Box) collision check
		if (
			a.x < b.x + b.size &&
			a.x + a.size > b.x &&
			a.y < b.y + b.size &&
			a.y + a.size > b.y
		) {
			return true;
		}

		// Additional check for triShot collision (if both are triShots)
		if (a.type === "triShot" && b.type === "triShot") {
			let dx = a.x - b.x;
			let dy = a.y - b.y;
			let distance = Math.sqrt(dx * dx + dy * dy);
			return distance < 16; // Collision if within 16 pixels
		}

		return false;
	}
	
	// Returns true if point (px, py) lies inside the triangle defined by points A, B, and C.
	function isPointInTriangle(px, py, ax, ay, bx, by, cx, cy) {
	  const areaOrig = Math.abs((bx - ax) * (cy - ay) - (cx - ax) * (by - ay));
	  const area1 = Math.abs((ax - px) * (by - py) - (bx - px) * (ay - py));
	  const area2 = Math.abs((bx - px) * (cy - py) - (cx - px) * (by - py));
	  const area3 = Math.abs((cx - px) * (ay - py) - (ax - px) * (cy - py));
	  // Use a tolerance to account for rounding errors:
	  return Math.abs((area1 + area2 + area3) - areaOrig) < 0.1;
	}

	function handleTriShotCollision(shotA, shotB) {
		if (shotA.bouncing || shotB.bouncing) return; // Ignore if already bouncing

		// Calculate direction between the two shots
		let angle = Math.atan2(shotA.y - shotB.y, shotA.x - shotB.x);

		// Apply opposite velocities for bouncing
		let speed = 3;
		shotA.vx = Math.cos(angle) * speed;
		shotA.vy = Math.sin(angle) * speed;
		shotB.vx = -Math.cos(angle) * speed;
		shotB.vy = -Math.sin(angle) * speed;

		// Mark them as bouncing and set the bounce start time
		shotA.bouncing = true;
		shotB.bouncing = true;
		shotA.bounceStart = Date.now();
		shotB.bounceStart = Date.now();
	}

	// Fire an orange boss shot.
	function fireBossShotOrange(style, startX, startY, angle, speedMod = 1) {
	  let speed, size;
	  if (style === "large") {
		speed = 3;
		size = 20; // twice the normal shot size
	  } else { // single
		speed = 4.5;
		size = 10;
	  }
	  speed *= speedMod;
	  // If angle not provided, fire directly at player.
	  if (angle === undefined) {
		angle = Math.atan2(player.y + player.size/2 - startX, player.x + player.size/2 - startX);
		// Alternatively, use: 
		angle = Math.atan2(player.y + player.size/2 - startY, player.x + player.size/2 - startX);
	  }
	  let shot = {
		type: "orange",
		style: style,
		x: startX,
		y: startY,
		vx: Math.cos(angle) * speed,
		vy: Math.sin(angle) * speed,
		size: size,
		bounceCount: 0
	  };
	  bossShots.push(shot);
	}
	
	// Update boss shots movement, collision with boss rocks, shield rings, moat, and player.
	function updateBossShots() {
	  for (let i = bossShots.length - 1; i >= 0; i--) {
		let shot = bossShots[i];
		if (!shot) continue;  // Skip undefined entries.
		
		// For red shots, check if it's time to switch to homing.
		if (shot.type === "red" && !shot.homing) {
		  let elapsed = Date.now() - shot.firedTime;
		  if (elapsed >= shot.straightDuration) {
			shot.homing = true;
		  }
		}
		// If homing, adjust velocity to chase the player.
		if (shot.type === "red" && shot.homing) {
		  let centerPlayerX = player.x + player.size/2;
		  let centerPlayerY = player.y + player.size/2;
		  let dx = centerPlayerX - shot.x;
		  let dy = centerPlayerY - shot.y;
		  let dist = Math.sqrt(dx*dx + dy*dy);
		  if (dist > 0) {
			shot.vx = (dx / dist) * 4.5;
			shot.vy = (dy / dist) * 4.5;
		  }
		}
		
		// Update position.
		shot.x += shot.vx;
		shot.y += shot.vy;
		
		// Boss Shot collision with Moat
		if (shot.x - shot.size/2 < 20 || shot.y - shot.size/2 < 20 ||
			shot.x + shot.size/2 > canvas.width - 20 || shot.y + shot.size/2 > canvas.height - 20) {
		  shot.remove = true;
		  continue;
		}
		
		// Shot collision with boss rocks.
		for (let j = bossRocks.length - 1; j >= 0; j--) {
		  let rock = bossRocks[j];
		  if (bossShotRockCollision(shot, rock)) {
			if (shot.type === "red") {
			  shot.remove = true;
			  break;
			} else if (shot.type === "orange") {
			  if (shot.style === "large") {
				shot.remove = true;
				bossRocks.splice(j, 1);
				break;
			  } else {
				let closestX = clamp(shot.x, rock.x, rock.x + rock.width);
				let closestY = clamp(shot.y, rock.y, rock.y + rock.height);
				let dx = shot.x - closestX;
				let dy = shot.y - closestY;
				let mag = Math.sqrt(dx*dx + dy*dy);
				if (mag > 0) {
				  let nx = dx / mag;
				  let ny = dy / mag;
				  let reflected = reflectVector(shot.vx, shot.vy, nx, ny);
				  shot.vx = reflected.vx;
				  shot.vy = reflected.vy;
				  shot.bounceCount++;
				}
			  }
			} else if (shot.type === "green" || shot.type === "blue") {
			  let closestX = clamp(shot.x, rock.x, rock.x + rock.width);
			  let closestY = clamp(shot.y, rock.y, rock.y + rock.height);
			  let dx = shot.x - closestX;
			  let dy = shot.y - closestY;
			  let mag = Math.sqrt(dx*dx + dy*dy);
			  if (mag > 0) {
				let nx = dx / mag;
				let ny = dy / mag;
				let reflected = reflectVector(shot.vx, shot.vy, nx, ny);
				shot.vx = reflected.vx;
				shot.vy = reflected.vy;
				shot.bounceCount++;
			  }
			}
		  }
		}
		
		// Remove shot if bounce count exceeds 25.
		if (shot.bounceCount > 25) {
		  shot.remove = true;
		}
		
		// Boss Shot collision with player.
		if (circlePlayerCollision(shot.x, shot.y, shot.size/2, player)) {
		  if (shot.type === "green") {
			orbActive = false;
			progress++;
			if (progress >= 10) {nextLevel()};
			shot.remove = true;
		  }
		  else if (shot.type === "blue") {
			orbActive = false;
			player.lives = Math.min(player.lives + 1, 999);
			progress++;
			if (progress >= 10) {nextLevel()};
			shot.remove = true;
		  }
		  else if (shot.type === "red" || shot.type === "orange") {
			shot.remove = true;
			// If the player has a shield, reduce the shield count instead of triggering a hit.
			if (player.shieldCount > 0) {
			  player.shieldCount--;
			  if (debug) { console.log("Boss shot absorbed by shield. New shield count: " + player.shieldCount);}
			} else {
			  playerHit();
			}
		  }
		}

	  }
	  bossShots = bossShots.filter(s => s && !s.remove);
	}

	// Draw boss shots.
	function drawBossShots() {
	  bossShots.forEach(shot => {
		ctx.beginPath();
		ctx.arc(shot.x, shot.y, shot.size/2, 0, Math.PI*2);
		if (shot.type === "orange") {
		  ctx.fillStyle = "orange";
		} else if (shot.type === "red") {
		  ctx.fillStyle = "red";
		} else if (shot.type === "green") {
		  ctx.fillStyle = "green";
		} else if (shot.type === "blue") {
		  ctx.fillStyle = "blue";
		}
		ctx.fill();
	  });
	}
	// Draw tri shots as red isosceles triangles pointing in the direction of travel
	function drawTriShots() {
		triShots.forEach(triShot => {
		
			// Draw the purple trail
			ctx.globalAlpha = 0.25; // Semi-transparent effect
			ctx.fillStyle = PURPLE_COLOUR; // Trail color

			triShot.trail.forEach((pos, index) => {
				let sizeFactor = (index / triShot.trail.length) * 0.7 + 0.3; // Fades out
				let size = 8 * sizeFactor; // Smaller towards the end
				ctx.beginPath();
				ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
				ctx.fill();
			});

			ctx.globalAlpha = 1.0; // Reset transparency		
		
			let { x, y, vx, vy } = triShot;

			// Triangle size
			let base = 16;   // Width of the base
			let height = 24; // Length from base to tip

			// Calculate the angle of movement
			let angle = Math.atan2(vy, vx);

			// Calculate triangle points
			let tipX = x + Math.cos(angle) * height;
			let tipY = y + Math.sin(angle) * height;
			let leftX = x + Math.cos(angle + Math.PI * 2 / 3) * base;
			let leftY = y + Math.sin(angle + Math.PI * 2 / 3) * base;
			let rightX = x + Math.cos(angle - Math.PI * 2 / 3) * base;
			let rightY = y + Math.sin(angle - Math.PI * 2 / 3) * base;

			// Draw the triangle
			ctx.fillStyle = "red";
			ctx.beginPath();
			ctx.moveTo(tipX, tipY);
			ctx.lineTo(leftX, leftY);
			ctx.lineTo(rightX, rightY);
			ctx.closePath();
			ctx.fill();
		});
	}
    
	// ========== The Orb Collision Function ==========
	function orbCollision(orbColor, orbShape, colliderType, sqr, index) {
	  // Validate input
	  const validColors = ["green", "blue", PURPLE_COLOUR, ICE_COLOUR, "orange", "red"];
	  const validShapes = ["circle", "hex"];
	  const validColliders = ["player", "sqr", "shot"];

	  if (!validColors.includes(orbColor) || !validShapes.includes(orbShape) || !validColliders.includes(colliderType)) {
		// Invalid parameters  handle error accordingly.
		return;
	  }

	  // Process collision based on collider type
	  switch(colliderType) {
		// ===== Player Collisions with Orbs =====
		case "player":
		  switch(orbColor) {
			case "green":
			  if (orbShape === "circle") {
				// Player collided with a green circle orb
				progress++;                                             // Add progress
				if (progress >= 5) {nextLevel()};                       // If  5, next level
			  } else if (orbShape === "hex") {
				// Player collided with a green hex orb
				progress = 5;                                           // Set progress to 5
				initiateBossFight();                                    // Start Boss Fight
			  }
			  break;
			case "blue":
			  if (orbShape === "circle") {
				// Player collided with a blue circle orb
				progress++;                                             // Add progress
				if (hasDoubleLife === 1) {
				  player.lives = Math.min(player.lives + 2, 999);       // Add 2 lives (upto 999)
				} else {
				  player.lives = Math.min(player.lives + 1, 999);       // Add a life (upto 999)
				} 
				if (progress >= 5) {nextLevel()}; // If 5, next level
			  } else if (orbShape === "hex") {
				// Player collided with a blue hex orb
				if (hasDoubleLife === 1) {
				  player.lives = Math.min(player.lives + 2, 999);       // Add 2 lives (upto 999)
				} else {
				  player.lives = Math.min(player.lives + 1, 999);       // Add a life (upto 999)
				} 
				progress = 5;                                           // Set progress to 5
				initiateBossFight();                                    // Start Boss Fight
			  }
			  break;
			case PURPLE_COLOUR:
			  if (orbShape === "circle") {
				// Player collided with a purple circle orb
				activatePurplePower();                                  // Do Purple Power
			  } else if (orbShape === "hex") {
				// Player collided with a purple hex orb
			  }
			  break;
			case ICE_COLOUR:
			  if (orbShape === "circle") {
				// Player collided with a light blue circle orb
				activateIcePower();                                     // Do Ice Power
			  } else if (orbShape === "hex") {
				// Player collided with a light blue hex orb
			  }
			  break;
			case "orange":
			  if (orbShape === "circle") {
				// Player collided with an orange circle orb
			  } else if (orbShape === "hex") {
				// Player collided with an orange hex orb
			  }
			  break;
			case "red":
			  if (orbShape === "circle") {
				// Player collided with a red circle orb
			  } else if (orbShape === "hex") {
				// Player collided with a red hex orb
			  }
			  break;
			default:
			  // Player collision with an unhandled orb type
		  }
		  break;
		  
		// ===== Sqr Collisions with Orbs =====
		case "sqr":
		
		// Global interactions
		if ((orbShape === "circle" || orbShape === "hex") && (sqr.color === PURPLE_COLOUR || sqr.color === ICE_COLOUR)) {
			sqrs.splice(index, 1);
			orbActive = false;            // Remove the orb
	        setTimeout(spawnorb, 1000);   // Schedule a new orb spawn after 1s
			return; // Exit the function so no further processing is done.
		}
		
		  switch(orbColor) {
			case "green":
			  if (orbShape === "circle") {
				// Sqr collided with a green circle orb
				if (sqr.color === "yellow") {                           // Yellow evolve to Orange
					sqr.color = "orange";
					let angle = Math.atan2(sqr.speedY, sqr.speedX);
					sqr.speedX = Math.cos(angle) * ORANGE_SPEED;
					sqr.speedY = Math.sin(angle) * ORANGE_SPEED;
				} else if (sqr.color === "orange") {                    // Orange evolve to Red
					sqr.color = "red";
					let angle = Math.atan2(sqr.speedY, sqr.speedX);
					sqr.speedX = Math.cos(angle) * RED_SPEED;
					sqr.speedY = Math.sin(angle) * RED_SPEED;
				} else if (sqr.color === "red") {                       // Reduce Progress
					progress = Math.max(0, progress - 1);
				}							
			  } else if (orbShape === "hex") {
				// Sqr collided with a green hex orb
			  }
			  break;
			case "blue":
			  if (orbShape === "circle") {
				// Sqr collided with a blue circle orb
				let newSqr = {                                          // Spawn New Yellow Sqr
					x: sqr.x,
					y: sqr.y,
					size: YELLOW_SIZE,
					color: "yellow",
					speedX: Math.cos(getRandomAngle()) * YELLOW_SPEED,
					speedY: Math.sin(getRandomAngle()) * YELLOW_SPEED
				};
				// Add the new sqr to the sqr list
				sqrs.push(newSqr);				
			  } else if (orbShape === "hex") {
				// Sqr collided with a blue hex orb
				let newSqr = {                               			// Spawn New Yellow Sqr
					x: sqr.x,
					y: sqr.y,
					size: YELLOW_SIZE,
					color: "yellow",
					speedX: Math.cos(getRandomAngle()) * YELLOW_SPEED,
					speedY: Math.sin(getRandomAngle()) * YELLOW_SPEED
				};				
			  }
			  break;
			case PURPLE_COLOUR:
			  if (orbShape === "circle") {
				// Sqr collided with a purple circle orb
				sqr.color = PURPLE_COLOUR;                               // Semi-Permanent Purple
				sqr.temporarilyPurple = true;
				sqr.temporarilyFrozen = false;
				hudorbIndicator.style.backgroundColor = PURPLE_COLOUR;  // Set the indicator
			  } else if (orbShape === "hex") {
				// Sqr collided with a purple hex orb
			  }
			  break;
			case ICE_COLOUR:
			  if (orbShape === "circle") {
				// Sqr collided with a light blue circle orb
				sqr.color = ICE_COLOUR;                                 // Semi-Permanent Ice
				sqr.temporarilyPurple = false;
				sqr.temporarilyFrozen = true;
			  } else if (orbShape === "hex") {
				// Sqr collided with a light blue hex orb
			  }
			  break;
			case "orange":
			  if (orbShape === "circle") {
				// Sqr collided with an orange circle orb
			  } else if (orbShape === "hex") {
				// Sqr collided with an orange hex orb
			  }
			  break;
			case "red":
			  if (orbShape === "circle") {
				// Sqr collided with a red circle orb
			  } else if (orbShape === "hex") {
				// Sqr collided with a red hex orb
			  }
			  break;
			default:
			  // Sqr collision with an unhandled orb type
		  }
		  break;

		// ===== Shot Collisions with Orbs =====
		case "shot":
		  switch(orbColor) {
			case "green":
			  if (orbShape === "circle") {
				// Shot collided with a green circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a green hex orb
			  }
			  break;
			case "blue":
			  if (orbShape === "circle") {
				// Shot collided with a blue circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a blue hex orb
			  }
			  break;
			case PURPLE_COLOUR:
			  if (orbShape === "circle") {
				// Shot collided with a purple circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a purple hex orb
			  }
			  break;
			case ICE_COLOUR:
			  if (orbShape === "circle") {
				// Shot collided with a light blue circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a light blue hex orb
			  }
			  break;
			case "orange":
			  if (orbShape === "circle") {
				// Shot collided with an orange circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with an orange hex orb
			  }
			  break;
			case "red":
			  if (orbShape === "circle") {
				// Shot collided with a red circle orb
			  } else if (orbShape === "hex") {
				// Shot collided with a red hex orb
			  }
			  break;
			default:
			  // Shot collision with an unhandled orb type
		  }
		  break;

		default:
		  // Handle unhandled collider types
	  }
	  // Do these to all collided orbs
	  orbActive = false;            // Remove the orb
	  setTimeout(spawnorb, 1000);   // Schedule a new orb spawn after 1s
	}
    
    function resetAllsqrSpeeds() {
      sqrs.forEach(sqr => {
        if (sqr.color === "red") {
          sqr.speedX = Math.sign(sqr.speedX) * RED_SPEED;
          sqr.speedY = Math.sign(sqr.speedY) * RED_SPEED;
        } else if (sqr.color === "orange") {
          sqr.speedX = Math.sign(sqr.speedX) * ORANGE_SPEED;
          sqr.speedY = Math.sign(sqr.speedY) * ORANGE_SPEED;
        } else {
          sqr.speedX = Math.sign(sqr.speedX) * YELLOW_SPEED;
          sqr.speedY = Math.sign(sqr.speedY) * YELLOW_SPEED;
        }
      });
    }
    
    function updateHUD() {
	  const hudLife = document.getElementById("hudLife");
      hudLife.textContent = player.lives;
	  //document.getElementById("hudShield").textContent = `${player.shieldCount}/6`;
	  if (player.shieldCount > 0) {
	    hudLife.classList.add("shielded");
		document.getElementById("hudShield").textContent = player.shieldCount;
	  } else {
	    hudLife.classList.remove("shielded");
		document.getElementById("hudShield").textContent = "";
	  };
      
	  hudLevelElem.textContent = "Level " + player.level;
      // Display progress with denominator 10 during boss fight, else 5.
      if (bossFight) {
        hudLevelProg.textContent = `${progress}/10`;
      } else {
        hudLevelProg.textContent = `${progress}/5`;
      }
      hudLevelProg.appendChild(hudorbIndicator);
      if (player.level > highScore) {
        highScore = player.level;
		localStorage.setItem("highScore", highScore); // Save new high score
      }
      hudHighScore.textContent = highScore;
	  triHud();
    }
	
	function ActivePowers() {
		// Green
		if (hasTriGreen === 1) {
			hasGreenArrow = 1;
			hasSuperOrb = 1;
		}		
		// Blue
		if (hasTriBlue === 1) {
			hasDoubleLife = 1;
		}		
		// Purple
	}
    
    // PlayerHit mechanic.
	function playerHit() {
		if (!gamePaused) {
			// Clear trail on death
			playerTrail = [];
			if (player.shieldCount > 0) {
				// Shield case: reduce shield count and display "Shield Lost" in purple.
				player.shieldCount--;
				bossHitColour = PURPLE_COLOUR;
				bossHitText = "Shield Lost";
			} else {
				// No shield available: subtract a life.
				player.lives--;
				shieldRings = [];
				// Only display "Life Lost" if the player still has lives remaining.
				if (player.lives > 0) {
					bossHitColour = "orange";
					bossHitText = "Life Lost";
				}
			}

			if (player.lives >= 1) {
				setPause(true, bossHitColour, bossHitText);
				hitCooldown = true;
				let pos;
				if (bossFight) {
					let obstacles = [];
					if (boss) obstacles.push({ x: boss.x, y: boss.y, size: boss.size });
					bossRocks.forEach(br => {
						obstacles.push({ x: br.x, y: br.y, size: br.size });
					});
					pos = getValidBossFightSpawnPosition(player.size, obstacles);
				} else {
					pos = getValidSpawnPosition(player.size, rocks.concat(sqrs, [orb]));
				}
				player.x = pos.x;
				player.y = pos.y;
				setTimeout(() => { hitCooldown = false; }, 1000);
			}		
			if (bossFight) {
				if (bossState === "orange") {
					bossFail = 1;
					bossState = "yellow"; // Reset boss state to yellow mode
				}	
				bossShots = [];
			}
		}
	}
    
    // Draw the Boss
    function drawBoss(cx, cy, size, rotation, color) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rotation);
      ctx.beginPath();
      let r = size / 2;
      for (let i = 0; i < 6; i++) {
        let angle = i * Math.PI / 3;
        let x = r * Math.cos(angle);
        let y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();
    }
	// Draw triangle centered at (cx,cy).
	function drawTriangle(cx, cy, width, height, color) {
	  ctx.beginPath();
	  ctx.moveTo(cx, cy - height / 2);         // Top vertex
	  ctx.lineTo(cx - width / 2, cy + height / 2); // Bottom left
	  ctx.lineTo(cx + width / 2, cy + height / 2); // Bottom right
	  ctx.closePath();
	  ctx.fillStyle = color;
	  ctx.fill();
	}
	function drawGlowingTriangle(cx, cy, width, height, fillColor, glowColor, glowBlur) {
	  ctx.save();
	  ctx.shadowColor = glowColor;
	  ctx.shadowBlur = glowBlur;
	  ctx.shadowOffsetX = 0;
	  ctx.shadowOffsetY = 0;
	  drawTriangle(cx, cy, width, height, fillColor);
	  ctx.restore();
	}
	
	function drawJoystickOverlay() {
	  if (!touchActive) return;
	  
	  // Convert the initial touch point to canvas coordinates.
	  const rect = canvas.getBoundingClientRect();
	  const centerX = touchStartX - rect.left;
	  const centerY = touchStartY - rect.top;
	  
	  // Joystick parameters
	  const joystickRadius = 75; // outer circle radius
	  const halfRadius = joystickRadius / 2; // cross arm length
	  
	  // Draw the filled circle (75% transparent grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, joystickRadius, 0, Math.PI * 2);
	  ctx.fillStyle = "rgba(64,64,64,0.25)"; // 75% transparent grey
	  ctx.fill();
	  
	  // Draw the circumference stroke (50% transparent dark grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, joystickRadius, 0, Math.PI * 2);
	  ctx.strokeStyle = "rgba(64,64,64,0.5)"; // 50% transparent dark grey
	  ctx.lineWidth = 2;
	  ctx.stroke();
	  
	  // Draw the cross:
	  ctx.beginPath();
	  // Horizontal line
	  ctx.moveTo(centerX - halfRadius, centerY);
	  ctx.lineTo(centerX + halfRadius, centerY);
	  // Vertical line
	  ctx.moveTo(centerX, centerY - halfRadius);
	  ctx.lineTo(centerX, centerY + halfRadius);
	  ctx.strokeStyle = "rgba(64,64,64,0.5)";
	  ctx.lineWidth = 2;
	  ctx.stroke();
	  
	  // Draw the center dot (25% transparent dark grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
	  ctx.fillStyle = "rgba(64,64,64,0.25)";
	  ctx.fill();
	}
	
	// Shop stuff!
		
	function createShopToken({
	  size = 40, 
	  colour = "#663300", 
	  title = "Default Shop Token", 
	  cost = 1,
	  reward = null,
	  payment = "blue", 
	  x = canvas.width / 2, 
	  y = canvas.height / 2 ,
	  active = false
	} = {}) {
	  const token = { size, colour, title, cost, reward, payment, x, y, active};
	  shopTokens.push(token);
	}	
	
	// Center the player in the shop
	function moveShopper() {
	  player.x = canvas.width / 2 - player.size / 2;
	  player.y = canvas.height / 2 - player.size / 2 + 50;
	}

	// Shop stock	
	const shopStock1 = [ // 1st stall - Green Stock
	  { title: "New Stock",   cost: 1, reward: "newStock" },
	  { title: "+1 Life",     cost: 2, reward: "Life" },
	  { title: "+1 Shield",   cost: 2, reward: "Shield" },
	  { title: "+1 Level",    cost: 3, reward: "Level" },
	  { title: "Boss Skip",   cost: 3, reward: "bossSkip" },
	  { title: "Green Arrow", cost: 4, reward: "greenArrow" },
	];
	const shopStock2 = [ // 2nd stall - Blue Stock
	  { title: "New Stock",   cost: 1, reward: "newStock" },
	  { title: "+1 Shield",   cost: 1, reward: "Shield" },
	  { title: "+1 Level",    cost: 1, reward: "Level" },
	  { title: "Double Life", cost: 5, reward: "doubleLife" },
	];		
	const shopStock3 = [ // 3rd stall - Purple Stock
	  { title: "New Stock",   cost: 1, reward: "newStock" },
	  { title: "+1 Life",     cost: 1, reward: "Life" },
	  { title: "+1 Level",    cost: 1, reward: "Level" },
	  { title: "Boss Skip",   cost: 2, reward: "bossSkip" },
	];
	const shopStockBoss = [ // Boss Gift
	  { title: "+1 Life",     cost: 0, reward: "Life" },
	  { title: "+2 Lives",     cost: 0, reward: "2Life" },
	  { title: "+1 Shield",   cost: 0, reward: "Shield" },
	  { title: "+2 Shields",   cost: 0, reward: "2Shield" },
	  { title: "Boss Skip",   cost: 0, reward: "bossSkip" },
	];

	// Generic function to return a random element from any array.
	function getRandomElement(arr) {
	  const index = Math.floor(Math.random() * arr.length);
	  return arr[index];
	}

	function stockShop() {
  	    shopTokens = [];
		// Get a random shopToken from each shopStock array:
		const stockOption1 = getRandomElement(shopStock1);
		const stockOption2 = getRandomElement(shopStock2);
		const stockOption3 = getRandomElement(shopStock3);
		const stockOptionBoss = getRandomElement(shopStockBoss);
		return { stockOption1, stockOption2, stockOption3, stockOptionBoss };
	}
	
	function openShop() {
		shop = true;
		// CLear the level.
		sqrs = [];
		rocks = [];
		mud = [];
		orbActive = false;
		moveShopper();
		playerTrail = [];
		enterShop();
		updateShopStock();
		// Pause game and display text until the player moves.
		setPause(true, "#444", "Secret Shop");
		
		// Green Tri and Shields
		triGreen.y = 500;
		triGreen.active = shop;
		triGreen.active = currentShopId < 5;
	}
				
	// Stall setup
	function updateShopStock() {
	  const { stockOption1, stockOption2, stockOption3, stockOptionBoss } = stockShop();
	
		if ( !bossReward ) {
		  createShopToken({
			title: stockOption1.title,
			cost: stockOption1.cost,
			reward: stockOption1.reward,
			payment: "green",
			x: canvas.width / 2 - 300,
			y: canvas.height / 2 - 220,
			active: false
		  });
		  createShopToken({
			title: stockOption2.title,
			cost: stockOption2.cost,
			reward: stockOption2.reward,
			payment: "blue",
			x: canvas.width / 2,
			y: canvas.height / 2 - 220,
			active: false
		  });
		  createShopToken({
			title: stockOption3.title,
			cost: stockOption3.cost,
			reward: stockOption3.reward,
			payment: PURPLE_COLOUR,
			x: canvas.width / 2 + 300,
			y: canvas.height / 2 - 220,
			active: false
		  });
		} else { // Only show this item as a Boss Reward
		  createShopToken({
			title: stockOptionBoss.title,
			cost: stockOptionBoss.cost,
			reward: stockOptionBoss.reward,
			payment: "#222",
			x: canvas.width / 2,
			y: canvas.height / 2,
			active: true
		  });
	    }
	  
	}				
	
	function shopShields() {
		triGreen.shields[3] = !shopsPatronised[1];
		triGreen.shields[2] = !shopsPatronised[2];
		triGreen.shields[1] = !shopsPatronised[3];
		triGreen.shields[0] = !shopsPatronised[4];
	}
	
	// This function checks for a collision between the player and a shop token's triangle.
	function playerTokenCollision(token) {
	  // Only process if the token is active (using the string "true")
	  if (!shop) { return; }
	  if (token.active === false) return;
	  
	  // Use the same dimensions as in drawShopToken
	  const triWidth = token.size;
	  const triHeight = token.size * 0.8;
	  const triX = token.x - triWidth / 2;
	  const triY = token.y; // Triangle's top
	  
	  // Define the triangle's vertices:
	  const ax = triX + triWidth / 2, ay = triY;         // Top vertex
	  const bx = triX, by = triY + triHeight;              // Bottom left
	  const cx = triX + triWidth, cy = triY + triHeight;     // Bottom right
	  
	  // Compute player's center:
	  const playerCenterX = player.x + player.size / 2;
	  const playerCenterY = player.y + player.size / 2;
	  
	  // If the player's center lies within the triangle, we have a collision.
	  if (isPointInTriangle(playerCenterX, playerCenterY, ax, ay, bx, by, cx, cy)) {
		if (currentShopId !== null) {
		  shopsPatronised[currentShopId] = true;
		  if (debug) { console.log("Shop", currentShopId, "has been patronised.");}
		}	  
		makePurchase(token);
	  }
	}

	// Define what happens when a collision occurs.
	function makePurchase(token) {
	  // if (debug) {console.log("Player collided with token:", token);}
	  moveShopper();
	  // Pay the price
	  if (token.payment === "blue")        { player.lives -= token.cost; }
	  if (token.payment === "green")       { progress -= token.cost;	}
	  if (token.payment === PURPLE_COLOUR) { player.shieldCount -= token.cost;	}	  
	  // Get what you paid for
	  if (token.reward === "Life") {player.lives = Math.min(player.lives + 1, 999)}
	  if (token.reward === "2Life") {player.lives = Math.min(player.lives + 2, 999)}
	  if (token.reward === "Shield") {player.shieldCount = Math.min(player.shieldCount + 1, 6);}
	  if (token.reward === "2Shield") {player.shieldCount = Math.min(player.shieldCount + 2, 6);}
	  if (token.reward === "Level") {player.level++}
	  if (token.reward === "greenArrow") {hasGreenArrow = 1}
	  if (token.reward === "superOrb") {hasSuperOrb = 1}
	  if (token.reward === "doubleLife") {hasDoubleLife = 1}
	  if (token.reward === "bossSkip") {bossSkip = 1}
	  if (token.reward === "newStock") {updateShopStock()}
	  // Skip to next level on Boss Gift
	  if (token.cost === 0 ) {nextLevel()}
	  // Reset token
	  token.active = false;
	}
	
	// If the player tries to wrap in the shop - Exit	
	function exitArea() {
		if (isWrapping && shop || isWrapping && bossDead) {
			pos = getValidSpawnPosition(player.size, rocks.concat(sqrs, [orb]));
		    player.x = pos.x;
		    player.y = pos.y;
			shop = false;
			bossDead = false;
			triGreen.active = shop;
			nextLevel();
		}
	};
 
	function spawnBossRocks() {
	  const bossRocks = [];
	  const numBossRocks = Math.floor(Math.random() * 6) + 5; // between 5 and 10
	  const bossCenterX = canvas.width / 2;
	  const bossCenterY = canvas.height / 2;
	  const sizes = [{w: 25, h: 50}, {w: 25, h: 75}, {w: 25, h: 100}, {w: 100, h: 25}, {w: 75, h: 25}, {w: 50, h: 25}];

	  let attempts = 0;
	  const maxAttempts = 1000;

	  for (let i = 0; i < numBossRocks; i++) {
		let placed = false;
		while (!placed && attempts < maxAttempts) {
		  attempts++;
		  let angle = Math.random() * 2 * Math.PI;
		  let distance = 175 + Math.random() * (225 - 175);
		  let rockPosX = bossCenterX + distance * Math.cos(angle);
		  let rockPosY = bossCenterY + distance * Math.sin(angle);
		  let chosen = sizes[Math.floor(Math.random() * sizes.length)];
		  let corners = getRandomCornerPattern(); // assumes this function exists
		  let bossRock = {
			x: rockPosX,
			y: rockPosY,
			width: chosen.w,
			height: chosen.h,
			size: Math.max(chosen.w, chosen.h),
			color: "#222",
			corners: corners
		  };

		  // Ensure the rock doesn't spawn onto the 20px moat with a 20px buffer.
		  if (bossRock.x < 40 ||
			  bossRock.y < 40 ||
			  bossRock.x + bossRock.width > canvas.width - 40 ||
			  bossRock.y + bossRock.height > canvas.height - 40) {
			continue; // Skip this candidate and try again.
		  }

		  // Check for overlaps with already placed boss rocks.
		  let overlap = false;
		  for (let j = 0; j < bossRocks.length; j++) {
			let other = bossRocks[j];
			if (bossRock.x < other.x + other.width &&
				bossRock.x + bossRock.width > other.x &&
				bossRock.y < other.y + other.height &&
				bossRock.y + bossRock.height > other.y) {
			  overlap = true;
			  break;
			}
		  }
		  if (!overlap) {
			bossRocks.push(bossRock);
			placed = true;
		  }
		}
	  }
	  return bossRocks;
	}
 
    // Initiate boss fight by clearing entities, repositioning the player,
    // and creating the boss, bossMoat and bossRocks.
    function initiateBossFight() {
      bossFight = true;
	  bossFail = 0;
	  bossState = "yellow";
	  hasSpiralFired = false;  // Reset spiral flag for new boss fight
       // Destroy all sqrs and obstacles.
      sqrs = [];
      rocks = [];
      mud = [];
	  orbActive = false;
      // Create boss in the center.
      boss = {
        x: canvas.width / 2 - 50,
        y: canvas.height / 2 - 50,
        size: 100,
        color: "yellow",
        rotation: 0
      };
      // Create bossRocks.
      bossRocks = [];
	  bossRocks = spawnBossRocks();
      // Reposition the player so he doesn't start overlapping boss elements.
      let obstacles = [];
      obstacles.push({ x: boss.x, y: boss.y, size: boss.size });
      bossRocks.forEach(br => { obstacles.push({ x: br.x, y: br.y, size: br.size }); });
      let pos = getValidBossFightSpawnPosition(player.size, obstacles);
      player.x = pos.x;
      player.y = pos.y;
	  // Clear the trail when the player is moved.
	  playerTrail = [];
      
      // Pause game and display "Boss Fight" until the player moves.
      setPause(true, "orange", "Boss Fight");
    }
    
	// ========== Update Sqr behaviour ==========
	
	function updatesqrs() {
	  // First: Update each square's velocity based on its behavior.
	  sqrs.forEach(sqr => {

		// Calculate centers for the square and player.
		const centerPlayerX = player.x + player.size / 2;
		const centerPlayerY = player.y + player.size / 2;
		const centerSqrX = sqr.x + sqr.size / 2;
		const centerSqrY = sqr.y + sqr.size / 2;
		const dx = centerPlayerX - centerSqrX;
		const dy = centerPlayerY - centerSqrY;
		const distance = Math.hypot(dx, dy);

		// Determine if the square is in a mud zone.
		for (let zone of mud) {
			if (isIntersecting({ x: sqr.x, y: sqr.y, size: sqr.size }, zone)) {
				sqr.inMud = true;
			 // if (debug) { console.log("In mud!")};
				break;
			} else {sqr.inMud = false;}
		}	
		// Determine the size and speed from colour.
		let fixedSpeed = 0;
			if (sqr.color === "yellow")   { sqr.size = YELLOW_SIZE, sqr.speed = YELLOW_SPEED * (sqr.inMud ? MUD_SLOW : 1)};
			if (sqr.color === "orange")   { sqr.size = ORANGE_SIZE, sqr.speed = ORANGE_SPEED * (sqr.inMud ? MUD_SLOW : 1)};
			if (sqr.color === "red")      { sqr.size = RED_SIZE,    sqr.speed = RED_SPEED    * (sqr.inMud ? MUD_SLOW : 1)};
			if (sqr.color === ICE_COLOUR) {                         sqr.speed = ICE_SPEED    * (sqr.inMud ? MUD_SLOW : 1)};
		// Determine if this square is running away.
		const runningAway = (sqr.color === PURPLE_COLOUR || sqr.color === FLASH_COLOUR);
		
		// Sqr movement behaviour
		// If originally yellow and not running away, use wandering.
		if (sqr.size === YELLOW_SIZE && !runningAway) {
		  sqr.speedX += (Math.random() - 0.5) * 0.2;
		  sqr.speedY += (Math.random() - 0.5) * 0.2;
		  
		  // Normalize the speed.
		  const currentSpeed = Math.hypot(sqr.speedX, sqr.speedY);
		  if (currentSpeed > 0) {
			sqr.speedX = (sqr.speedX / currentSpeed) * sqr.speed;
			sqr.speedY = (sqr.speedY / currentSpeed) * sqr.speed;
		  }
		} else {
		  let dx, dy, distance, moveX, moveY;
		  if (runningAway) {
			// Calculate wrapped differences for running away
			let canvasWidth = canvas.width;
			let canvasHeight = canvas.height;
			dx = centerPlayerX - centerSqrX;
			if (dx > canvasWidth / 2) {
			  dx -= canvasWidth;
			} else if (dx < -canvasWidth / 2) {
			  dx += canvasWidth;
			}
			dy = centerPlayerY - centerSqrY;
			if (dy > canvasHeight / 2) {
			  dy -= canvasHeight;
			} else if (dy < -canvasHeight / 2) {
			  dy += canvasHeight;
			}
			distance = Math.sqrt(dx * dx + dy * dy);
			// Reverse the vector to run away from the player
			moveX = -dx / distance;
			moveY = -dy / distance;
		  } else {
			// For chasing, use direct differences (ignoring wrapping)
			dx = centerPlayerX - centerSqrX;
			dy = centerPlayerY - centerSqrY;
			distance = Math.sqrt(dx * dx + dy * dy);
			moveX = dx / distance;
			moveY = dy / distance;
		  }
		  sqr.speedX = moveX * sqr.speed;
		  sqr.speedY = moveY * sqr.speed;
		}
	  });
	  
	  // Second: Update position and handle collisions.
	  sqrs.forEach((sqr, index) => {
		// Reset rock collision flag at start of update.
		sqr.collidedWithRock = false;

		// Check for collision with an active orb.
		if (
		  orbActive &&
		  sqr.x < orb.x + orb.size &&
		  sqr.x + sqr.size > orb.x &&
		  sqr.y < orb.y + orb.size &&
		  sqr.y + sqr.size > orb.y
		) {
		  orbCollision(orb.color, orb.shape, "sqr", sqr, index);
		}

		// Apply the mud slowdown.
		const slowdownMultiplier = sqr.inMud ? MUD_SLOW : 1;
		let effectiveSpeedX = sqr.speedX * slowdownMultiplier;
		let effectiveSpeedY = sqr.speedY * slowdownMultiplier;
		
		// Store previous position before moving.
		let prevX = sqr.x, prevY = sqr.y;
		// Update position.
		sqr.x += effectiveSpeedX;
		sqr.y += effectiveSpeedY;

		// Check collision with rocks and resolve.
		for (let obs of rocks) {
		  // Compute intersection rectangle between square and rock.
		  let intersectLeft = Math.max(sqr.x, obs.x);
		  let intersectRight = Math.min(sqr.x + sqr.size, obs.x + obs.width);
		  let intersectTop = Math.max(sqr.y, obs.y);
		  let intersectBottom = Math.min(sqr.y + sqr.size, obs.y + obs.height);
		  
		  if (intersectRight > intersectLeft && intersectBottom > intersectTop) {
			// Collision detected.
			let intersectWidth = intersectRight - intersectLeft;
			let intersectHeight = intersectBottom - intersectTop;
			sqr.collidedWithRock = true;
			
			if (sqr.color === "yellow") {
			  // For yellow squares, resolve collision by moving them out along the smallest penetration.
			  if (intersectWidth < intersectHeight) {
				// Resolve horizontally.
				if (sqr.x + sqr.size/2 < obs.x + obs.width/2) {
				  // Square is on the left side of the rock.
				  sqr.x = obs.x - sqr.size;
				} else {
				  // Square is on the right side of the rock.
				  sqr.x = obs.x + obs.width;
				}
				// Reflect horizontal velocity.
				sqr.speedX = -sqr.speedX;
			  } else {
				// Resolve vertically.
				if (sqr.y + sqr.size/2 < obs.y + obs.height/2) {
				  // Square is above the rock.
				  sqr.y = obs.y - sqr.size;
				} else {
				  // Square is below the rock.
				  sqr.y = obs.y + obs.height;
				}
				// Reflect vertical velocity.
				sqr.speedY = -sqr.speedY;
			  }
			} else {
			  // For orange/red, simply reverse both velocity components.
			  sqr.speedX = -sqr.speedX;
			  sqr.speedY = -sqr.speedY;
			  // Also resolve position similar to above.
			  if (intersectWidth < intersectHeight) {
				if (sqr.x + sqr.size/2 < obs.x + obs.width/2) {
				  sqr.x = obs.x - sqr.size;
				} else {
				  sqr.x = obs.x + obs.width;
				}
			  } else {
				if (sqr.y + sqr.size/2 < obs.y + obs.height/2) {
				  sqr.y = obs.y - sqr.size;
				} else {
				  sqr.y = obs.y + obs.height;
				}
			  }
			}
			
			// Ensure speed is not below half the base speed.
			let baseSpeed = (sqr.color === "red") ? RED_SPEED : (sqr.color === "orange" ? ORANGE_SPEED : YELLOW_SPEED);
			if (Math.abs(sqr.speedX) < baseSpeed * 0.5) {
			  sqr.speedX = baseSpeed * Math.sign(sqr.speedX || 1);
			}
			if (Math.abs(sqr.speedY) < baseSpeed * 0.5) {
			  sqr.speedY = baseSpeed * Math.sign(sqr.speedY || 1);
			}
			// Once a collision is resolved for one rock, exit the loop.
			break;
		  }
		}
		
		// Bounce off the canvas edges.
		if (sqr.x <= 0 || sqr.x >= canvas.width - sqr.size) {
		  sqr.speedX = -sqr.speedX;
		  sqr.x += sqr.speedX;
		}
		if (sqr.y <= 0 || sqr.y >= canvas.height - sqr.size) {
		  sqr.speedY = -sqr.speedY;
		  sqr.y += sqr.speedY;
		}
		
		// Sqr collision with the player.
		if (
		  player.x < sqr.x + sqr.size &&
		  player.x + player.size > sqr.x &&
		  player.y < sqr.y + sqr.size &&
		  player.y + player.size > sqr.y
		) {
		  // If the square is temporarily frozen, remove it on collision.
		  if (sqr.temporarilyFrozen) {
			sqr.toRemove = true;
		  }
		  if (sqr.temporarilyPurple) {
			sqr.toRemove = true;
		  } else if (player.shieldCount > 0) {
			// Consume one shield and remove the square.
			player.shieldCount--;
			sqr.toRemove = true;
			if (debug) { console.log("Sqr collision - Shield count: " + player.shieldCount);}
		  } else {
			// Process a normal hit.
			playerHit();
		  }
		}
	  });

	  // Clear the rock collision flags for the next frame.
	  sqrs.forEach(sqr => {
		sqr.collidedWithRock = false;
	  });
	  
		// --- Handle collisions between yellow squares ---
		for (let i = 0; i < sqrs.length; i++) {
		  const sqr1 = sqrs[i];
		  if (sqr1.color !== "yellow") continue;
		  for (let j = i + 1; j < sqrs.length; j++) {
			const sqr2 = sqrs[j];
			if (sqr2.color !== "yellow") continue;
			
			// Skip if either square has just collided with a rock.
			if (sqr1.collidedWithRock || sqr2.collidedWithRock) continue;
			
			// Only process collision if neither square is within 10px of a rock.
			// const tooCloseToRock1 = rocks.some(rock => isTooClose(sqr1, rock, 10));
			// const tooCloseToRock2 = rocks.some(rock => isTooClose(sqr2, rock, 10));
			// if (tooCloseToRock1 || tooCloseToRock2) continue;
			
			// Check if the two yellow squares intersect.
			if (
			  sqr1.x < sqr2.x + sqr2.size &&
			  sqr1.x + sqr1.size > sqr2.x &&
			  sqr1.y < sqr2.y + sqr2.size &&
			  sqr1.y + sqr1.size > sqr2.y
			) {
			  // Compute the centers of each square.
			  const center1X = sqr1.x + sqr1.size / 2;
			  const center1Y = sqr1.y + sqr1.size / 2;
			  const center2X = sqr2.x + sqr2.size / 2;
			  const center2Y = sqr2.y + sqr2.size / 2;
			  
			  const dx = center1X - center2X;
			  const dy = center1Y - center2Y;
			  const distanceSq = dx * dx + dy * dy;
			  if (distanceSq === 0) continue; // Avoid division by zero.
			  
			  // Calculate the velocity difference and project it onto the
			  // vector between the centers (using the elastic collision formula for equal masses).
			  const dvx = sqr1.speedX - sqr2.speedX;
			  const dvy = sqr1.speedY - sqr2.speedY;
			  const dot = dvx * dx + dvy * dy;
			  const factor = dot / distanceSq;
			  
			  // New velocities after collision.
			  const newVx1 = sqr1.speedX - factor * dx;
			  const newVy1 = sqr1.speedY - factor * dy;
			  const newVx2 = sqr2.speedX + factor * dx;
			  const newVy2 = sqr2.speedY + factor * dy;
			  
			  // Re-normalize to maintain the fixed YELLOW_SPEED.
			  let mag1 = Math.sqrt(newVx1 * newVx1 + newVy1 * newVy1);
			  if (mag1 > 0) {
				sqr1.speedX = (newVx1 / mag1) * YELLOW_SPEED;
				sqr1.speedY = (newVy1 / mag1) * YELLOW_SPEED;
			  }
			  let mag2 = Math.sqrt(newVx2 * newVx2 + newVy2 * newVy2);
			  if (mag2 > 0) {
				sqr2.speedX = (newVx2 / mag2) * YELLOW_SPEED;
				sqr2.speedY = (newVy2 / mag2) * YELLOW_SPEED;
			  }
			}
		  }
		}
	  
	}

	// ==================== Main Update loop ====================
	
    function update() {
      // Save player's previous position for collision rollback.
      let playerPrevX = player.x;
      let playerPrevY = player.y;
	  
	if (player.x !== lastPlayerX || player.y !== lastPlayerY) {
	  // The player moved  update the last move time and store new position.
	  lastPlayerMoveTime = Date.now();
	  lastPlayerX = player.x;
	  lastPlayerY = player.y;
	} else {
	  // The player hasn't moved  if more than 6 seconds have passed, set override.
	  if (Date.now() - lastPlayerMoveTime >= 6000) {
		overrideNextBossShot = true;
	  }
	}	  
	  
       if (player.lives < 1) {
        if (!gameOver) {
          player.lives = 0;
          gameOver = true;
        }
        if (!gameOverPrompted) {
          gameOverPrompted = true;
          setTimeout(() => {
            messageOverlay.innerHTML += "<br><span style='font-size: 24px; color: blue;'>Try again?</span>";
            tryAgainAvailable = true;
          }, 1000);
        }
        return;
      }
      if (gameOver) return;
      if (gamePaused) return;
	  
	// Determine if the player is wrapping.
	if (
	  player.x < 0 ||
	  player.y < 0 ||
	  player.x + player.size > canvas.width ||
	  player.y + player.size > canvas.height
	) {
	  isWrapping = true;
	} else {
	  isWrapping = false;
	}
	  
	  // Update boss rotation if the boss exists.
	  if (boss) {
		boss.rotation += bossRotationSpeed; // bossRotationSpeed is set in updateBossState()
	  }
  
      // Award a shield ring if the temporary purple effect is active,
      // there are no sqrs left, a shield hasn't been awarded this level,
      if (purplePower && sqrs.length === 0 && !shieldAwardedForCurrentTempPurple) {
        player.shieldCount = Math.min(player.shieldCount + 1, 6);
        shieldAwardedForCurrentTempPurple = true;
		if (debug) { console.log("Area clear - Shield gained: " + player.shieldCount);}
      }
      // Recalculate shield ring radii using desired values.
      recalcShieldRadii();
      
	  // Purple Triangle Stuff & purpleOrb Power
		let effectivePlayerSpeed = player.speed;
		let addTrail = false;

		if (hasTriPurple === 1 && player.shieldCount >= 1) {
		  // When the purple triangle is active and the player has one or more shields:
		  // Increase speed by 0.5 per shield.
		  effectivePlayerSpeed = Math.min(player.speed + player.shieldCount * 0.5, player.speed + 3);
		  // Bypass mud slowdown.
		  addTrail = true;
		} else if (purplePower) {
		  // Temporary purple orb effect: no mud slowdown.
		  effectivePlayerSpeed = player.speed;
		  addTrail = true;
		} else {
		  // Player in mud slowdown.
		  for (let zone of mud) {
			if (isIntersecting(player, zone)) {
			  effectivePlayerSpeed = player.speed * 0.2;
			  break;
			}
		  }
		}
		
		// Do the sqr Updates
		updatesqrs();
		// Do the Rock Updates
		checkRockCollision();
		rockFakeUpdate();
		shopShields();
		exitArea();


		// Add the purple trail if either purple effect is active.
		if (addTrail) {
		  playerTrail.push({ x: player.x, y: player.y });
		  if (playerTrail.length > TRAIL_LENGTH) {
			playerTrail.shift();
		  }
		} else {
		  // Otherwise, clear the trail.
		  playerTrail = [];
		}
		
      let dx = 0, dy = 0;
      if (keys["ArrowUp"] || keys["w"]) dy -= effectivePlayerSpeed;
      if (keys["ArrowDown"] || keys["s"]) dy += effectivePlayerSpeed;
      if (keys["ArrowLeft"] || keys["a"]) dx -= effectivePlayerSpeed;
      if (keys["ArrowRight"] || keys["d"]) dx += effectivePlayerSpeed;

		// Touch controls: override keyboard input if touch is active
		if (touchActive) {
			// Calculate the magnitude of the touch displacement.
			let mag = Math.sqrt(touchDx * touchDx + touchDy * touchDy);
			// Set a small deadzone to avoid jittering.
			const deadzone = 5;
			if (mag > deadzone) {
				// Normalize the touch vector (direction only).
				let normX = touchDx / mag;
				let normY = touchDy / mag;
				// Move the player at fixed speed.
				dx = normX * effectivePlayerSpeed;
				dy = normY * effectivePlayerSpeed;
			} else {
				dx = 0;
				dy = 0;
			}
		}
		// End Touch Controls
			  
			  let oldX = player.x;
			  player.x += dx;
			  
				// Clyde Mode [2505]
				if (inputNoWrap) {
				  // Clamp player's x so they cannot move past the canvas edges
				  if (shop) return;
				  if (player.x < 0) player.x = 0;
				  if (player.x + player.size > canvas.width) player.x = canvas.width - player.size;
				}	
				
				// Screen Wrap ability
				// Horizontal wrapping: when half of the player is off the canvas
				if (player.x >= canvas.width - player.size / 2) {
					player.x = -player.size / 2;
				}
				if (player.x < -player.size / 2) {
					player.x = canvas.width - player.size / 2;
				}

				// Vertical wrapping: when half of the player is off the canvas
				if (player.y >= canvas.height - player.size / 2) {
					player.y = -player.size / 2;
				}
				if (player.y < -player.size / 2) {
					player.y = canvas.height - player.size / 2;
				}
				

      
      let oldY = player.y;
      player.y += dy;
		if (inputNoWrap) {
		  // Clamp player's y so they cannot move past the canvas edges
		  if (player.y < 0) player.y = 0;
		  if (player.y + player.size > canvas.height) player.y = canvas.height - player.size;
		}	  
      if (player.y > canvas.height) player.y = -player.size;
      if (player.y + player.size < 0) player.y = canvas.height;

        // Player collision with Rocks.
		// Handle Rock collisions separately along each axis.
		let tentativeX = player.x; // player.x has been updated by dx already.
		let tentativeY = player.y; // player.y has been updated by dy already.
		// First, check horizontal collision by testing new x with previous y.
		if (isCollidingWithObstacle({ x: tentativeX, y: playerPrevY, size: player.size }, rocks)) {
		  tentativeX = playerPrevX;
		}
		// Next, check vertical collision using the (possibly adjusted) x and new y.
		if (isCollidingWithObstacle({ x: tentativeX, y: tentativeY, size: player.size }, rocks)) {
		  tentativeY = playerPrevY;
		}
		player.x = tentativeX;
		player.y = tentativeY;
      
		// Player collision with orbs
		if (orbActive &&
		player.x < orb.x + orb.size &&
		player.x + player.size > orb.x &&
		player.y < orb.y + orb.size &&
		player.y + player.size > orb.y) {
			orbCollision(orb.color, orb.shape, "player");
		};

	  // Player collision with active shop tokens.
	  shopTokens.forEach(token => {
		playerTokenCollision(token);
	  }); 
  
      // Remove any sqrs marked for removal.
      sqrs = sqrs.filter(sqr => !sqr.toRemove);
      
      // Boss fight collisions.
      if (bossFight) {
	  if (!gamePaused) {
		// If no boss rocks remain, set boss colour to orange.
		if (bossRocks.length === 0) {

		  	updateBossState();
		}
	  }
        // Player collision with Boss (using bounding box).
        if (boss &&
            player.x < boss.x + boss.size &&
            player.x + player.size > boss.x &&
            player.y < boss.y + boss.size &&
            player.y + player.size > boss.y) {
			if (bossState !== "yellow") {
				bossFail = 1;
				bossState = "yellow";
				triShots = [];
			}
          playerHit();
        }
        // Player collision with bossMoat.
        if (player.x < 20 ||
            player.y < 20 ||
            player.x + player.size > canvas.width - 20 ||
            player.y + player.size > canvas.height - 20) {
			if (bossState !== "yellow") {
				bossFail = 1;
				bossState = "yellow";
				triShots = [];
			}			
            playerHit();
        }
        // Player collision with bossRocks.
		// Handle bossRock collisions separately along each axis.
		let tentativeX = player.x; // player.x has been updated by dx already.
		let tentativeY = player.y; // player.y has been updated by dy already.
		// Check horizontal collision by testing new x with previous y.
		if (isCollidingWithObstacle({ x: tentativeX, y: playerPrevY, size: player.size }, bossRocks)) {
		  tentativeX = playerPrevX;
		}
		// Check vertical collision using the (possibly adjusted) x and new y.
		if (isCollidingWithObstacle({ x: tentativeX, y: tentativeY, size: player.size }, bossRocks)) {
		  tentativeY = playerPrevY;
		}
		player.x = tentativeX;
		player.y = tentativeY;
	  
		// Fire a new boss shot if the timer has expired.
		if (bossState === "yellow") {
		  let currentTime = Date.now();
		  if (currentTime - lastBossShotTime >= bossShotInterval) {
			fireBossShot();
			scheduleNextBossShot();
		  }
		}
		// Update existing boss shots.
		updateBossShots();
		updateTriShots();
      }
		checkTriGreenCollision();
		checkTriGreenShieldCollision();
		checkTriBlueCollision();
		checkTriPurpleCollision();
		
		// Activate Tri Powers
		ActivePowers();
		
    }  // ===== End main update loop=====
    
    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
	
	// Draw Shop

	// Modified drawShopToken function that draws a single token
	function drawShopToken(token) {
	  if (!token) {
		console.error("drawShopToken called with undefined token");
		return;				
	  }
	  
	  //Determine payment method
	  let threshold = player.lives;
	  if (token.payment === "green") { threshold = progress; }
	  if (token.payment === PURPLE_COLOUR) { threshold = player.shieldCount; }		
	  // --- Set text colour if player can afford the cost ---	
	  let tokenColour = (token.cost > threshold) ? "#222" : token.colour;
      let costColour = (token.cost > threshold) ? "#444" : "white";	  
	  let titleColour = (token.cost > threshold) ? "#222" : "white";
	  let valueColour = (token.cost > threshold) ? "#222" : "white";
	  if (token.cost <= threshold) { token.active = true };
	  
	  // --- Draw the triangle ---
	  const triWidth = token.size;
	  const triHeight = token.size * 0.8; // Adjust height as needed
	  const triX = token.x - triWidth / 2;
	  const triY = token.y; // Triangle's top starts at token.y
	  
	  ctx.save();
	  ctx.fillStyle = tokenColour;
	  ctx.beginPath();
	  ctx.moveTo(triX + triWidth / 2, triY);  // Top vertex of the triangle
	  ctx.lineTo(triX, triY + triHeight);
	  ctx.lineTo(triX + triWidth, triY + triHeight);
	  ctx.closePath();
	  ctx.fill();
	  ctx.restore();
 
	  // --- Measure text width for auto-resizing the rectangle ---
	  ctx.save();
	  ctx.font = "14px Arial"; // Set font for measurement
	  let textWidth = ctx.measureText(token.title).width;
	  ctx.restore();
	  
	  // --- Calculate extra space for the cost circle ---
	  let circleRadius = token.circleRadius || 15; // radius for cost circle
	  let circlePadding = 10; // space between circle and text
	  let circleTotalWidth = (circleRadius * 2) + circlePadding;
	  
	  let padding = 20; // extra width for rectangle padding
	  let rectWidth = Math.max(textWidth + padding + circleTotalWidth, 25 * 2);
	  let rectHeight = 20;
	  let rectX = token.x - rectWidth / 2;
	  let rectY = token.y - rectHeight - 20; // 20px gap above the triangle
	  const radius = 10;
	  
	  // --- Draw filled rounded rectangle (using your existing function) ---
	  ctx.fillStyle = "#444";
	  drawRoundedRect(rectX, rectY, rectWidth, rectHeight, radius);
	  
	  // --- Draw the rectangle outline ---
	  ctx.beginPath();
	  ctx.moveTo(rectX + radius, rectY);
	  ctx.lineTo(rectX + rectWidth - radius, rectY);
	  ctx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
	  ctx.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
	  ctx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
	  ctx.lineTo(rectX + radius, rectY + rectHeight);
	  ctx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
	  ctx.lineTo(rectX, rectY + radius);
	  ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
	  ctx.closePath();
	  ctx.strokeStyle = "black";
	  ctx.lineWidth = 1;
	  ctx.stroke();
	  
	  // --- Draw the cost circle inside the rectangle ---
	  const circleCenterX = rectX + circleRadius; 
	  const circleCenterY = rectY + rectHeight / 2;
	  ctx.beginPath();
	  ctx.arc(circleCenterX, circleCenterY, circleRadius, 0, Math.PI * 2);
	  ctx.fillStyle = token.payment;
	  ctx.fill();
	  ctx.lineWidth = 1;
	  ctx.strokeStyle = "black";
	  ctx.stroke();
	  ctx.closePath();

	  // Draw the cost number centered inside the circle
		ctx.save();
		ctx.fillStyle = costColour;
		ctx.font = token.cost === 0 ? "bold 8px Arial" : "bold 14px Arial";
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText(token.cost === 0 ? "FREE" : token.cost, circleCenterX, circleCenterY);
		ctx.restore();
	  
	  // --- Draw the title text inside the rectangle ---
	  const textX = circleCenterX + circleRadius + circlePadding;
	  ctx.save();
	  ctx.fillStyle = titleColour;
	  ctx.font = "14px Arial";
	  ctx.textAlign = "left";
	  ctx.textBaseline = "middle";
	  ctx.fillText(token.title, textX, rectY + rectHeight / 2 + 1);
	  ctx.restore();
	}	

	// Function to draw all shop tokens
	function drawShopTokens() {
	  shopTokens.forEach(token => {
		drawShopToken(token);
	  });
	}
    
	function drawrock(obs) {
	  // Destructure properties.
	  const { x, y, width, height } = obs;
	  let corners = obs.corners;
	  // Use a default radius based on rock size.
	  let radius = Math.min(width, height) / 4;
	  
	  // If this rock is flagged as rockFake, override its corners and fill style.
	  if (obs.rockFake) {
		// Force all sides to be curved.
		corners = [true, true, true, true];
		// Use the rock's original colour (set in spawnrocks) normally,
		// but if the player is inside (after 500ms collision), switch to a darker colour.
		ctx.fillStyle = obs.inside ? "#1A1A1A" : obs.color;
	  } else {
		// For normal rocks, use their defined colour.
		ctx.fillStyle = obs.color;
	  }
	  
	  // Begin drawing using the (possibly overridden) corners.
	  ctx.beginPath();
	  if (corners[0]) {
		ctx.moveTo(x + radius, y);
	  } else {
		ctx.moveTo(x, y);
	  }
	  if (corners[1]) {
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	  } else {
		ctx.lineTo(x + width, y);
	  }
	  if (corners[2]) {
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	  } else {
		ctx.lineTo(x + width, y + height);
	  }
	  if (corners[3]) {
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	  } else {
		ctx.lineTo(x, y + height);
	  }
	  if (corners[0]) {
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
	  } else {
		ctx.lineTo(x, y);
	  }
	  ctx.closePath();
	  ctx.fill();
	}
 
	function lightenColor(hex, amount) {
	  // Remove the leading '#' if present.
	  hex = hex.replace(/^#/, '');
	  // Convert 3-digit hex to 6-digit.
	  if (hex.length === 3) {
		hex = hex.split('').map(c => c + c).join('');
	  }
	  let num = parseInt(hex, 16);
	  let r = (num >> 16) + amount;
	  let g = ((num >> 8) & 0x00FF) + amount;
	  let b = (num & 0x0000FF) + amount;
	  r = r > 255 ? 255 : r;
	  g = g > 255 ? 255 : g;
	  b = b > 255 ? 255 : b;
	  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
	}
 
    function draw() { // Main Draw Loop
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      mud.forEach(zone => {
        ctx.fillStyle = zone.color;
        drawRoundedRect(zone.x, zone.y, zone.width, zone.height, 20);
      });
      rocks.forEach(obs => {
        ctx.fillStyle = obs.color;
        drawrock(obs);
      });
      if (gameOver) {
        ctx.textAlign = "center";
        ctx.font = "bold 30px Arial";
        ctx.fillStyle = "red";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "black";
        ctx.strokeText("GAME OVER", canvas.width / 2, canvas.height / 2);
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
        return;
      }
		
		// Draw Shop
		if (shop) { drawShopTokens(); }
		
		 // Draw Power Triangles
		drawTriPower();
		
		// Ghost Wrap
		function drawWrappingGhost() {
		  ctx.save();
		  
		  // Set up the glow effect.
		  // Adjust shadowBlur and shadowColor to achieve the desired glow brightness.
		  ctx.shadowColor = "rgba(255,255,255,1)";     // Pure White aura
		  ctx.shadowBlur = 25;                         // Nice and glowy
		  ctx.fillStyle = "rgba(255,255,255,0.033)";   // White and mostly see-through
		  
		  let ghostView = 20;
		  // If player's left edge is within ghostView of the left side, draw ghost square on right.
		  if (player.x <= ghostView) {
			ctx.fillRect(canvas.width - player.size, player.y, player.size, player.size);
		  }
		  // If player's right edge is within ghostView of the right side, draw ghost square on left.
		  if (player.x + player.size >= canvas.width - ghostView) {
			ctx.fillRect(0, player.y, player.size, player.size);
		  }
		  // If player's top edge is within ghostView of the top, draw ghost square on the bottom.
		  if (player.y <= ghostView) {
			ctx.fillRect(player.x, canvas.height - player.size, player.size, player.size);
		  }
		  // If player's bottom edge is within ghostView of the bottom, draw ghost square on the top.
		  if (player.y + player.size >= canvas.height - ghostView) {
			ctx.fillRect(player.x, 0, player.size, player.size);
		  }
		  
		  ctx.restore();
		}
		// Don't draw ghost if in shop (or 2505)
		if (!(inputNoWrap || shop)) {
		  drawWrappingGhost();
		}		
		// Draw player trail if purple power-up is active
		if (purplePower || (hasTriPurple === 1 && player.shieldCount >= 1)) {
		  ctx.globalAlpha = 0.25; // Semi-transparent effect
		  ctx.fillStyle = PURPLE_COLOUR; // Use the same purple as the power-up

		  playerTrail.forEach((pos, index) => {
			let size = player.size * ((index / TRAIL_LENGTH) * 0.7 + 0.3);
			ctx.fillRect(pos.x + (player.size - size) / 2, pos.y + (player.size - size) / 2, size, size);
		  });

		  ctx.globalAlpha = 1.0; // Reset transparency
		}
		
		ctx.fillStyle = playerIsPink ? "#FFB7CE" : "white";
		ctx.fillRect(player.x, player.y, player.size, player.size);
		
		// Draw Orbs
		function drawOrb(orb) {
		  ctx.save();  // Save current canvas state

		  // Apply a glow effect if progress is 4.
		  if (progress === 4) {
			ctx.shadowColor = lightenColor(orb.color, 127);
			ctx.shadowBlur = 20;  // Glow size as before.
		  } else {
			ctx.shadowBlur = 0;
		  }

		  // Draw the orb based on its shape.
		  if (orb.shape === "hex") {
			// Use the existing drawBoss function for hex orbs.
			drawBoss(orb.x + orb.size / 2, orb.y + orb.size / 2, orb.size, 0, orb.color);
		  } else {
			ctx.fillStyle = orb.color;
			ctx.beginPath();
			ctx.arc(orb.x + orb.size / 2, orb.y + orb.size / 2, orb.size / 2, 0, Math.PI * 2);
			ctx.fill();
		  }

		  // If hasDoubleLife is active and the orb is blue,
		  // add a glowing inner ring to signify the effect.
		  if (orb.color === "blue" && hasDoubleLife === 1) {
			ctx.save();  // Save state for the ring
			ctx.shadowColor = "#00BFFF";  // Glowing blue color
			ctx.shadowBlur = 5;
			ctx.lineWidth = 2;
			ctx.strokeStyle = "#00BFFF";
			ctx.beginPath();
			// Draw a circle slightly smaller than the orb's outer edge.
			ctx.arc(orb.x + orb.size / 2, orb.y + orb.size / 2, (orb.size / 2) - 3, 0, Math.PI * 2);
			ctx.stroke();
			ctx.restore();  // Restore state after drawing the ring
		  }

		  ctx.restore();  // Restore the canvas state
		}		
		//Draw Orbs if active
		if (orbActive) {
			drawOrb(orb);
		}

	    // Draw sqrs
		sqrs.forEach(sqr => {
			// Set Colour
			ctx.fillStyle = sqr.color;

		  // Draw the sqr
		  ctx.fillRect(sqr.x, sqr.y, sqr.size, sqr.size);

		  // Handle Green Arrow Power
		  if (hasGreenArrow === 1 && gamePaused) {
			const centerX = sqr.x + sqr.size / 2;
			const centerY = sqr.y + sqr.size / 2;
			const angle = Math.atan2(sqr.speedY, sqr.speedX);
			const arrowLength = sqr.size / 2;

			// Draw the line indicating direction
			ctx.strokeStyle = "green";
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(centerX, centerY);
			ctx.lineTo(centerX + arrowLength * Math.cos(angle), centerY + arrowLength * Math.sin(angle));
			ctx.stroke();

			// Draw the arrowhead
			const arrowHeadLength = 5; // Increase for a larger arrowhead
			const arrowSpread = Math.PI / 2.5; // Make the arrowhead wider (e.g., 45 degrees)

			ctx.beginPath();
			ctx.moveTo(centerX + arrowLength * Math.cos(angle), centerY + arrowLength * Math.sin(angle));
			ctx.lineTo(centerX + (arrowLength - arrowHeadLength) * Math.cos(angle + arrowSpread), 
					   centerY + (arrowLength - arrowHeadLength) * Math.sin(angle + arrowSpread));
			ctx.lineTo(centerX + (arrowLength - arrowHeadLength) * Math.cos(angle - arrowSpread), 
					   centerY + (arrowLength - arrowHeadLength) * Math.sin(angle - arrowSpread));
			ctx.closePath();
			ctx.fillStyle = "green";
			ctx.fill();
		  }
		});
	  
		// Draw shield rings around the player based on player.shieldCount.
		// There are up to 3 rings; each ring gets "activated" at an odd count and "lighter" at the next even count.
		const centerX = player.x + player.size / 2;
		const centerY = player.y + player.size / 2;
		for (let i = 0; i < 3; i++) {
		  // The i-th ring is activated if shieldCount is at least (i*2 + 1)
		  if (player.shieldCount >= i * 2 + 1) {
			// If shieldCount is at least (i*2 + 2), the ring is drawn in dark purple; otherwise, in normal purple.
			let ringColor = (player.shieldCount >= i * 2 + 2) ? PURPLE_COLOUR : DARK_PURPLE;
			ctx.strokeStyle = ringColor;
			ctx.lineWidth = shieldThickness;  // Use your defined shieldThickness
			ctx.beginPath();
			ctx.arc(centerX, centerY, desiredRadii[i], 0, Math.PI * 2);
			ctx.stroke();
		  }
		}
      
      // Draw boss fight elements if active.
      if (bossFight) {
        // Draw bossMoat: a 20px red border around the canvas.
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, canvas.width, 20); // Top border
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20); // Bottom border
        ctx.fillRect(0, 0, 20, canvas.height); // Left border
        ctx.fillRect(canvas.width - 20, 0, 20, canvas.height); // Right border
  
        // Draw Boss.
        if (boss) {
			drawBoss(boss.x + boss.size / 2, boss.y + boss.size / 2, boss.size, boss.rotation, boss.color);
			}		
		}
	
       	// Draw bossShots and triShots.
		drawBossShots();
		drawTriShots();
		
        // Draw bossRocks.
        bossRocks.forEach(br => {
          ctx.fillStyle = br.color;
          drawrock(br);
        });	
    }
    
	let lastUpdateTime = 0;
	function gameLoop(timestamp) {
	  if (!lastUpdateTime) {
		lastUpdateTime = timestamp;
	  }
	  const delta = timestamp - lastUpdateTime;
	  
	  // Only update if at least ~16.67ms have passed (about 60fps)
	  if (delta >= 15) {
		update();
		draw();
		updateHUD();
		lastUpdateTime = timestamp;
	  }
	  
	  // Draw joystick overlay
	  if (touchActive) {
		drawJoystickOverlay();
	  }	  
	  requestAnimationFrame(gameLoop);
	}
    
	// Restart Game function
    function restartGame() {
      hudorbIndicator.style.backgroundColor = "grey";
      let pos = getValidSpawnPosition(player.size);
      player = { x: pos.x, y: pos.y, size: 20, speed: basePlayerSpeed, lives: 1, level: 1, shieldCount: 0 };
      progress = 0;
	  setPause(true, "blue", "Level " + player.level);
      gameOver = false;
      gameOverPrompted = false;
      tryAgainAvailable = false;
      orbActive = true;
      controlsLocked = true;
      setTimeout(() => { controlsLocked = false; }, 1000);
      // Reset shield-related variables.
      shieldRings = [];
      shieldAwardedForCurrentTempPurple = false;
      purplePower = false;
      // Reset boss fight state if any.
      bossFight = false;
      boss = null;
      bossRocks = [];
      spawnmud();
	  recalcRockValues();
      spawnrocks();
	  spawnsqrs();
      spawnorb();
	  // Reset boss fight state if any.
	  bossFight = false;
	  boss = null;
	  bossRocks = [];
	  bossShots = [];
	  shop = false;
      triGreen.active = shop;
	  triGreen.shields = [true, true, true, true];
	  shopsPatronised = {};
	  currentShopId = null; 
    }
	
	// Clear Local Data
	function resetGameData() {
		localStorage.clear();
		location.reload(); // Refresh the game to apply changes
	}
    
    restartGame();
    gameLoop();
    
    let keys = {};
	document.addEventListener("keydown", (event) => {
	  // If in a boss fight and waiting for input, allow movement keys to unpause
	  if (
		bossFight &&
		gamePaused &&
		["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(event.key) &&
		!event.repeat
	  ) {
		resumeGame();
	  } else if (controlsLocked) {
		return;
	  }

	  keys[event.key] = true;

	  const leftKey = keys["ArrowLeft"] || keys["a"];
	  const rightKey = keys["ArrowRight"] || keys["d"];

		// Manual Pause after holding keys for 1 second
		if (!gamePaused && leftKey && rightKey && !boss) {
		  if (!manualPauseTimer) {
			manualPauseTimer = setTimeout(() => {
			  setPause(true, "blue", "Paused");
			  manualPauseTimer = null; // Reset timer after firing
			}, 1000);
		  }
		} else {
		  // If keys are released before the timeout, clear the timer.
		  if (manualPauseTimer) {
			clearTimeout(manualPauseTimer);
			manualPauseTimer = null;
		  }
		}

	  if (gamePaused && (keys["ArrowUp"] || keys["w"] || keys["ArrowDown"] || keys["s"] || leftKey || rightKey)) {
		if (!manualPauseLocked) {
		  resumeGame();
		}
	  }

	  if (gameOver && tryAgainAvailable) {
		if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(event.key)) {
		  restartGame();
		  return;
		}
	  }

	  // Input code detection
	  // 0000 - Clear Local
	  // 2001 - Suicide
	  // 2505 - Clyde Walls
	  // 3712 - Sophie Pink
	  if ("0123456789".includes(event.key)) {
		inputCodeBuffer += event.key;
		// Keep only the last 4 digits
		if (inputCodeBuffer.length > 4) {
		  inputCodeBuffer = inputCodeBuffer.slice(-4);
		}
		if (inputCodeBuffer === "0000") {
			highScore = 1;
			hasTriGreen = 0;
			hasTriBlue = 0;
			hasTriPurple = 0;			
		    resetGameData();
		    console.log("Cleared local data");
		}
		if (inputCodeBuffer === "2001") {
			player.lives = 0;
		    console.log("That looked like it hurt...");
		}
		if (inputCodeBuffer === "2505") {
		    inputNoWrap = true;
		    if (debug) { console.log("Player wrapping disabled!");}
		}
		if (inputCodeBuffer === "3712") {
		    playerIsPink = true;
		    if (debug) { console.log("You are now pink!");}
		}
	  }
		//Debug Key
		document.addEventListener("keydown", (e) => {
		  if (debug && e.key === "End") {
		    // ==========================================
			openShop();
			progress = 4;

			//initiateBossFight();
		    // ==========================================
			console.log("Debug key pressed");
		  }
		});

		// K Code
		const kCode = ["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","b","a"];
		let kPosition = 0;
		document.addEventListener("keydown", (e) => {
		  if (e.key === kCode[kPosition]) {
			kPosition++;
			if (kPosition === kCode.length) {
			  if (debug) { console.log("K code entered!");}
			  // Reset if you want to allow re-entry.
			  kPosition = 0;
			}
		  } else {
			kPosition = 0;
		  }
		});

	});

    document.addEventListener("keyup", (event) => {
      delete keys[event.key];
      if ((event.key === "ArrowLeft" || event.key === "a" || event.key === "ArrowRight" || event.key === "d") && manualPauseTimer) {
        clearTimeout(manualPauseTimer);
        manualPauseTimer = null;
      }
      if (
        !keys["ArrowLeft"] && !keys["ArrowRight"] && !keys["ArrowUp"] && !keys["ArrowDown"] &&
        !keys["w"] && !keys["a"] && !keys["s"] && !keys["d"]
      ) {
        manualPauseLocked = false;
      }
    });
    
	// ========== Mouse Stuff - Debug Tools ==========

	let leftClickTimer = null;
	let leftClickStartTime = 0;
	let middleClickTimer = null;
	let middleClickStartTime = 0;
	
	canvas.addEventListener('mousedown', function(event) {
		let rect = canvas.getBoundingClientRect();
		let mouseX = event.clientX - rect.left;
		let mouseY = event.clientY - rect.top;
	  
		// ========== Left Click Stuff ==========
		if (event.button === 0 && debug) {
		  // If left click is on the player, start the long click timer.
		  if (mouseX >= player.x && mouseX <= player.x + player.size &&
			  mouseY >= player.y && mouseY <= player.y + player.size) {
			leftClickStartTime = Date.now();
			leftClickTimer = setTimeout(() => {
			  player.lives = 999;
			  if (debug) { console.log("Lives set to 999");}
			  leftClickTimer = null;
			}, 1000);
			event.preventDefault();
			return;
		  }
		  // Debug-only: Check if orb is clicked to trigger debugSkipLevels(1)
		  if (orbActive && debug) {
			let orbCenterX = orb.x + orb.size / 2;
			let orbCenterY = orb.y + orb.size / 2;
			let dx = mouseX - orbCenterX;
			let dy = mouseY - orbCenterY;
			if (Math.sqrt(dx * dx + dy * dy) <= orb.size / 2) {
			if (debug) {
				const index = Math.floor(player.level / 10);
				console.log("Lv",player.level,"Skipped - (fr",rockValues[index],")");
			}
			  debugSkipLevels(1);
			  event.preventDefault();
			  return;
			}
		  }
		  // Debug-only: Process clicks on sqr squares (sqrs)
		  if (debug) {
			let sqrFound = false;
			for (let i = 0; i < sqrs.length; i++) {
			  let sqr = sqrs[i];
			  if (mouseX >= sqr.x && mouseX <= sqr.x + sqr.size &&
				  mouseY >= sqr.y && mouseY <= sqr.y + sqr.size) {
				sqrFound = true;
				if (debug) { console.log("Evolved sqr");}
				if        (sqr.color === "yellow") { sqr.color = "orange";
				} else if (sqr.color === "orange") { sqr.color = "red";
				} else if (sqr.color === "red"   ) {
					if (debug) { console.log("Removed sqr");}
				    sqrs.splice(i, 1);
				}
				break;
			  }
			}
		  }
		  event.preventDefault();
		  // ========== Right Click Stuff ==========
		} else if (event.button === 2 && debug) { 
				if (orbActive && debug) {
				  let orbCenterX = orb.x + orb.size / 2;
				  let orbCenterY = orb.y + orb.size / 2;
				  let dx = mouseX - orbCenterX;
				  let dy = mouseY - orbCenterY;
				  if (Math.sqrt(dx * dx + dy * dy) <= orb.size / 2) {
					debugSkipLevels(10);
					if (debug) {
						const index = Math.floor(player.level / 10);
						console.log("Jumnped to Lv", player.level, "- (fr",rockValues[index],")");
					}
					event.preventDefault();
					return;
				  }
				}
				if (debug && mouseX >= player.x && mouseX <= player.x + player.size &&
					mouseY >= player.y && mouseY <= player.y + player.size) {
				  if (debug) { console.log("Life removed");}
				  player.lives--; 
				  event.preventDefault();
				  return;
				}
				// Debug-only: Process rock removal, mud removal, and sqr modifications.
				if (debug) {
				  for (let i = 0; i < rocks.length; i++) {
					let rock = rocks[i];
					if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						mouseY >= rock.y && mouseY <= rock.y + rock.height) {
					  if (debug) { console.log("Removed rock");}
					  rocks.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < bossRocks.length; i++) {
					let rock = bossRocks[i];
					if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						mouseY >= rock.y && mouseY <= rock.y + rock.height) {
					  if (debug) { console.log("Removed boss rock");}
					  bossRocks.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < mud.length; i++) {
					let m = mud[i];
					if (mouseX >= m.x && mouseX <= m.x + m.width &&
						mouseY >= m.y && mouseY <= m.y + m.height) {
					  if (debug) { console.log("Removed mud");}
					  mud.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < sqrs.length; i++) {
					let sqr = sqrs[i];
					if (mouseX >= sqr.x && mouseX <= sqr.x + sqr.size &&
						mouseY >= sqr.y && mouseY <= sqr.y + sqr.size) {
					  if (debug) { console.log("Devolved sqr");}
					  if        (sqr.color === "red"   ) { sqr.color = "orange";
					  } else if (sqr.color === "orange") { sqr.color = "yellow";
					  } else if (sqr.color === "yellow") {
						if (debug) { console.log("Removed sqr");}
						sqrs.splice(i, 1);
					  }
					  event.preventDefault();
					  return;
					}
				  }
				  // Debug-only: If no sqr was clicked, spawn a new sqr.
				  if (debug) { console.log("Spawned an sqr");}
				  let angle = getRandomAngle();
				  let newsqr = {
					x: mouseX - YELLOW_SIZE / 2,
					y: mouseY - YELLOW_SIZE / 2,
					size: YELLOW_SIZE,
					color: "yellow",
					speedX: Math.cos(angle) * YELLOW_SPEED,
					speedY: Math.sin(angle) * YELLOW_SPEED
				  };
				  sqrs.push(newsqr);
				  event.preventDefault();
				}
						
				// ========== Middle Click Stuff ==========
				} else if (event.button === 1) {
				  if (!debug) { return }; // Only execute debug features when debug === 1.
					// If middle click is on the player, start a long click timer.
					if (mouseX >= player.x && mouseX <= player.x + player.size &&
						mouseY >= player.y && mouseY <= player.y + player.size) {
					  middleClickStartTime = Date.now();
					  middleClickTimer = setTimeout(() => {
						player.shieldCount = 999;
						if (debug) { console.log("Shields to full! - Shield count: " + player.shieldCount);}
						middleClickTimer = null;
					  }, 1000);
					  event.preventDefault();
					  return;
					}
					
					// Debug Middle Click: Orb Cycler.
					if (!orbActive) return;

					const orbCenterX = orb.x + orb.size / 2;
					const orbCenterY = orb.y + orb.size / 2;
					const dx = mouseX - orbCenterX;
					const dy = mouseY - orbCenterY;
					const radius = orb.size / 2;

					if (dx * dx + dy * dy <= radius * radius) {
					  if (debug) { console.log("Cycled orb colour");}
					  
					  // Define the cycle states:
					  const cycleStates = [
						{ color: "green", shape: "circle" },
						{ color: "blue", shape: "circle" },
						{ color: PURPLE_COLOUR, shape: "circle" },
						{ color: ICE_COLOUR, shape: "circle" },
						{ color: "green", shape: "hex" },
						{ color: "blue", shape: "hex" }
					  ];
					  
					  // Determine the current state index.
					  const currentIndex = cycleStates.findIndex(
						state => state.color === orb.color && state.shape === orb.shape
					  );
					  
					  // If not found, default to the first state; otherwise, move to the next state.
					  const nextState =
						currentIndex === -1
						  ? cycleStates[0]
						  : cycleStates[(currentIndex + 1) % cycleStates.length];
						  
					  orb.color = nextState.color;
					  orb.shape = nextState.shape;
					  
					  event.preventDefault();
					  return;
					}
					// Debug-only: Process middle click on sqr squares (sqrs) to remove all sqrs.
					for (let i = 0; i < sqrs.length; i++) {
					  let sqr = sqrs[i];
					  if (mouseX >= sqr.x && mouseX <= sqr.x + sqr.size &&
						  mouseY >= sqr.y && mouseY <= sqr.y + sqr.size) {
						if (debug) { console.log("Removed all sqrs");}
						sqrs = [];
						event.preventDefault();
						return;
					  }
					}
					// If middle click is on a rock or boss rock, remove all rocks and boss rocks.
					let hitRock = false;
					for (let i = 0; i < rocks.length; i++) {
					    let rock = rocks[i];
					    if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						    mouseY >= rock.y && mouseY <= rock.y + rock.height) {
						    hitRock = true;
						    break;
					    }
					}
					for (let i = 0; i < bossRocks.length; i++) { // This isn't working for unknown reason
						let bossRock = bossRocks[i];
						if (mouseX >= bossRock.x && mouseX <= bossRock.x + bossRock.width &&
							mouseY >= bossRock.y && mouseY <= bossRock.y + bossRock.height) {
						    hitRock = true;
						    break;
						}
					}
					
					if (hitRock) {
					  if (debug) { console.log("Removed all rocks");}
					  rocks = [];
					  bossRocks = [];
					  event.preventDefault();
					  return;
					}
				  event.preventDefault();
				}
		});
		// End of Main Debug Click Features
		
		// Debug: Boss click
		function evolveBoss() {
			if (!debug) return;
			if (!boss || !bossFight) return; // No boss to evolve

			if (bossState === "yellow") {
				bossRocks = [];
				if (debug) { console.log("Boss evolved to orange!");}
			} else if (bossState === "orange") {
				bossShots = [];
				isSpiralActive = true;
				if (debug) { console.log("Boss evolved to red!");}
			} else if (bossState === "red") {
			    isSpiralActive = false;
				bossShots = [];
				triShots = [];
				boss = null;
				triPurple.active = true;
				triShotShieldCount = 0;
				if (debug) { console.log("Boss defeated!");}
				
				messageOverlay.textContent = "";
			}
		}

		canvas.addEventListener("click", function(event) {
			if (!boss || !bossFight) return; // Do nothing if no boss is present

			let rect = canvas.getBoundingClientRect();
			let mouseX = event.clientX - rect.left;
			let mouseY = event.clientY - rect.top;

			// Check if the click is inside the boss
			if (
				mouseX >= boss.x &&
				mouseX <= boss.x + boss.size &&
				mouseY >= boss.y &&
				mouseY <= boss.y + boss.size
			) {
				evolveBoss();
			}
		});
	
	canvas.addEventListener("mouseup", function(event) {
	  if (event.button === 0 && debug) {
		if (leftClickTimer) {
		  clearTimeout(leftClickTimer);
		  leftClickTimer = null;
		  player.lives = Math.min(player.lives + 1, 999);
		  if (debug) { console.log("Life added");}
		  event.preventDefault();
		}
	  }
	});
	
	canvas.addEventListener("mouseup", function(event) {
	  if (event.button === 1 && debug) {
		if (middleClickTimer) {
		  clearTimeout(middleClickTimer);
		  middleClickTimer = null;
		  player.shieldCount++;
		  if (debug) { console.log("Shields up! - Shield count: " + player.shieldCount);}
		  event.preventDefault();
		}
	  }
	});
    
	function debugSkipLevels(levelsToSkip) {
	  if (levelsToSkip === 10) {
		// Calculate the next multiple of 10.
		// (player.level + 1) ensures that if you're exactly on a multiple (e.g., 10),
		// you will jump to the next one (20).
		player.level = Math.ceil((player.level + 1) / 10) * 10;
	  } else {
		player.level += levelsToSkip;
	  }
	  clearLevel();
	  spawnLevel();
	  setPause(true, "green", "Skip to level " + player.level);
	}
	triHud(); // Ensure the HUD updates with saved values
  </script>
</body>
</html>
