<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=800, initial-scale=1.0" />
  <title>A Game of Squares</title>
  <style>
    body {
      margin: 0;
      background-color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    /* Title Styles */
    #title {
      text-align: center;
      margin-top: 20px;
      margin-bottom: 10px;
      width: 800px;
    }
    #titleTop {
      color: grey;
      font-size: 24px;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    #titleBottom {
      color: white;
      font-size: 48px;
      font-weight: bold;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    /* HUD Container */
    #hudContainer {
      width: 800px;
      background-color: #333;
      border-radius: 8px;
      padding: 5px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: Arial, sans-serif;
	  position: relative;
    }
	#hudTriangles {
	  position: absolute;
	  right: 180px;  /* adjust this value as needed so it sits nicely between Level and High Score */
	  top: 50%;
	  transform: translateY(-50%);
	  display: flex;
	  gap: 10px;  /* gap between triangles */
	}
	.triangle.green {
	  box-shadow: none;
	}
	.triangle.blue {
	  box-shadow: none;
	}
	.triangle.purple {
	  box-shadow: none;
	}	

	/* Creating an equilateral triangle pointing upward. */
	.triangle {
	  width: 41px; /* approximates the base of an equilateral triangle with 35px height */
	  height: 35px;
	  background-color: #202020;
	  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
	  box-shadow: inset -10px -5px 5px rgba(0, 0, 0, 0.5); /* adjust shadow as needed */
	}
    /* HUD elements */
    .hud-label {
      color: grey;
      font-size: 20px;
    }
    /* Lives: Fixed blue circle that stays the same size */
    #hudLife {
      background-color: blue;
      color: white;
      font-size: 20px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 5px;
    }
    /* Center HUD */
    #hudLevel {
      color: white;
      font-size: 26px;
      font-weight: bold;
      margin: 0 2px 0 0;
    }
    /* Level progression */
    #hudLevelProg {
      background-color: green;
      color: white;
      font-size: 16px;
      font-weight: bold;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      text-align: center;
      line-height: 40px;
      margin-left: 2px;
      display: inline-block;
      position: relative;
    }
    /* The tiny indicator inside the green circle */
    #hudorbIndicator {
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background-color: grey;
      border-radius: 50%;
    }
    /* High Score: fixed width for the number */
    #hudHighScore {
      color: white;
      font-size: 20px;
      font-weight: bold;
      width: 30px;
      text-align: center;
      display: inline-block;
      margin-left: 1px;
    }
    /* Containers for left, center, and right parts */
    #hudLeft, #hudCenter, #hudRight {
      display: flex;
      align-items: center;
    }
    /* Game container and canvas */
    #gameContainer {
      position: relative;
      width: 800px;
      height: 600px;
      margin-top: 10px;
    }
    canvas {
      background-color: #111;
      display: block;
    }
    /* Overlay for in-canvas messages */
    #messageOverlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: Arial, sans-serif;
      font-size: 48px;
      font-weight: bold;
      z-index: 5;
      pointer-events: none;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      text-align: center;
    }
	#bottomBar {
	  width: 800px;
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  font-family: Arial, sans-serif;
	  font-size: 12px;
	  margin-top: 2px;
	}

	#debugModeIndicator {
	  text-align: left;
	  color: blue;
	}

	#devVersion {
	  text-align: right;
	  color: #2a2a2a;
	}
	.glow {
	  animation: glowEffect 1s infinite alternate;
	}

	@keyframes glowEffect {
	  from {
		filter: brightness(1);
	  }
	  to {
		filter: brightness(1.5);
	  }
	}
  </style>
</head>
<body>
  <div id="title">
    <div id="titleTop">Dave Longhurst presents</div>
    <div id="titleBottom">A Game of Squares</div>
  </div>
	<div id="hudContainer">
	  <div id="hudLeft">
		<span class="hud-label">Lives:</span>
		<span id="hudLife">1</span>
	  </div>
	  <div id="hudCenter">
		<span id="hudLevel">Level 1</span>
		<span id="hudLevelProg">0/5
		  <div id="hudorbIndicator"></div>
		</span>
	  </div>
	  <div id="hudTriangles">
		<div class="triangle"></div>
		<div class="triangle"></div>
		<div class="triangle"></div>
	  </div>
	  <div id="hudRight">
		<span class="hud-label">High Score:</span>
		<span id="hudHighScore">1</span>
	  </div>
	</div>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="messageOverlay"></div>
  </div>
  <!-- Debug Mode Indicator & Version Number -->
  <div id="bottomBar">
    <div id="debugModeIndicator"></div>
    <div id="devVersion">v1.4.4-touch</div>
  </div>
  <script>
    let debug = 0;
	if (debug) {
	  document.getElementById("debugModeIndicator").textContent = "Debug Mode";
	} else {
	  document.getElementById("debugModeIndicator").textContent = "";
	}
	
	// Click HUD triangles
	if (debug) {
	  const triangles = document.querySelectorAll("#hudTriangles .triangle");
	  if (triangles.length >= 3) {
		// Left triangle toggles hasTriGreen
		triangles[0].addEventListener("click", () => {
		  hasTriGreen = hasTriGreen === 1 ? 0 : 1;
		  triHud();
		});
		// Middle triangle toggles hasTriBlue
		triangles[1].addEventListener("click", () => {
		  hasTriBlue = hasTriBlue === 1 ? 0 : 1;
		  triHud();
		});
		// Right triangle toggles hasTriPurple
		triangles[2].addEventListener("click", () => {
		  hasTriPurple = hasTriPurple === 1 ? 0 : 1;
		  triHud();
		});
	  }
	}

	function drawTriPower() {
	  // Draw each triangle only if it's active
	  drawTriObj(triGreen, "green");
	  drawTriObj(triBlue, "blue");
	  drawTriObj(triPurple, PURPLE_COLOR);
	}

	function drawTriObj(tri, activeColor) {
	  // Only draw the triangle if it is active.
	  if (!tri.active) return;
	  
	  ctx.save();
	  // For active triangles, we fill with the active color and use no shadow.
	  ctx.shadowColor = "transparent";
	  ctx.fillStyle = activeColor;
	  
	  // Draw an upward pointing triangle.
	  // We assume tri.x and tri.y are the top-left of a square that bounds the triangle.
	  let x = tri.x;
	  let y = tri.y;
	  let width = tri.width || 41;
	  let height = tri.height || 35;
		  
	  ctx.beginPath();
	  // Mimic the HUD clip-path: polygon(50% 0%, 0% 100%, 100% 100%)
	  ctx.moveTo(x + width / 2, y);       // Top vertex at the middle of the top edge.
	  ctx.lineTo(x, y + height);          // Bottom left vertex.
	  ctx.lineTo(x + width, y + height);  // Bottom right vertex.
	  ctx.closePath();
	  ctx.fill();
	  
	  ctx.restore();
	}

	// TriGreen Collision with player
	function checkTriGreenCollision() {
	  // Only perform the check if triGreen is active.
	  if (!triGreen.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triGreen area.
	  if (player.x < triGreen.x + triangleWidth &&
		  player.x + player.size > triGreen.x &&
		  player.y < triGreen.y + triangleHeight &&
		  player.y + player.size > triGreen.y) {
		// When collision occurs, remove triGreen and set hasTriGreen.
		triGreen.active = false;
		hasTriGreen = 1;
	  }
	}
	// TriBlue Collision with player
	function checkTriBlueCollision() {
	  // Only perform the check if triBlue is active.
	  if (!triBlue.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triBlue area.
	  if (player.x < triBlue.x + triangleWidth &&
		  player.x + player.size > triBlue.x &&
		  player.y < triBlue.y + triangleHeight &&
		  player.y + player.size > triBlue.y) {
		// When collision occurs, remove triBlue and set hasTriBlue.
		triBlue.active = false;
		hasTriBlue = 1;
	  }
	}
	// Player collision with TriPurple
	function checkTriPurpleCollision() {
	  // Only perform the check if triPurple is active.
	  if (!triPurple.active) return;
	  
	  // Fixed dimensions matching the HUD triangle.
	  let triangleWidth = 41;
	  let triangleHeight = 35;
	  
	  // Simple AABB collision detection between the player and the triPurple area.
	  if (player.x < triPurple.x + triangleWidth &&
		  player.x + player.size > triPurple.x &&
		  player.y < triPurple.y + triangleHeight &&
		  player.y + player.size > triPurple.y) {
		// When collision occurs, remove triPurple and set hasTriPurple.
		triPurple.active = false;
		hasTriPurple = 1;
		
		// temp level skip stuff - probably add access to shop here
		nextLevel();
		// End temp level skip stuff
		
	  }
	}

    let highScore = 1;
	// Load saved values from localStorage (default to 0 if not found)
	highScore = localStorage.getItem("highScore") ? parseInt(localStorage.getItem("highScore")) : 1;
    let gameOverPrompted = false;
    const PURPLE_COLOR = "#7F00FF";
	const DARK_PURPLE = "#4B0082"; 
    let purpleorbUsed = false;
    
    // Use fixed shield rings (up to 3).
    let shieldRings = [];
    // Flag to prevent awarding multiple shields in one temporary purple cycle.
    let shieldAwardedForCurrentTempPurple = false;
    // Indicates that the temporary purple effect is active.
    let purplePower = false;
    
    // Constants for shield ring drawing.
    // Desired radii: first ring = 20, second = 25, third = 30.
    const desiredRadii = [20, 25, 30];
    const shieldThickness = 3;  // Stroke width is 3 pixels.
    
    // Recalculate each shield ring's radius based on its index.
    function recalcShieldRadii() {
      for (let i = 0; i < shieldRings.length; i++) {
        shieldRings[i].ringRadius = desiredRadii[i];
      }
    }
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
	
	// Touch variables
	let touchStartX = null;
	let touchStartY = null;
	let touchActive = false;
	let touchDx = 0;
	let touchDy = 0;

	// Touch event listeners
	canvas.addEventListener('touchstart', function(e) {
	  e.preventDefault(); // Prevent scrolling
	  // Unpause game if needed (or any additional logic)
	  if (paused || levelPaused || bossWaitForInput) {
		  paused = false;
		  levelPaused = false;
		  bossWaitForInput = false;
		  manualPause = false;
		  controlsLocked = false;
		  messageOverlay.textContent = "";
	  }
	  
		  if (e.touches.length > 0) {
			  touchActive = true;
			  if (touchStartX === null && touchStartY === null) {
				  touchStartX = e.touches[0].clientX;
				  touchStartY = e.touches[0].clientY;
			  }
			  touchDx = 0;
			  touchDy = 0;
		  }
		}, false);

	canvas.addEventListener('touchmove', function(e) {
	  e.preventDefault(); // Prevent scrolling
	  if (touchActive && e.touches.length > 0) {
		  let currentX = e.touches[0].clientX;
		  let currentY = e.touches[0].clientY;
		  touchDx = currentX - touchStartX;
		  touchDy = currentY - touchStartY;
	  }
	}, false);

	canvas.addEventListener('touchend', function(e) {
	  e.preventDefault();
	  touchActive = false;
	  touchStartX = null; // Reset initial touch point for next touch event
	  touchStartY = null;
	  touchDx = 0;
	  touchDy = 0;
	}, false);
	
    canvas.addEventListener('contextmenu', function(event) {
      event.preventDefault();
    });
    const messageOverlay = document.getElementById("messageOverlay");
    const hudLife = document.getElementById("hudLife");
    const hudLevelElem = document.getElementById("hudLevel");
    const hudLevelProg = document.getElementById("hudLevelProg");
    const hudorbIndicator = document.getElementById("hudorbIndicator");
    const hudHighScore = document.getElementById("hudHighScore");
    const zoneSize = 250;
    let tryAgainAvailable = false;
    
    let orbActive = true;
    let manualPause = false;
    let manualPauseTimer = null;
    let manualPauseLocked = false;
    let controlsLocked = false;
	let playerIsPink = false;
	let cheatNoWrap = false;
	let cheatCodeBuffer = ""; //0000-Clear 3712-Pink 2505-NoWrap
	let bossRotationSpeed = 0.04;
	let bossFail = 0;
	
	let loggingInterval = null;
	let flashInterval = null;
	
	// Trail Effect
	let playerTrail = [];
	const TRAIL_LENGTH = 20;  
	// Green Triangle Glow
	let triGlowEnabled = false;
	
	let hasTriGreen = 0;
	let hasTriBlue = 0;
	let hasTriPurple = 0;
	// Load saved values from localStorage (default to 0 if not found)
	hasTriPurple = localStorage.getItem("hasTriPurple") ? parseInt(localStorage.getItem("hasTriPurple")) : 0;
	hasTriBlue = localStorage.getItem("hasTriBlue") ? parseInt(localStorage.getItem("hasTriBlue")) : 0;
	hasTriGreen = localStorage.getItem("hasTriGreen") ? parseInt(localStorage.getItem("hasTriGreen")) : 0;
	let triGreen = {
	  active: false,  // Indicates if the triGreen is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	let triBlue = {
	  active: false,  // Indicates if the triBlue is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	let triPurple = {
	  active: false,  // Indicates if the triPurple is currently active
	  x: canvas.width / 2 - 20.5,  // Adjusted for a width of 41
	  y: canvas.height / 2 - 17.5, // Adjusted for a height of 35
	  size: 40      // Adjust this size as needed
	};
	
	function triHud() {
	  // Get the three triangle elements in order: left, middle, right.
	  let triangles = document.querySelectorAll("#hudTriangles .triangle");
	  if (triangles.length < 3) return; // Ensure all three exist

	  // Left triangle (green)
	  if (hasTriGreen === 1) {
		triangles[0].style.backgroundColor = "green";
		triangles[0].classList.add("green");
		triangles[0].style.boxShadow = "none";
		localStorage.setItem("hasTriGreen", hasTriPurple); // Save to localStorage
	  } else {
		triangles[0].style.backgroundColor = "#202020";
		triangles[0].classList.remove("green");
		triangles[0].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
	  }

	  // Middle triangle (blue)
	  if (hasTriBlue === 1) {
		triangles[1].style.backgroundColor = "blue";
		triangles[1].classList.add("blue");
		triangles[1].style.boxShadow = "none";
		  localStorage.setItem("hasTriBlue", hasTriPurple); // Save to localStorage
	  } else {
		triangles[1].style.backgroundColor = "#202020";
		triangles[1].classList.remove("blue");
		triangles[1].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
	  }

		// Right triangle (purple)
		if (hasTriPurple === 1) {
		  triangles[2].style.backgroundColor = PURPLE_COLOR;
		  triangles[2].classList.add("purple");
		  triangles[2].style.boxShadow = "none";
		  localStorage.setItem("hasTriPurple", hasTriPurple); // Save to localStorage
		  if (player.shieldCount >= 1) {
			triangles[2].classList.add("glow");
		  } else {
			triangles[2].classList.remove("glow");
		  }
		} else {
		  triangles[2].style.backgroundColor = "#202020";
		  triangles[2].classList.remove("purple");
		  triangles[2].classList.remove("glow");
		  triangles[2].style.boxShadow = "inset -10px -5px 5px rgba(0, 0, 0, 0.5)";
		}
	}
		
	// Boss state variables and triShot counter
	let bossState = "yellow"; // Possible states: "yellow", "orange", "red"
	let triShotShieldCount = 0; // Counts the number of triShot that have hit a Shield
	let triShots = [];  // Array for triShot projectiles

	// updateBossState, colour and rotation
	function updateBossState() {
	if (boss){
		if (bossState === "yellow") { boss.color = "yellow", bossRotationSpeed = 0.03;}
		if (bossState === "orange") { boss.color = "orange", bossRotationSpeed = 0.06;}
		if (bossState === "red") { boss.color = "red", bossRotationSpeed = 0.09;}
	}
		
		if (bossState === "yellow" && !bossFail) {
		    bossShots = []; // Delete all existing boss shots
			bossState = "orange";
		}
		if (bossState === "orange") {
			setTimeout(() => {
			fireSpiral() // Oooh pretty spiral
			}, 3000);    // How long before the Spiral come
			setTimeout(() => {
				if (bossState === "orange") {
					bossShots = []; // Delete all existing boss shots
					fireTriShots(); // Fires two triShots in opposite random directions
					bossState = "red"; // Change boss state to red
				}
			}, 18000); // How long before the triShots come
		}
	}

	// Fires two triShots at opposite directions
	function fireTriShots() {
	if (triShots.length > 0) return; // Don't fire if they exist.
		if (bossState === "orange") {
						
			// Calculate the vector from the boss to the player
			let dx = (player.x + player.size / 2) - (boss.x + boss.size / 2);
			let dy = (player.y + player.size / 2) - (boss.y + boss.size / 2);

			// Compute perpendicular vectors (90-degree rotation)
			let angle1 = Math.atan2(dy, dx) + Math.PI / 2;  // 90 degrees counterclockwise
			let angle2 = Math.atan2(dy, dx) - Math.PI / 2;  // 90 degrees clockwise

			// Spawn the two triShots moving perpendicularly
			spawnTriShot(angle1);
			spawnTriShot(angle2);
			bossState = "red";
		}
	}
	// Fire spiral
	let isSpiralActive = false;
	let hasSpiralFired = false;

	function fireSpiral() {
	  if (hasSpiralFired || isSpiralActive || !boss || !bossFight || paused) return;
	  hasSpiralFired = true;  // Mark the spiral as fired for this boss fight
	  isSpiralActive = true;
	  let spiralStartTime = Date.now(); // Record start time
	  let spiralInitialLives = player.lives; // Store player's lives at the start
	  let bossCenterX = boss.x + boss.size / 2;
	  let bossCenterY = boss.y + boss.size / 2;
	  let initialAngleDeg = -90; // -90° is straight upward.
	  let totalShots = 11400; // Duration of Spiral
	  let currentShot = 0;
	  let spiralSpeed = 0.75; // How tight the Spiral is
	  let spiralDelay = 20;  // How slow the Spiral circles
	  
	  // Randomize spin direction: +1 for clockwise, -1 for counterclockwise.
	  let spinDirection = Math.random() < 0.5 ? 1 : -1;
	  
	  function shootNext() {
		// Stop the spiral
		if (Date.now() - spiralStartTime >= totalShots || currentShot >= totalShots || paused || gameOver || player.lives < spiralInitialLives) {
		  isSpiralActive = false;
		  return;
		}
		
		// Calculate the angle in degrees and convert to radians.
		let angleDeg = initialAngleDeg + (currentShot * 2 * spinDirection);
		let angleRad = angleDeg * Math.PI / 180;
		
		// Fire a normal orange shot ("single" style) at this angle with the given speed.
		fireBossShotOrange("single", bossCenterX, bossCenterY, angleRad, spiralSpeed);
		
		currentShot++;
		setTimeout(shootNext, spiralDelay);
	  }
	  
	  shootNext();
	}

	
    const YELLOW_SPEED = 1, ORANGE_SPEED = 2, RED_SPEED = 4;
    const YELLOW_SIZE = 20, ORANGE_SIZE = 25, RED_SIZE = 30;
    
    const safeMargin = 30;
    function isTooClose(a, b, margin) {
      return (
        a.x < b.x + b.size + margin &&
        a.x + a.size > b.x - margin &&
        a.y < b.y + b.size + margin &&
        a.y + a.size > b.y - margin
      );
    }
    function getValidSpawnPosition(entitySize, existingEntities = []) {
      let x, y, valid = false;
      let candidate = { x: 0, y: 0, size: entitySize };
      while (!valid) {
        x = Math.random() * (canvas.width - entitySize);
        y = Math.random() * (canvas.height - entitySize);
        candidate.x = x;
        candidate.y = y;
        valid = true;
        for (let ent of existingEntities) {
          if (isTooClose(candidate, ent, safeMargin)) {
            valid = false;
            break;
          }
        }
      }
      return { x, y };
    }
    // New function for boss fight respawn/spawn positioning.
    function getValidBossFightSpawnPosition(entitySize, obstacles) {
      let x, y, valid = false;
      let candidate;
      while (!valid) {
        // Ensure the spawn is within the canvas excluding the 20px moat border.
        x = 20 + Math.random() * (canvas.width - entitySize - 40);
        y = 20 + Math.random() * (canvas.height - entitySize - 40);
        candidate = { x: x, y: y, size: entitySize };
        valid = true;
        for (let obs of obstacles) {
          if (isTooClose(candidate, obs, safeMargin)) {
            valid = false;
            break;
          }
        }
      }
      return { x, y };
    }
    function getValidEnemySpawnPosition(entitySize) {
      let pos;
      let tries = 0;
      do {
        pos = getValidSpawnPosition(entitySize, rocks.concat(sqrs, [player]));
        tries++;
      } while (
        rocks.some(obs =>
          pos.x < obs.x + obs.size &&
          pos.x + entitySize > obs.x &&
          pos.y < obs.y + obs.size &&
          pos.y + entitySize > obs.y
        ) && tries < 1000
      );
      return pos;
    }
    function getRandomAngle() {
      return Math.random() * 2 * Math.PI;
    }
	// Helper: Clamp a value between min and max.
	function clamp(val, min, max) {
	  return Math.max(min, Math.min(max, val));
	}

	// Helper: Compute reflection vector.
	function reflectVector(vx, vy, nx, ny) {
	  let dot = vx * nx + vy * ny;
	  return { vx: vx - 2 * dot * nx, vy: vy - 2 * dot * ny };
	}

	// Helper: Collision between circle and rectangle.
	function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
	  let closestX = clamp(cx, rx, rx + rw);
	  let closestY = clamp(cy, ry, ry + rh);
	  let dx = cx - closestX;
	  let dy = cy - closestY;
	  return (dx * dx + dy * dy) < (radius * radius);
	}

	// Helper: Collision between circle and player's rectangle.
	function circlePlayerCollision(cx, cy, radius, player) {
	  return circleRectCollision(cx, cy, radius, player.x, player.y, player.size, player.size);
	}

	// Helper: Collision between circle (boss shot) and a boss rock (rectangle).
	function bossShotRockCollision(shot, rock) {
	  return circleRectCollision(shot.x, shot.y, shot.size / 2, rock.x, rock.y, rock.width, rock.height);
	}

	// Helper: Returns a random boss shot interval between 1 and 3 seconds.
	function getRandomBossShotInterval() {
	  return 1000 + Math.random() * 2000;
	}

	// Schedules next boss shot interval.
	function scheduleNextBossShot() {
	  lastBossShotTime = Date.now();
	  bossShotInterval = getRandomBossShotInterval();
	}
    
	// Player Setup
    const basePlayerSpeed = 5;
    let player = { x: 50, y: 50, size: 20, speed: basePlayerSpeed, lives: 1, level: 1, shieldCount: 0 };
    let progress = 0;
    let orb = { x: 200, y: 200, size: 20, color: "green", isHex: false };
    let sqrs = [];
    let rocks = [];
    let mud = [];
	
	let lastPlayerMoveTime = Date.now();
	let overrideNextBossShot = false;
	let lastPlayerX = player.x;
	let lastPlayerY = player.y;		
	let hasGreenArrow = 0;
	
	// boss fight globals
	let bossFight = false;
	let boss = null;
	let bossRocks = [];
	// boss shot globals
	let bossShots = [];
	let lastBossShotTime = Date.now();
	let bossShotInterval = getRandomBossShotInterval(); // initial interval
    // Flag to indicate that the boss fight is waiting for the player to move before unpausing.
    let bossWaitForInput = false;
    
    let paused = true;
    let levelPaused = true;
    let hitCooldown = false;
    let gameOver = false;
    let hasScored = false;
    
    function isIntersecting(entity, zone) {
      return !(entity.x + entity.size < zone.x ||
               entity.x > zone.x + zone.width ||
               entity.y + entity.size < zone.y ||
               entity.y > zone.y + zone.height);
    }
    function isCollidingWithrocks(entity) {
      for (let obs of rocks) {
        if (
          entity.x < obs.x + obs.width &&
          entity.x + entity.size > obs.x &&
          entity.y < obs.y + obs.height &&
          entity.y + entity.size > obs.y
        ) {
          return true;
        }
      }
      return false;
    }
	
	function isCollidingWithBossRocks(entity) {
	  for (let obs of bossRocks) {
		if (
		  entity.x < obs.x + obs.width &&
		  entity.x + entity.size > obs.x &&
		  entity.y < obs.y + obs.height &&
		  entity.y + entity.size > obs.y
		) {
		  return true;
		}
	  }
	  return false;
	}
    
    function getRandomCornerPattern() {
      let pattern;
      do {
        pattern = [
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5,
          Math.random() < 0.5
        ];
      } while (pattern.filter(c => c).length === 0 || pattern.filter(c => c).length === 4);
      return pattern;
    }
    
    function spawnmud() {
      mud = [];
      if (player.level === 1) return;
      let count = 1;
      if (player.level >= 50) count = 5;
      else if (player.level >= 40) count = 4;
      else if (player.level >= 30) count = 3;
      else if (player.level >= 20) count = 2;
      count = Math.min(count, 5);
      for (let i = 0; i < count; i++) {
        mud.push({
          x: Math.random() * (canvas.width - zoneSize),
          y: Math.random() * (canvas.height - zoneSize),
          width: zoneSize,
          height: zoneSize,
          color: "#5D3A1A"
        });
      }
    }
    
    function spawnrocks() {
      rocks = [];
      if (player.level === 1) return;
      let count = Math.floor(Math.random() * Math.floor(player.level / 2)) + 1;
      count = Math.min(count, 10);
      const shapes = [
        { width: 50, height: 50 },
        { width: 50, height: 100 },
        { width: 100, height: 50 },
        { width: 75, height: 75 }
      ];
      for (let i = 0; i < count; i++) {
        let shape = shapes[Math.floor(Math.random() * shapes.length)];
        let rockSize = Math.max(shape.width, shape.height);
        let pos = getValidSpawnPosition(rockSize, rocks.concat([player]));
        let corners = getRandomCornerPattern();
        rocks.push({ 
          x: pos.x, 
          y: pos.y, 
          width: shape.width, 
          height: shape.height, 
          size: rockSize, 
          color: "#222",
          corners: corners
        });
      }
    }
    
	function spawnsqrs() {
		sqrs = [];
		let redCount = Math.floor(player.level / 25);
		let orangeCount = Math.floor(player.level / 10);
		let yellowCount = player.level - (redCount + orangeCount);
		yellowCount = Math.min(yellowCount, 50);
		let totalEnemies = redCount + orangeCount + yellowCount;

		// Cap totalEnemies
		totalEnemies = Math.min(totalEnemies, 25);

		for (let i = 0; i < totalEnemies; i++) {
			let enemy = { x: 0, y: 0, size: YELLOW_SIZE, speedX: 0, speedY: 0, color: "yellow" };
			
			if (i < redCount) {
				enemy.color = "red";
				enemy.size = RED_SIZE;
			} else if (i < redCount + orangeCount) {
				enemy.color = "orange";
				enemy.size = ORANGE_SIZE;
			} else {
				enemy.color = "yellow";
				enemy.size = YELLOW_SIZE;
			}

			// Ensure enemy doesn't spawn inside rocks
			let validSpawn = false;
			let pos;

			while (!validSpawn) {
				pos = getValidEnemySpawnPosition(enemy.size);
				validSpawn = true; // Assume valid position

				// Check if it overlaps with any rock
				for (let rock of rocks) {
					if (
						pos.x < rock.x + rock.width &&
						pos.x + enemy.size > rock.x &&
						pos.y < rock.y + rock.height &&
						pos.y + enemy.size > rock.y
					) {
						validSpawn = false; // Invalid spawn, try again
						break;
					}
				}
			}

			enemy.x = pos.x;
			enemy.y = pos.y;
			let angle = getRandomAngle();

			if (enemy.color === "red") {
				enemy.speedX = Math.cos(angle) * RED_SPEED;
				enemy.speedY = Math.sin(angle) * RED_SPEED;
			} else if (enemy.color === "orange") {
				enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
				enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
			} else {
				enemy.speedX = Math.cos(angle) * YELLOW_SPEED;
				enemy.speedY = Math.sin(angle) * YELLOW_SPEED;
			}

			sqrs.push(enemy);
		}
	}
    
    function spawnorb() {
	  if (bossFight) return;  // Prevent orb spawning during boss fights.
      orbActive = true;
      const minDistance = 250;
      let pos, distance;
      const playerCenterX = player.x + player.size / 2;
      const playerCenterY = player.y + player.size / 2;
      do {
        pos = getValidSpawnPosition(orb.size, rocks.concat(sqrs, [player]));
        const orbCenterX = pos.x + orb.size / 2;
        const orbCenterY = pos.y + orb.size / 2;
        const dx = orbCenterX - playerCenterX;
        const dy = orbCenterY - playerCenterY;
        distance = Math.sqrt(dx * dx + dy * dy);
      } while (distance < minDistance);
      orb.x = pos.x;
      orb.y = pos.y;
      if (progress === 4) {
        if (player.level % 10 === 0) {
          // For a hex orb on every 10th level.
          orb.color = "blue"; // hex orb will be blue but drawn as a hexagon
          orb.isHex = true;
        } else {
          orb.color = "blue";
          orb.isHex = false;
        }
      } else if (progress >= 1 && progress <= 3 && !purpleorbUsed) {
        if (Math.random() < 0.1) {
          orb.color = PURPLE_COLOR;
          purpleorbUsed = true;
        } else {
          orb.color = "green";
        }
        orb.isHex = false;
      } else {
        orb.color = "green";
        orb.isHex = false;
      }
    }
	
	// Next Level setup
	function levelMessage() {
		messageOverlay.style.color = "blue";
		messageOverlay.textContent = `Level ${player.level}`;
		controlsLocked = true;
		setTimeout(() => { controlsLocked = false; }, 1000);
	}

	function clearPurplePower() {
	purplePower = false;
	hudorbIndicator.style.backgroundColor = "grey";
	playerTrail = []; 
	shieldAwardedForCurrentTempPurple = false;
	purpleorbUsed = false;
    clearTimeout(loggingInterval);
    clearInterval(flashInterval);
	}

	function clearLevel() {
		bossFight = false;
		boss = null;
		//shot.remove = true;
		bossRocks = [];
		bossShots = [];
		clearPurplePower();
		progress = 0;
	}

	function spawnLevel() {
		spawnmud();
		spawnrocks();
		spawnsqrs();
		spawnorb();
	}		

	function nextLevel() {
		player.level++;
		levelPaused = true;
		paused = true;
		levelMessage();
		clearLevel();
	spawnLevel();
	}	

	// Function to fire a boss shot (or burst) based on probabilities and limits.
	function fireBossShot() {
	  // Only fire if boss is rotating (i.e. bossFight is active and not paused)
	  if (!bossFight || paused) return;

	  // Override: if the player has been stationary, fire a large orange shot.
	  if (overrideNextBossShot) {
		let bossCenterX = boss.x + boss.size / 2;
		let bossCenterY = boss.y + boss.size / 2;
		fireBossShotOrange("large", bossCenterX, bossCenterY);
		lastPlayerMoveTime = Date.now(); // Reset timer
		overrideNextBossShot = false;  // Reset override flag for subsequent shots.
		scheduleNextBossShot();
		return;
	  }
	  
	  // Decide shot type based on probability:
	  // 50% chance for orange, 25% for red, 25% for green (or blue if progress>=9)
	  let rand = Math.random();
	  let shotType;
	  if (rand < 0.5) {
		shotType = "orange";
	  } else if (rand < 0.75) {
		shotType = "red";
	  } else {
		shotType = "green";  // will convert to blue later if progress>=9
	  }
	  
	  // Check limits:
	  // Only 1 green/blue shot allowed.
	  let greenCount = bossShots.filter(s => s.type === "green" || s.type === "blue").length;
	  if (shotType === "green" && greenCount >= 1) {
		shotType = "orange";
	  }
	  // Only 2 red shots allowed.
	  let redCount = bossShots.filter(s => s.type === "red").length;
	  if (shotType === "red" && redCount >= 2) {
		shotType = "orange";
	  }
	  
	  // For green shots, if progress >= 9 then they become blue.
	  if (shotType === "green" && progress >= 9) {
		shotType = "blue";
	  }
	  
	  // Determine firing position: assume boss center.
	  let bossCenterX = boss.x + boss.size / 2;
	  let bossCenterY = boss.y + boss.size / 2;
	  
	  // For orange shots, further choose one of four styles.
		if (shotType === "orange") {
		  let r = Math.random();
		  if (r < 0.0) {
			// Large: 0% chance (unless stationary).
			fireBossShotOrange("large", bossCenterX, bossCenterY);
		  } else if (r < 0.4) {
			// Line: next 30% chance.
			for (let i = 0; i < 5; i++) {
			  setTimeout(() => {
				fireBossShotOrange("single", bossCenterX, bossCenterY);
			  }, i * 50);
			}
		  } else if (r < 0.6) {
			// Spray: next 20% chance.
			let baseAngle = Math.atan2(player.y + player.size/2 - bossCenterY, player.x + player.size/2 - bossCenterX);
			let angles = [
			  baseAngle,
			  baseAngle + 5 * Math.PI/180,
			  baseAngle - 5 * Math.PI/180,
			  baseAngle + 10 * Math.PI/180,
			  baseAngle - 10 * Math.PI/180
			];
			angles.forEach(angle => {
			  fireBossShotOrange("single", bossCenterX, bossCenterY, angle);
			});
		  } else {
			// Single: remaining 40% chance.
			fireBossShotOrange("single", bossCenterX, bossCenterY);
		  }
		}
	  
	  else if (shotType === "red") {
		// Fire a red shot with a random ±30° offset relative to the player.
		let baseAngle = Math.atan2(player.y + player.size/2 - bossCenterY, player.x + player.size/2 - bossCenterX);
		let offset = (Math.random() < 0.5 ? -30 : 30) * Math.PI/180;
		let angle = baseAngle + offset;
		let speed = 4.5;
		let shot = {
		  type: "red",
		  x: bossCenterX,
		  y: bossCenterY,
		  vx: Math.cos(angle) * speed,
		  vy: Math.sin(angle) * speed,
		  size: 10, // boss shot diameter (half the orb)
		  bounceCount: 0,
		  firedTime: Date.now(), // for tracking phase
		  homing: false  // will switch to homing after 0.5-1 sec
		};
		// Random straight travel duration between 500 and 1000 ms.
		shot.straightDuration = 500 + Math.random() * 500;
		bossShots.push(shot);
	  }
	  else if (shotType === "green" || shotType === "blue") {
		// Fire a green/blue shot at speed 3 in a random direction.
		let angle = getRandomAngle();
		let shot = {
		  type: (shotType === "green" ? "green" : "blue"),
		  x: bossCenterX,
		  y: bossCenterY,
		  vx: Math.cos(angle) * 3,
		  vy: Math.sin(angle) * 3,
		  size: 10,
		  bounceCount: 0
		};
		bossShots.push(shot);
	  }
	  scheduleNextBossShot();
	}

	// Creates a triShot projectile
	function spawnTriShot(angle) {
		let triShot = {
			x: boss.x + boss.size / 2,  // Start from boss center
			y: boss.y + boss.size / 2,
			vx: Math.cos(angle) * 2,    // Initial speed of 2
			vy: Math.sin(angle) * 2,
			homing: false,
			spawnedAt: Date.now(),
			size: 10,  // You can adjust size as needed
			type: "triShot" // Marks it for collision detection
		};
		triShots.push(triShot);
	}

	// Updates triShots each frame
	function updateTriShots() {
		triShots.forEach((triShot, index) => {
			// Store previous positions for the trail
			if (!triShot.trail) triShot.trail = [];
			triShot.trail.push({ x: triShot.x, y: triShot.y });
			if (triShot.trail.length > 20) triShot.trail.shift();

			// Check for collision with other triShots
			triShots.forEach((otherShot, otherIndex) => {
				if (index !== otherIndex && checkCollision(triShot, otherShot)) {
					handleTriShotCollision(triShot, otherShot);
				}
			});

			// If bouncing, move in opposite directions for 2 seconds
			if (triShot.bouncing) {
				if (Date.now() - triShot.bounceStart < 2000) {
					triShot.x += triShot.vx;
					triShot.y += triShot.vy;
					return; // Prevents homing from overriding bounce movement
				} else {
					// After 2 seconds, refocus on player
					triShot.bouncing = false;
				}
			}

			// Homing logic should only apply if the shot is NOT bouncing
			if (!triShot.bouncing && Date.now() - triShot.spawnedAt > 3000) {
				let dx = (player.x + player.size / 2) - triShot.x;
				let dy = (player.y + player.size / 2) - triShot.y;
				let distance = Math.sqrt(dx * dx + dy * dy);
				triShot.vx = (dx / distance) * 2;
				triShot.vy = (dy / distance) * 2;
			}

			// Move triShot
			triShot.x += triShot.vx;
			triShot.y += triShot.vy;

			// Tri Shot collision with player.
			if (checkCollision(triShot, player)) {
			  if (player.shieldCount > 0) {
				// Shield case:
				player.shieldCount--;               // Consume one shield hit
				triShotShieldCount++;               // Increment the triShot shield counter
				triShots.splice(index, 1);          // Remove only the collided triShot

				// When triShotShieldCount reaches 2 or more, remove the boss:
				if (triShotShieldCount >= 2) {
				  // Remove the boss from the game (adjust as needed for your game’s boss removal routine)
				  triGreen.x = canvas.width / 2 - triGreen.size / 2;
				  triGreen.y = canvas.height / 2 - (triGreen.size * 1.2) / 2; // if height = triGreen.size * 1.2
				  boss = null;
				  triPurple.active = true;
				  triShotShieldCount = 0;             // Reset the triShot shield counter
				}
			  } else {
				// No-shield case:
				bossFail = 1;
				triShots = [];                      // Remove both triShots
				if (boss) {
				  bossState = "yellow";             // Reset boss state to yellow mode
				}
				triShotShieldCount = 0;             // Reset the triShot shield counter
				// Trigger player hit (which will decrement lives and handle respawn)
				handlePlayerHit();
				// (Optionally, break out of the loop if necessary to avoid further processing)
			  }
			}

		});
	}

	// Simple collision detection (adjust the numbers if needed)
	function checkCollision(a, b) {
		// Standard AABB (Axis-Aligned Bounding Box) collision check
		if (
			a.x < b.x + b.size &&
			a.x + a.size > b.x &&
			a.y < b.y + b.size &&
			a.y + a.size > b.y
		) {
			return true;
		}

		// Additional check for triShot collision (if both are triShots)
		if (a.type === "triShot" && b.type === "triShot") {
			let dx = a.x - b.x;
			let dy = a.y - b.y;
			let distance = Math.sqrt(dx * dx + dy * dy);
			return distance < 16; // Collision if within 16 pixels
		}

		return false;
	}

	function handleTriShotCollision(shotA, shotB) {
		if (shotA.bouncing || shotB.bouncing) return; // Ignore if already bouncing

		// Calculate direction between the two shots
		let angle = Math.atan2(shotA.y - shotB.y, shotA.x - shotB.x);

		// Apply opposite velocities for bouncing
		let speed = 3;
		shotA.vx = Math.cos(angle) * speed;
		shotA.vy = Math.sin(angle) * speed;
		shotB.vx = -Math.cos(angle) * speed;
		shotB.vy = -Math.sin(angle) * speed;

		// Mark them as bouncing and set the bounce start time
		shotA.bouncing = true;
		shotB.bouncing = true;
		shotA.bounceStart = Date.now();
		shotB.bounceStart = Date.now();
	}

	// Helper function for firing an orange boss shot.
	function fireBossShotOrange(style, startX, startY, angle, speedMod = 1) {
	  let speed, size;
	  if (style === "large") {
		speed = 3;
		size = 20; // twice the normal shot size
	  } else { // single
		speed = 4.5;
		size = 10;
	  }
	  speed *= speedMod;
	  // If angle not provided, fire directly at player.
	  if (angle === undefined) {
		angle = Math.atan2(player.y + player.size/2 - startX, player.x + player.size/2 - startX);
		// Alternatively, use: 
		angle = Math.atan2(player.y + player.size/2 - startY, player.x + player.size/2 - startX);
	  }
	  let shot = {
		type: "orange",
		style: style,
		x: startX,
		y: startY,
		vx: Math.cos(angle) * speed,
		vy: Math.sin(angle) * speed,
		size: size,
		bounceCount: 0
	  };
	  bossShots.push(shot);
	}
	
	// Update boss shots: movement, collision with boss rocks, shield rings, moat, and player.
	function updateBossShots() {
	  for (let i = bossShots.length - 1; i >= 0; i--) {
		let shot = bossShots[i];
		if (!shot) continue;  // Skip undefined entries.
		
		// For red shots, check if it's time to switch to homing.
		if (shot.type === "red" && !shot.homing) {
		  let elapsed = Date.now() - shot.firedTime;
		  if (elapsed >= shot.straightDuration) {
			shot.homing = true;
		  }
		}
		// If homing, adjust velocity to chase the player.
		if (shot.type === "red" && shot.homing) {
		  let centerPlayerX = player.x + player.size/2;
		  let centerPlayerY = player.y + player.size/2;
		  let dx = centerPlayerX - shot.x;
		  let dy = centerPlayerY - shot.y;
		  let dist = Math.sqrt(dx*dx + dy*dy);
		  if (dist > 0) {
			shot.vx = (dx / dist) * 4.5;
			shot.vy = (dy / dist) * 4.5;
		  }
		}
		
		// Update position.
		shot.x += shot.vx;
		shot.y += shot.vy;
		
		// Boss Shot collision with boss Moat (20px border)
		if (shot.x - shot.size/2 < 20 || shot.y - shot.size/2 < 20 ||
			shot.x + shot.size/2 > canvas.width - 20 || shot.y + shot.size/2 > canvas.height - 20) {
		  shot.remove = true;
		  continue;
		}
		
		// Check collision with boss rocks.
		for (let j = bossRocks.length - 1; j >= 0; j--) {
		  let rock = bossRocks[j];
		  if (bossShotRockCollision(shot, rock)) {
			if (shot.type === "red") {
			  shot.remove = true;
			  break;
			} else if (shot.type === "orange") {
			  if (shot.style === "large") {
				shot.remove = true;
				bossRocks.splice(j, 1);
				break;
			  } else {
				let closestX = clamp(shot.x, rock.x, rock.x + rock.width);
				let closestY = clamp(shot.y, rock.y, rock.y + rock.height);
				let dx = shot.x - closestX;
				let dy = shot.y - closestY;
				let mag = Math.sqrt(dx*dx + dy*dy);
				if (mag > 0) {
				  let nx = dx / mag;
				  let ny = dy / mag;
				  let reflected = reflectVector(shot.vx, shot.vy, nx, ny);
				  shot.vx = reflected.vx;
				  shot.vy = reflected.vy;
				  shot.bounceCount++;
				}
			  }
			} else if (shot.type === "green" || shot.type === "blue") {
			  let closestX = clamp(shot.x, rock.x, rock.x + rock.width);
			  let closestY = clamp(shot.y, rock.y, rock.y + rock.height);
			  let dx = shot.x - closestX;
			  let dy = shot.y - closestY;
			  let mag = Math.sqrt(dx*dx + dy*dy);
			  if (mag > 0) {
				let nx = dx / mag;
				let ny = dy / mag;
				let reflected = reflectVector(shot.vx, shot.vy, nx, ny);
				shot.vx = reflected.vx;
				shot.vy = reflected.vy;
				shot.bounceCount++;
			  }
			}
		  }
		}
		
		// Remove shot if bounce count exceeds 10.
		if (shot.bounceCount > 10) {
		  shot.remove = true;
		}
		
		// Boss Shot collision with player.
		if (circlePlayerCollision(shot.x, shot.y, shot.size/2, player)) {
		  if (shot.type === "green") {
			orbActive = false;
			progress++;
			shot.remove = true;
			setTimeout(spawnorb, 1000);
		  }
		  else if (shot.type === "blue") {
			orbActive = false;
			player.lives = Math.min(player.lives + 1, 999);
			nextLevel();
		  }
		  else if (shot.type === "red" || shot.type === "orange") {
			shot.remove = true;
			// If the player has a shield, reduce the shield count instead of triggering a hit.
			if (player.shieldCount > 0) {
			  player.shieldCount--;
			  console.log("Boss shot absorbed by shield. New shield count: " + player.shieldCount);
			} else {
			  handlePlayerHit();
			}
		  }
		}

	  }
	  bossShots = bossShots.filter(s => s && !s.remove);
	}

	// Draw boss shots.
	function drawBossShots() {
	  bossShots.forEach(shot => {
		ctx.beginPath();
		ctx.arc(shot.x, shot.y, shot.size/2, 0, Math.PI*2);
		if (shot.type === "orange") {
		  ctx.fillStyle = "orange";
		} else if (shot.type === "red") {
		  ctx.fillStyle = "red";
		} else if (shot.type === "green") {
		  ctx.fillStyle = "green";
		} else if (shot.type === "blue") {
		  ctx.fillStyle = "blue";
		}
		ctx.fill();
	  });
	}
	// Draw tri shots as red isosceles triangles pointing in the direction of travel
	function drawTriShots() {
		triShots.forEach(triShot => {
		
			// Draw the purple trail
			ctx.globalAlpha = 0.25; // Semi-transparent effect
			ctx.fillStyle = "purple"; // Trail color

			triShot.trail.forEach((pos, index) => {
				let sizeFactor = (index / triShot.trail.length) * 0.7 + 0.3; // Fades out
				let size = 8 * sizeFactor; // Smaller towards the end
				ctx.beginPath();
				ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
				ctx.fill();
			});

			ctx.globalAlpha = 1.0; // Reset transparency		
		
			let { x, y, vx, vy } = triShot;

			// Triangle size
			let base = 16;   // Width of the base
			let height = 24; // Length from base to tip

			// Calculate the angle of movement
			let angle = Math.atan2(vy, vx);

			// Calculate triangle points
			let tipX = x + Math.cos(angle) * height;
			let tipY = y + Math.sin(angle) * height;
			let leftX = x + Math.cos(angle + Math.PI * 2 / 3) * base;
			let leftY = y + Math.sin(angle + Math.PI * 2 / 3) * base;
			let rightX = x + Math.cos(angle - Math.PI * 2 / 3) * base;
			let rightY = y + Math.sin(angle - Math.PI * 2 / 3) * base;

			// Draw the triangle
			ctx.fillStyle = "red";
			ctx.beginPath();
			ctx.moveTo(tipX, tipY);
			ctx.lineTo(leftX, leftY);
			ctx.lineTo(rightX, rightY);
			ctx.closePath();
			ctx.fill();
		});
	}
    
    // When processing orb collision, if the orb is purple or hex, handle accordingly.
    function processorbCollision() {
      orbActive = false;
      resetAllEnemySpeeds();
      if (orb.isHex) {
        // Set progress to 5 (switching from x/5 to x/10 style) then trigger boss fight.
	    player.lives = Math.min(player.lives + 1, 999);
        progress = 5;
        // Remove the orb and trigger boss fight.
        initiateBossFight();
		
		// Purple Power
		} else if (orb.color === PURPLE_COLOR) {
		  purplePower = true;
		  const purpleStartTime = Date.now(); // record when the effect starts
		  const purpleDuration = 15000; // total duration of 15 seconds

		  // Start logging the remaining time immediately
		  const loggingInterval = setInterval(() => {
			let timeLeft = purpleDuration - (Date.now() - purpleStartTime);
			if (timeLeft < 0) timeLeft = 0;
			const sec = Math.floor(timeLeft / 1000);
			const ms = timeLeft % 1000;
			// console.log("Purple power time left: " + sec.toString().padStart(2, '0') + ":" + ms.toString().padStart(3, '0'));
		  }, 1); // log interval ms

		  sqrs.forEach(enemy => {
			if (!enemy.temporarilyPurple) {
			  enemy.originalColor = enemy.color;
			  enemy.color = PURPLE_COLOR;
			  enemy.temporarilyPurple = true;
			}
		  });
		  hudorbIndicator.style.backgroundColor = PURPLE_COLOR;
		  
		  let flashInterval = null;
		  // Start flashing at 13 seconds
		  setTimeout(() => {
			flashInterval = setInterval(() => {
			  sqrs.forEach(enemy => {
				if (enemy.temporarilyPurple) {
				  enemy.color = (enemy.color === PURPLE_COLOR) ? "#E6E6FA" : PURPLE_COLOR;
				}
			  });
			}, 62);
		  }, 13000);
		  
		  // After 15 seconds, clear both intervals and reset enemy colors
		  setTimeout(() => {
			clearInterval(flashInterval);
			clearInterval(loggingInterval);
			sqrs.forEach(enemy => {
			  if (enemy.temporarilyPurple) {
				enemy.color = enemy.originalColor || enemy.color;
				delete enemy.temporarilyPurple;
				delete enemy.originalColor;
			  }
			});
			purplePower = false;
			shieldAwardedForCurrentTempPurple = false;
		  }, purpleDuration);

        setTimeout(spawnorb, 1000);
      } else if (orb.color === "blue") {
        progress++;
        player.lives = Math.min(player.lives + 1, 999);
        hasScored = true;
        if (progress >= 5) {
			nextLevel();
        } else {
          setTimeout(spawnorb, 1000);
        }
      } else { // Green orb
        progress++;
        if (progress >= 5) {
			nextLevel();
        } else {
          setTimeout(spawnorb, 1000);
        }
      }
    }
    
    function resetAllEnemySpeeds() {
      sqrs.forEach(enemy => {
        if (enemy.color === "red") {
          enemy.speedX = Math.sign(enemy.speedX) * RED_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * RED_SPEED;
        } else if (enemy.color === "orange") {
          enemy.speedX = Math.sign(enemy.speedX) * ORANGE_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * ORANGE_SPEED;
        } else {
          enemy.speedX = Math.sign(enemy.speedX) * YELLOW_SPEED;
          enemy.speedY = Math.sign(enemy.speedY) * YELLOW_SPEED;
        }
      });
    }
    
    function updateHUD() {
      hudLife.textContent = player.lives;
      hudLevelElem.textContent = "Level " + player.level;
      // Display progress with denominator 10 during boss fight, else 5.
      if (bossFight) {
        hudLevelProg.textContent = `${progress}/10`;
      } else {
        hudLevelProg.textContent = `${progress}/5`;
      }
      hudLevelProg.appendChild(hudorbIndicator);
      if (player.level > highScore) {
        highScore = player.level;
		localStorage.setItem("highScore", highScore); // Save new high score
      }
      hudHighScore.textContent = highScore;
	  triHud();
    }
    
    // PlayerHit mechanic.
	function handlePlayerHit() {
	  if (!paused) {
	    // Clear trail on death
	    playerTrail = [];
		if (player.shieldCount > 0) {
		  // Shield case: reduce shield count and display "Shield Lost" in purple.
		  player.shieldCount--;
		  messageOverlay.style.color = "purple";
		  messageOverlay.textContent = "Shield Lost";
		} else {
		  // No shield available: subtract a life.
		  player.lives--;
		  shieldRings = [];
		  // Only display "Life Lost" if the player still has lives remaining.
		  if (player.lives > 0) {
			messageOverlay.style.color = "orange";
			messageOverlay.textContent = "Life Lost";
		  }
		}
		
		if (player.lives >= 1) {
		  paused = true;
		  hitCooldown = true;
		  let pos;
		  if (bossFight) {
			let obstacles = [];
			if (boss) obstacles.push({ x: boss.x, y: boss.y, size: boss.size });
			bossRocks.forEach(br => {
			  obstacles.push({ x: br.x, y: br.y, size: br.size });
			});
			pos = getValidBossFightSpawnPosition(player.size, obstacles);
		  } else {
			pos = getValidSpawnPosition(player.size, rocks.concat(sqrs, [orb]));
		  }
		  player.x = pos.x;
		  player.y = pos.y;
		  setTimeout(() => { hitCooldown = false; }, 1000);
		}		
		if (bossFight) {
			if (bossState === "orange") {
				bossFail = 1;
				bossState = "yellow"; // Reset boss state to yellow mode
			}	
		    bossShots = [];
		}
	  }
	}
    
    // Draw a rotated hexagon given center, size, rotation and color.
    function drawBoss(cx, cy, size, rotation, color) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rotation);
      ctx.beginPath();
      let r = size / 2;
      for (let i = 0; i < 6; i++) {
        let angle = i * Math.PI / 3;
        let x = r * Math.cos(angle);
        let y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();
    }
	// Draw triangle centered at (cx,cy).
	function drawTriangle(cx, cy, width, height, color) {
	  ctx.beginPath();
	  ctx.moveTo(cx, cy - height / 2);         // Top vertex
	  ctx.lineTo(cx - width / 2, cy + height / 2); // Bottom left
	  ctx.lineTo(cx + width / 2, cy + height / 2); // Bottom right
	  ctx.closePath();
	  ctx.fillStyle = color;
	  ctx.fill();
	}
	function drawGlowingTriangle(cx, cy, width, height, fillColor, glowColor, glowBlur) {
	  ctx.save();
	  ctx.shadowColor = glowColor;
	  ctx.shadowBlur = glowBlur;
	  ctx.shadowOffsetX = 0;
	  ctx.shadowOffsetY = 0;
	  drawTriangle(cx, cy, width, height, fillColor);
	  ctx.restore();
	}
	
	function drawJoystickOverlay() {
	  if (!touchActive) return;
	  
	  // Convert the initial touch point to canvas coordinates.
	  const rect = canvas.getBoundingClientRect();
	  const centerX = touchStartX - rect.left;
	  const centerY = touchStartY - rect.top;
	  
	  // Joystick parameters
	  const joystickRadius = 75; // outer circle radius
	  const halfRadius = joystickRadius / 2; // cross arm length
	  
	  // Draw the filled circle (75% transparent grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, joystickRadius, 0, Math.PI * 2);
	  ctx.fillStyle = "rgba(64,64,64,0.25)"; // 75% transparent grey
	  ctx.fill();
	  
	  // Draw the circumference stroke (50% transparent dark grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, joystickRadius, 0, Math.PI * 2);
	  ctx.strokeStyle = "rgba(64,64,64,0.5)"; // 50% transparent dark grey
	  ctx.lineWidth = 2;
	  ctx.stroke();
	  
	  // Draw the cross:
	  ctx.beginPath();
	  // Horizontal line
	  ctx.moveTo(centerX - halfRadius, centerY);
	  ctx.lineTo(centerX + halfRadius, centerY);
	  // Vertical line
	  ctx.moveTo(centerX, centerY - halfRadius);
	  ctx.lineTo(centerX, centerY + halfRadius);
	  ctx.strokeStyle = "rgba(64,64,64,0.5)";
	  ctx.lineWidth = 2;
	  ctx.stroke();
	  
	  // Draw the center dot (25% transparent dark grey)
	  ctx.beginPath();
	  ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
	  ctx.fillStyle = "rgba(64,64,64,0.25)";
	  ctx.fill();
	}

    
    // New function: Initiate boss fight by clearing entities, repositioning the player,
    // and creating the boss, bossMoat (drawn as border) and bossRocks.
    function initiateBossFight() {
      bossFight = true;
	  bossFail = 0;
	  bossState = "yellow";
	  hasSpiralFired = false;  // Reset spiral flag for new boss fight
       // Destroy all enemies and obstacles.
      sqrs = [];
      rocks = [];
      mud = [];
      // Create boss in the center.
      boss = {
        x: canvas.width / 2 - 50,
        y: canvas.height / 2 - 50,
        size: 100,
        color: "yellow",
        rotation: 0
      };
      // Create bossRocks.
      bossRocks = [];
      let numBossRocks = Math.floor(Math.random() * 6) + 5; // between 5 and 10
      let bossCenterX = canvas.width / 2;
      let bossCenterY = canvas.height / 2;
      let sizes = [{w:25, h:50}, {w:25, h:75}, {w:50, h:25}, {w:75, h:25}];
      for (let i = 0; i < numBossRocks; i++) {
        let angle = Math.random() * 2 * Math.PI;
        let distance = 175 + Math.random() * (225 - 175);
        let rockPosX = bossCenterX + distance * Math.cos(angle);
        let rockPosY = bossCenterY + distance * Math.sin(angle);
        let chosen = sizes[Math.floor(Math.random() * sizes.length)];
        let corners = getRandomCornerPattern();
        let bossRock = {
          x: rockPosX,
          y: rockPosY,
          width: chosen.w,
          height: chosen.h,
          size: Math.max(chosen.w, chosen.h),
          color: "#222",
          corners: corners
        };
        bossRocks.push(bossRock);
      }
      // Reposition the player so he doesn't start overlapping boss elements.
      let obstacles = [];
      obstacles.push({ x: boss.x, y: boss.y, size: boss.size });
      bossRocks.forEach(br => { obstacles.push({ x: br.x, y: br.y, size: br.size }); });
      let pos = getValidBossFightSpawnPosition(player.size, obstacles);
      player.x = pos.x;
      player.y = pos.y;
	  // Clear the trail when the player is moved.
	  playerTrail = [];
      
      // Pause game and display "Boss Fight" until the player moves.
      paused = true;
      levelPaused = true;
      bossWaitForInput = true;
      messageOverlay.style.color = "orange";
      messageOverlay.textContent = "Boss Fight";
      // Removed controlsLocked here so movement keys can unpause.
    }
    
    function update() { // Main Update loop
      // Save player's previous position for collision rollback.
      let playerPrevX = player.x;
      let playerPrevY = player.y;
	  
	if (player.x !== lastPlayerX || player.y !== lastPlayerY) {
	  // The player moved – update the last move time and store new position.
	  lastPlayerMoveTime = Date.now();
	  lastPlayerX = player.x;
	  lastPlayerY = player.y;
	} else {
	  // The player hasn't moved – if more than 6 seconds have passed, set override.
	  if (Date.now() - lastPlayerMoveTime >= 6000) {
		overrideNextBossShot = true;
	  }
	}	  
	  
       if (player.lives < 1) {
        if (!gameOver) {
          player.lives = 0;
          gameOver = true;
        }
        if (!gameOverPrompted) {
          gameOverPrompted = true;
          setTimeout(() => {
            messageOverlay.innerHTML += "<br><span style='font-size: 24px; color: blue;'>Try again?</span>";
            tryAgainAvailable = true;
          }, 1000);
        }
        return;
      }
      if (gameOver) return;
      if (paused) return;
	  // Update boss rotation if the boss exists.
	  if (boss) {
		boss.rotation += bossRotationSpeed; // bossRotationSpeed is set in updateBossState()
	  }
  
      // Award a shield ring if the temporary purple effect is active,
      // there are no enemies left, a shield hasn't been awarded this cycle,
      // and we have fewer than 3 rings.
      if (purplePower && sqrs.length === 0 && !shieldAwardedForCurrentTempPurple && shieldRings.length < 3) {
        player.shieldCount = Math.min(player.shieldCount + 1, 6);
        shieldAwardedForCurrentTempPurple = true;
		console.log("Area clear - Shield count: " + player.shieldCount);
      }
      // Recalculate shield ring radii using desired values.
      recalcShieldRadii();
      
	  // Purple Triangle Stuff & purpleOrb Power
		let effectivePlayerSpeed = player.speed;
		let addTrail = false;

		if (hasTriPurple === 1 && player.shieldCount >= 1) {
		  // When the purple triangle is active and the player has one or more shields:
		  // Increase speed by 0.5 per shield.
		  effectivePlayerSpeed = Math.min(player.speed + player.shieldCount * 0.5, player.speed + 3);
		  // Bypass mud slowdown.
		  addTrail = true;
		} else if (purplePower) {
		  // Temporary purple orb effect: no mud slowdown.
		  effectivePlayerSpeed = player.speed;
		  addTrail = true;
		} else {
		  // Normal movement: check for mud slowdown.
		  for (let zone of mud) {
			if (isIntersecting(player, zone)) {
			  effectivePlayerSpeed = player.speed * 0.25;
			  break;
			}
		  }
		}

		// Add the purple trail if either purple effect is active.
		if (addTrail) {
		  playerTrail.push({ x: player.x, y: player.y });
		  if (playerTrail.length > TRAIL_LENGTH) {
			playerTrail.shift();
		  }
		} else {
		  // Otherwise, clear the trail.
		  playerTrail = [];
		}
		
      let dx = 0, dy = 0;
      if (keys["ArrowUp"] || keys["w"]) dy -= effectivePlayerSpeed;
      if (keys["ArrowDown"] || keys["s"]) dy += effectivePlayerSpeed;
      if (keys["ArrowLeft"] || keys["a"]) dx -= effectivePlayerSpeed;
      if (keys["ArrowRight"] || keys["d"]) dx += effectivePlayerSpeed;

		// Touch controls: override keyboard input if touch is active
		if (touchActive) {
			// Calculate the magnitude of the touch displacement.
			let mag = Math.sqrt(touchDx * touchDx + touchDy * touchDy);
			// Set a small deadzone to avoid jittering.
			const deadzone = 5;
			if (mag > deadzone) {
				// Normalize the touch vector (direction only).
				let normX = touchDx / mag;
				let normY = touchDy / mag;
				// Move the player at fixed speed.
				dx = normX * player.speed;
				dy = normY * player.speed;
			} else {
				dx = 0;
				dy = 0;
			}
		}
			  
			  let oldX = player.x;
			  player.x += dx;
				// Clyde Mode [2505]
				if (cheatNoWrap) {
				  // Clamp player's x so they cannot move past the canvas edges
				  if (player.x < 0) player.x = 0;
				  if (player.x + player.size > canvas.width) player.x = canvas.width - player.size;
				}	  
			  if (player.x > canvas.width) player.x = -player.size;
			  if (player.x + player.size < 0) player.x = canvas.width;
			  if (isCollidingWithrocks(player)) {
				player.x = oldX;
			  }
		// End Touch Controls
      
      let oldY = player.y;
      player.y += dy;
		if (cheatNoWrap) {
		  // Clamp player's y so they cannot move past the canvas edges
		  if (player.y < 0) player.y = 0;
		  if (player.y + player.size > canvas.height) player.y = canvas.height - player.size;
		}	  
      if (player.y > canvas.height) player.y = -player.size;
      if (player.y + player.size < 0) player.y = canvas.height;
      if (isCollidingWithrocks(player)) {
        player.y = oldY;
      }
      
      if (orbActive &&
          player.x < orb.x + orb.size &&
          player.x + player.size > orb.x &&
          player.y < orb.y + orb.size &&
          player.y + player.size > orb.y) {
        processorbCollision();
      }
      
      sqrs.forEach((sqr, index) => {
	  
	  // NEW: For yellow sqrs, choose a new random direction every 5-10 seconds.
	  if (sqr.color === "yellow") {
		// If this property hasn't been set yet, initialize it.
		if (!sqr.nextDirectionChange) {
		  sqr.nextDirectionChange = Date.now() + (5000 + Math.random() * 5000);
		}
		// If the current time is past the set time, update the direction.
		if (Date.now() > sqr.nextDirectionChange) {
		  let newAngle = getRandomAngle();
		  sqr.speedX = Math.cos(newAngle) * YELLOW_SPEED;
		  sqr.speedY = Math.sin(newAngle) * YELLOW_SPEED;
		  // Set the next direction change time between 5-10 seconds from now.
		  sqr.nextDirectionChange = Date.now() + (5000 + Math.random() * 5000);
		}
	  }	  
	  
		if (orbActive &&
			sqr.x < orb.x + orb.size &&
			sqr.x + sqr.size > orb.x &&
			sqr.y < orb.y + orb.size &&
			sqr.y + sqr.size > orb.y) {

		  if (orb.color === "blue" || orb.isHex) {
			  // Spawn a full-sized yellow sqr at this location
			  let newSqr = {
			  x: sqr.x,
			  y: sqr.y,
			  size: YELLOW_SIZE,
			  color: "yellow",
			  speedX: Math.cos(getRandomAngle()) * YELLOW_SPEED,
			  speedY: Math.sin(getRandomAngle()) * YELLOW_SPEED
			};

			// Add the new sqr to the enemy list
			sqrs.push(newSqr);

			// Remove the blue orb and spawn a new one after a delay
			orbActive = false;
			setTimeout(spawnorb, 1000);

			} else {
			  // Default behavior for other orbs (green, purple, etc.)
			  orbActive = false;
			  resetAllEnemySpeeds();
			  if (orb.color === PURPLE_COLOR) {
				hudorbIndicator.style.backgroundColor = PURPLE_COLOR;
				// Kill the square by removing it from the array.
				sqrs.splice(index, 1);
			  } else if (sqr.color === "yellow") {
				sqr.color = "orange";
				sqr.size = ORANGE_SIZE;
				let angle = Math.atan2(sqr.speedY, sqr.speedX);
				sqr.speedX = Math.cos(angle) * ORANGE_SPEED;
				sqr.speedY = Math.sin(angle) * ORANGE_SPEED;
			  } else if (sqr.color === "orange") {
				sqr.color = "red";
				sqr.size = RED_SIZE;
				let angle = Math.atan2(sqr.speedY, sqr.speedX);
				sqr.speedX = Math.cos(angle) * RED_SPEED;
				sqr.speedY = Math.sin(angle) * RED_SPEED;
			  } else if (sqr.color === "red") {
				progress = Math.max(0, progress - 1);
				orb.color = "green";
			  }
			  setTimeout(spawnorb, 1000);
			}

		}
        
        if (sqr.color === "red") {
          let centerPlayerX = player.x + player.size / 2;
          let centerPlayerY = player.y + player.size / 2;
          let centerEnemyX = sqr.x + sqr.size / 2;
          let centerEnemyY = sqr.y + sqr.size / 2;
          let dxTarget = centerPlayerX - centerEnemyX;
          let dyTarget = centerPlayerY - centerEnemyY;
          let dist = Math.sqrt(dxTarget * dxTarget + dyTarget * dyTarget);
          if (dist > 0) {
            sqr.speedX = RED_SPEED * (dxTarget / dist);
            sqr.speedY = RED_SPEED * (dyTarget / dist);
          }
        } else if (sqr.color === "orange") {
          let centerPlayerX = player.x + player.size / 2;
          let centerPlayerY = player.y + player.size / 2;
          let centerEnemyX = sqr.x + sqr.size / 2;
          let centerEnemyY = sqr.y + sqr.size / 2;
          let dxTarget = centerPlayerX - centerEnemyX;
          let dyTarget = centerPlayerY - centerEnemyY;
          let dist = Math.sqrt(dxTarget * dxTarget + dyTarget * dyTarget);
          if (dist > 0) {
            let speedMag = Math.sqrt(sqr.speedX * sqr.speedX + sqr.speedY * sqr.speedY);
            let targetSpeedX = (dxTarget / dist) * speedMag;
            let targetSpeedY = (dyTarget / dist) * speedMag;
            sqr.speedX = sqr.speedX * 0.5 + targetSpeedX * 0.5;
            sqr.speedY = sqr.speedY * 0.5 + targetSpeedY * 0.5;
          }
        }
      
        let slowdownMultiplier = 1;
        for (let zone of mud) {
          if (isIntersecting({ x: sqr.x, y: sqr.y, size: sqr.size }, zone)) {
            slowdownMultiplier = 0.25;
            break;
          }
        }
        let effectiveSpeedX = sqr.speedX * slowdownMultiplier;
        let effectiveSpeedY = sqr.speedY * slowdownMultiplier;
      
        let prevX = sqr.x, prevY = sqr.y;
        sqr.x += effectiveSpeedX;
        sqr.y += effectiveSpeedY;
      
		for (let obs of rocks) {
		  if (
			sqr.x < obs.x + obs.width &&
			sqr.x + sqr.size > obs.x &&
			sqr.y < obs.y + obs.height &&
			sqr.y + sqr.size > obs.y
		  ) {
			// Reset position to the previous location
			sqr.x = prevX;
			sqr.y = prevY;
			
			if (sqr.color === "yellow") {
			  // For yellow sqrs, choose a new random direction for bounce.
			  let newAngle = getRandomAngle();
			  sqr.speedX = Math.cos(newAngle) * YELLOW_SPEED;
			  sqr.speedY = Math.sin(newAngle) * YELLOW_SPEED;
			} else {
			  // For other colors, reverse the current direction.
			  sqr.speedX = -sqr.speedX;
			  sqr.speedY = -sqr.speedY;
			}
			
			// Ensure the speed is not too low.
			let baseSpeed = (sqr.color === "red") ? RED_SPEED : ((sqr.color === "orange") ? ORANGE_SPEED : YELLOW_SPEED);
			if (Math.abs(sqr.speedX) < baseSpeed * 0.5) {
			  sqr.speedX = baseSpeed * Math.sign(sqr.speedX || 1);
			}
			if (Math.abs(sqr.speedY) < baseSpeed * 0.5) {
			  sqr.speedY = baseSpeed * Math.sign(sqr.speedY || 1);
			}
			
			// Update position with the new speed.
			sqr.x += sqr.speedX;
			sqr.y += sqr.speedY;
			break;
		  }
		}
		
        if (sqr.x <= 0 || sqr.x >= canvas.width - sqr.size) {
          sqr.speedX = -sqr.speedX;
          sqr.x += sqr.speedX;
        }
        if (sqr.y <= 0 || sqr.y >= canvas.height - sqr.size) {
          sqr.speedY = -sqr.speedY;
          sqr.y += sqr.speedY;
        }
		if (
		  player.x < sqr.x + sqr.size &&
		  player.x + player.size > sqr.x &&
		  player.y < sqr.y + sqr.size &&
		  player.y + player.size > sqr.y
		) {
		  if (sqr.temporarilyPurple) {
			sqr.toRemove = true;
		  } else if (player.shieldCount > 0) {
			// If shields are active, consume one shield and remove the sqr
			player.shieldCount--;
			sqr.toRemove = true;
			console.log("Sqr collision - Shield count: " + player.shieldCount);
		  } else {
			// Otherwise, no shield available so process a normal hit
			handlePlayerHit();
		  }
		}
      });
      
      // Remove any enemies marked for removal.
      sqrs = sqrs.filter(enemy => !enemy.toRemove);
      
      // Boss fight collisions.
      if (bossFight) {
	  if (!paused) {
		// If no boss rocks remain, set boss color to orange.
		if (bossRocks.length === 0) {

		  	updateBossState();
		}
	  }
        // Player collision with Boss (using bounding box).
        if (boss &&
            player.x < boss.x + boss.size &&
            player.x + player.size > boss.x &&
            player.y < boss.y + boss.size &&
            player.y + player.size > boss.y) {
			if (bossState !== "yellow") {
				bossFail = 1;
				bossState = "yellow";
				triShots = [];
			}
          handlePlayerHit();
        }
        // Player collision with bossMoat (20px border around canvas).
        if (player.x < 20 ||
            player.y < 20 ||
            player.x + player.size > canvas.width - 20 ||
            player.y + player.size > canvas.height - 20) {
			if (bossState !== "yellow") {
				bossFail = 1;
				bossState = "yellow";
				triShots = [];
			}			
            handlePlayerHit();
        }
        // Check collision with bossRocks (behave as normal rocks).
		// Handle bossRock collisions separately along each axis.
		let tentativeX = player.x; // player.x has been updated by dx already.
		let tentativeY = player.y; // player.y has been updated by dy already.

		// First, check horizontal collision by testing new x with previous y.
		if (isCollidingWithBossRocks({ x: tentativeX, y: playerPrevY, size: player.size })) {
		  tentativeX = playerPrevX;
		}

		// Next, check vertical collision using the (possibly adjusted) x and new y.
		if (isCollidingWithBossRocks({ x: tentativeX, y: tentativeY, size: player.size })) {
		  tentativeY = playerPrevY;
		}

		player.x = tentativeX;
		player.y = tentativeY;
	  
		// Fire a new boss shot if the timer has expired.
		if (bossState === "yellow") {
		  let currentTime = Date.now();
		  if (currentTime - lastBossShotTime >= bossShotInterval) {
			fireBossShot();
			scheduleNextBossShot();
		  }
		}
		// Update existing boss shots.
		updateBossShots();
		updateTriShots();
      }
		checkTriGreenCollision();
		checkTriBlueCollision();
		checkTriPurpleCollision();
    } // End main-update loop
    
    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
    
    function drawrock(obs) {
      const { x, y, width, height, corners } = obs;
      const radius = Math.min(width, height) / 4;
      ctx.beginPath();
      if (corners[0]) {
        ctx.moveTo(x + radius, y);
      } else {
        ctx.moveTo(x, y);
      }
      if (corners[1]) {
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      } else {
        ctx.lineTo(x + width, y);
      }
      if (corners[2]) {
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      } else {
        ctx.lineTo(x + width, y + height);
      }
      if (corners[3]) {
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      } else {
        ctx.lineTo(x, y + height);
      }
      if (corners[0]) {
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
      } else {
        ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    function draw() { // Main Draw Loop
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      mud.forEach(zone => {
        ctx.fillStyle = zone.color;
        drawRoundedRect(zone.x, zone.y, zone.width, zone.height, 20);
      });
      rocks.forEach(obs => {
        ctx.fillStyle = obs.color;
        drawrock(obs);
      });
      if (gameOver) {
        ctx.textAlign = "center";
        ctx.font = "bold 30px Arial";
        ctx.fillStyle = "red";
        ctx.lineWidth = 3;
        ctx.strokeStyle = "black";
        ctx.strokeText("GAME OVER", canvas.width / 2, canvas.height / 2);
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
        return;
      }
	  
		// Draw player trail if purple power-up is active
		if (purplePower || (hasTriPurple === 1 && player.shieldCount >= 1)) {
		  ctx.globalAlpha = 0.25; // Semi-transparent effect
		  ctx.fillStyle = PURPLE_COLOR; // Use the same purple as the power-up

		  playerTrail.forEach((pos, index) => {
			let size = player.size * ((index / TRAIL_LENGTH) * 0.7 + 0.3);
			ctx.fillRect(pos.x + (player.size - size) / 2, pos.y + (player.size - size) / 2, size, size);
		  });

		  ctx.globalAlpha = 1.0; // Reset transparency
		}
		
		ctx.fillStyle = playerIsPink ? "#FFB7CE" : "white";
		ctx.fillRect(player.x, player.y, player.size, player.size);
      if (orbActive) {
        if (orb.isHex) {
          // Draw hex orb as a blue hexagon.
          drawBoss(orb.x + orb.size / 2, orb.y + orb.size / 2, orb.size, 0, orb.color);
        } else {
          ctx.fillStyle = orb.color;
          ctx.beginPath();
          ctx.arc(orb.x + orb.size / 2, orb.y + orb.size / 2, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      sqrs.forEach(sqr => {
        ctx.fillStyle = sqr.color;
        ctx.fillRect(sqr.x, sqr.y, sqr.size, sqr.size);
		// Green Arrow Power
		// If the game is paused, draw the directional indicator.
		  if (paused && hasGreenArrow === 1) {
			const centerX = sqr.x + sqr.size / 2;
			const centerY = sqr.y + sqr.size / 2;
			const angle = Math.atan2(sqr.speedY, sqr.speedX);
			const arrowLength = sqr.size / 2;

			// Draw the line indicating direction.
			ctx.strokeStyle = "green";
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(centerX, centerY);
			ctx.lineTo(centerX + arrowLength * Math.cos(angle),
					   centerY + arrowLength * Math.sin(angle));
			ctx.stroke();

			// Draw the arrowhead.
			const arrowHeadLength = 5; // Increase this for a larger arrowhead
			const arrowSpread = Math.PI / 2.5; // Increase this to make the arrowhead wider (e.g., 45 degrees)

			ctx.beginPath();
			ctx.moveTo(centerX + arrowLength * Math.cos(angle),
					   centerY + arrowLength * Math.sin(angle));
			ctx.lineTo(centerX + (arrowLength - arrowHeadLength) * Math.cos(angle + arrowSpread),
					   centerY + (arrowLength - arrowHeadLength) * Math.sin(angle + arrowSpread));
			ctx.lineTo(centerX + (arrowLength - arrowHeadLength) * Math.cos(angle - arrowSpread),
					   centerY + (arrowLength - arrowHeadLength) * Math.sin(angle - arrowSpread));
			ctx.closePath();
			ctx.fillStyle = "green";
			ctx.fill();
		  }
      });
	  
	  drawTriPower() // Draw Power Triangles
	  
		// Draw shield rings around the player based on player.shieldCount.
		// There are up to 3 rings; each ring gets "activated" at an odd count and "lighter" at the next even count.
		const centerX = player.x + player.size / 2;
		const centerY = player.y + player.size / 2;
		for (let i = 0; i < 3; i++) {
		  // The i-th ring is activated if shieldCount is at least (i*2 + 1)
		  if (player.shieldCount >= i * 2 + 1) {
			// If shieldCount is at least (i*2 + 2), the ring is drawn in dark purple; otherwise, in normal purple.
			let ringColor = (player.shieldCount >= i * 2 + 2) ? PURPLE_COLOR : DARK_PURPLE;
			ctx.strokeStyle = ringColor;
			ctx.lineWidth = shieldThickness;  // Use your defined shieldThickness
			ctx.beginPath();
			ctx.arc(centerX, centerY, desiredRadii[i], 0, Math.PI * 2);
			ctx.stroke();
		  }
		}
      
      // Draw boss fight elements if active.
      if (bossFight) {
        // Draw bossMoat: a 20px red border around the canvas.
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, canvas.width, 20); // Top border
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20); // Bottom border
        ctx.fillRect(0, 0, 20, canvas.height); // Left border
        ctx.fillRect(canvas.width - 20, 0, 20, canvas.height); // Right border
  
        // Draw Boss.
        if (boss) {
			drawBoss(boss.x + boss.size / 2, boss.y + boss.size / 2, boss.size, boss.rotation, boss.color);
			}		
		}
	
       	// Draw bossShots and triShots.
		drawBossShots();
		drawTriShots();
		
        // Draw bossRocks.
        bossRocks.forEach(br => {
          ctx.fillStyle = br.color;
          drawrock(br);
        });
      }
    
	let lastUpdateTime = 0;
	function gameLoop(timestamp) {
	  if (!lastUpdateTime) {
		lastUpdateTime = timestamp;
	  }
	  const delta = timestamp - lastUpdateTime;
	  // Only update if at least ~16.67ms have passed (about 60fps)
	  if (delta >= 15) {
		update();
		draw();
		updateHUD();
		lastUpdateTime = timestamp;
	  }
	  if (touchActive) {
		drawJoystickOverlay();
	  }	  
	  requestAnimationFrame(gameLoop);
	}
    
    function restartGame() {
      hudorbIndicator.style.backgroundColor = "grey";
      let pos = getValidSpawnPosition(player.size);
      player = { x: pos.x, y: pos.y, size: 20, speed: basePlayerSpeed, lives: 1, level: 1, shieldCount: 0 };
      progress = 0;
      hasScored = false;
      paused = true;
      levelPaused = true;
      gameOver = false;
      gameOverPrompted = false;
      tryAgainAvailable = false;
      orbActive = true;
      manualPause = false;
      manualPauseTimer = null;
      manualPauseLocked = false;
      messageOverlay.style.color = "blue";
      messageOverlay.textContent = `Level ${player.level}`;
      controlsLocked = true;
      setTimeout(() => { controlsLocked = false; }, 1000);
      // Reset shield-related variables.
      shieldRings = [];
      shieldAwardedForCurrentTempPurple = false;
      purplePower = false;
      // Reset boss fight state if any.
      bossFight = false;
      boss = null;
      bossRocks = [];
      spawnmud();
      spawnrocks();
	  spawnsqrs();
      spawnorb();
	  // Reset boss fight state if any.
	  bossFight = false;
	  boss = null;
	  bossRocks = [];
	  bossShots = [];
    }
	
	// Clear Local Data
	function resetGameData() {
		localStorage.clear();
		location.reload(); // Refresh the game to apply changes
	}
    
    restartGame();
    gameLoop();
    
    setInterval(resetAllEnemySpeeds, 1000);
    
    let keys = {};
    document.addEventListener("keydown", (event) => {
      // If in a boss fight and waiting for input, allow movement keys to unpause
		  if (
			bossFight &&
			bossWaitForInput &&
			["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(event.key) &&
			!event.repeat
		  ) {
			bossWaitForInput = false;
			paused = false;
			levelPaused = false;
			messageOverlay.textContent = "";
		  } else if (controlsLocked) {
			return;
		  }
      keys[event.key] = true;
      
      const leftKey = keys["ArrowLeft"] || keys["a"];
      const rightKey = keys["ArrowRight"] || keys["d"];
      if (!manualPause && leftKey && rightKey && !boss) {
        if (!manualPauseTimer) {
          manualPauseTimer = setTimeout(() => {
            if ((keys["ArrowLeft"] || keys["a"]) && (keys["ArrowRight"] || keys["d"])) {
              manualPause = true;
              paused = true;
              messageOverlay.style.color = "blue";
              messageOverlay.textContent = "Paused";
              manualPauseTimer = null;
              manualPauseLocked = true;
            }
          }, 1000);
        }
      }
      
      if (manualPause && (keys["ArrowUp"] || keys["w"] || keys["ArrowDown"] || keys["s"] || leftKey || rightKey)) {
        if (!manualPauseLocked) {
          manualPause = false;
          paused = false;
          messageOverlay.textContent = "";
        }
      }
      
      if (gameOver && tryAgainAvailable) {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d"].includes(event.key)) {
          restartGame();
          return;
        }
      }
      if (!manualPause && !bossWaitForInput && (levelPaused || (paused && !hitCooldown)) && !gameOver) {
        levelPaused = false;
        paused = false;
        messageOverlay.textContent = "";
      }
		// Cheat code detection
		// 0000 - Clear Local
		// 2505 - Clyde Walls
		// 3712 - Sophie Pink 
		if ("0123456789".includes(event.key)) {
			cheatCodeBuffer += event.key;
			// Keep only the last 4 digits
			if (cheatCodeBuffer.length > 4) {
				cheatCodeBuffer = cheatCodeBuffer.slice(-4);
			}
			if (cheatCodeBuffer === "0000") {
			    resetGameData()
			    console.log("Cleared local data");
			}			
			if (cheatCodeBuffer === "2505") {
			    cheatNoWrap = true;
			    console.log("Player wrapping disabled!");
			}			
			if (cheatCodeBuffer === "3712") {
				playerIsPink = true;
				console.log("You are now pink!");
			}
		}
		});
    document.addEventListener("keyup", (event) => {
      delete keys[event.key];
      if ((event.key === "ArrowLeft" || event.key === "a" || event.key === "ArrowRight" || event.key === "d") && manualPauseTimer) {
        clearTimeout(manualPauseTimer);
        manualPauseTimer = null;
      }
      if (
        !keys["ArrowLeft"] && !keys["ArrowRight"] && !keys["ArrowUp"] && !keys["ArrowDown"] &&
        !keys["w"] && !keys["a"] && !keys["s"] && !keys["d"]
      ) {
        manualPauseLocked = false;
      }
    });
    
	// ========== Mouse Stuff - Debug Tools ==========

	let leftClickTimer = null;
	let leftClickStartTime = 0;
	let middleClickTimer = null;
	let middleClickStartTime = 0;
	
	canvas.addEventListener('mousedown', function(event) {
		let rect = canvas.getBoundingClientRect();
		let mouseX = event.clientX - rect.left;
		let mouseY = event.clientY - rect.top;
	  
		// ========== Left Click Stuff ==========
		if (event.button === 0 && debug) {
		  // If left click is on the player, start the long click timer.
		  if (mouseX >= player.x && mouseX <= player.x + player.size &&
			  mouseY >= player.y && mouseY <= player.y + player.size) {
			leftClickStartTime = Date.now();
			leftClickTimer = setTimeout(() => {
			  player.lives = 999;
			  console.log("Lives set to 999");
			  leftClickTimer = null;
			}, 1000);
			event.preventDefault();
			return;
		  }
		  // Debug-only: Check if orb is clicked to trigger debugSkipLevels(1)
		  if (orbActive && debug) {
			let orbCenterX = orb.x + orb.size / 2;
			let orbCenterY = orb.y + orb.size / 2;
			let dx = mouseX - orbCenterX;
			let dy = mouseY - orbCenterY;
			if (Math.sqrt(dx * dx + dy * dy) <= orb.size / 2) {
			  console.log("Level skipped");
			  debugSkipLevels(1);
			  event.preventDefault();
			  return;
			}
		  }
		  // Debug-only: Process clicks on enemy squares (sqrs)
		  if (debug) {
			let enemyFound = false;
			for (let i = 0; i < sqrs.length; i++) {
			  let enemy = sqrs[i];
			  if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
				  mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
				enemyFound = true;
				console.log("Evolved Enemy");
				if (enemy.color === "yellow") {
				  enemy.color = "orange";
				  enemy.size = ORANGE_SIZE;
				  let angle = Math.atan2(enemy.speedY, enemy.speedX);
				  enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
				  enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
				} else if (enemy.color === "orange") {
				  enemy.color = "red";
				  enemy.size = RED_SIZE;
				  let angle = Math.atan2(enemy.speedY, enemy.speedX);
				  enemy.speedX = Math.cos(angle) * RED_SPEED;
				  enemy.speedY = Math.sin(angle) * RED_SPEED;
				} else if (enemy.color === "red") {
				  console.log("Removed enemy");
				  sqrs.splice(i, 1);
				}
				break;
			  }
			}
		  }
		  event.preventDefault();
		  // ========== Right Click Stuff ==========
		} else if (event.button === 2 && debug) { 
				if (orbActive && debug) {
				  let orbCenterX = orb.x + orb.size / 2;
				  let orbCenterY = orb.y + orb.size / 2;
				  let dx = mouseX - orbCenterX;
				  let dy = mouseY - orbCenterY;
				  if (Math.sqrt(dx * dx + dy * dy) <= orb.size / 2) {
					console.log("Jumped 10 levels");
					debugSkipLevels(10);
					event.preventDefault();
					return;
				  }
				}
				if (debug && mouseX >= player.x && mouseX <= player.x + player.size &&
					mouseY >= player.y && mouseY <= player.y + player.size) {
				  console.log("Life removed");
				  player.lives--; 
				  event.preventDefault();
				  return;
				}
				// Debug-only: Process rock removal, mud removal, and enemy modifications.
				if (debug) {
				  for (let i = 0; i < rocks.length; i++) {
					let rock = rocks[i];
					if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						mouseY >= rock.y && mouseY <= rock.y + rock.height) {
					  console.log("Removed rock");
					  rocks.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < bossRocks.length; i++) {
					let rock = bossRocks[i];
					if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						mouseY >= rock.y && mouseY <= rock.y + rock.height) {
					  console.log("Removed boss rock");
					  bossRocks.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < mud.length; i++) {
					let m = mud[i];
					if (mouseX >= m.x && mouseX <= m.x + m.width &&
						mouseY >= m.y && mouseY <= m.y + m.height) {
					  console.log("Removed mud");
					  mud.splice(i, 1);
					  event.preventDefault();
					  return;
					}
				  }
				  for (let i = 0; i < sqrs.length; i++) {
					let enemy = sqrs[i];
					if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
						mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
					  console.log("Devolved enemy");
					  if (enemy.color === "red") {
						enemy.color = "orange";
						enemy.size = ORANGE_SIZE;
						let angle = Math.atan2(enemy.speedY, enemy.speedX);
						enemy.speedX = Math.cos(angle) * ORANGE_SPEED;
						enemy.speedY = Math.sin(angle) * ORANGE_SPEED;
					  } else if (enemy.color === "orange") {
						enemy.color = "yellow";
						enemy.size = YELLOW_SIZE;
						let angle = Math.atan2(enemy.speedY, enemy.speedX);
						enemy.speedX = Math.cos(angle) * YELLOW_SPEED;
						enemy.speedY = Math.sin(angle) * YELLOW_SPEED;
					  } else if (enemy.color === "yellow") {
						console.log("Removed enemy");
						sqrs.splice(i, 1);
					  }
					  event.preventDefault();
					  return;
					}
				  }
				  // Debug-only: If no enemy was clicked, spawn a new enemy.
				  console.log("Spawned an enemy");
				  let angle = getRandomAngle();
				  let newEnemy = {
					x: mouseX - YELLOW_SIZE / 2,
					y: mouseY - YELLOW_SIZE / 2,
					size: YELLOW_SIZE,
					color: "yellow",
					speedX: Math.cos(angle) * YELLOW_SPEED,
					speedY: Math.sin(angle) * YELLOW_SPEED
				  };
				  sqrs.push(newEnemy);
				  event.preventDefault();
				}
						
				// ========== Middle Click Stuff ==========
				} else if (event.button === 1) {
				  if (debug) {  // Only execute debug features when debug === 1.
					// If middle click is on the player, start a long click timer.
					if (mouseX >= player.x && mouseX <= player.x + player.size &&
						mouseY >= player.y && mouseY <= player.y + player.size) {
					  middleClickStartTime = Date.now();
					  middleClickTimer = setTimeout(() => {
						player.shieldCount = 999;
						console.log("Shields to full! - Shield count: " + player.shieldCount);
						middleClickTimer = null;
					  }, 1000);
					  event.preventDefault();
					  return;
					}
					// Otherwise, if orb is active, cycle its colour.
					if (orbActive) {
					  let orbCenterX = orb.x + orb.size / 2;
					  let orbCenterY = orb.y + orb.size / 2;
					  let dx = mouseX - orbCenterX;
					  let dy = mouseY - orbCenterY;
					  if (Math.sqrt(dx * dx + dy * dy) <= orb.size / 2) {
						console.log("Cycled orb colour");
						if (orb.color === "green" && !orb.isHex) {
						  orb.color = "blue";
						  orb.isHex = false;
						} else if (orb.color === "blue" && !orb.isHex) {
						  orb.color = PURPLE_COLOR;
						  orb.isHex = false;
						} else if (orb.color === PURPLE_COLOR) {
						  orb.color = "blue";
						  orb.isHex = true;
						} else if (orb.isHex) {
						  orb.color = "green";
						  orb.isHex = false;
						}
						event.preventDefault();
						return;
					  }
					}
					// Debug-only: Process middle click on enemy squares (sqrs) to remove all enemies.
					for (let i = 0; i < sqrs.length; i++) {
					  let enemy = sqrs[i];
					  if (mouseX >= enemy.x && mouseX <= enemy.x + enemy.size &&
						  mouseY >= enemy.y && mouseY <= enemy.y + enemy.size) {
						console.log("Removed all enemies");
						sqrs = [];
						event.preventDefault();
						return;
					  }
					}
					// NEW FEATURE: If middle click is on a rock or boss rock, remove all rocks and boss rocks.
					let hitRock = false;
					for (let i = 0; i < rocks.length; i++) {
					  let rock = rocks[i];
					  if (mouseX >= rock.x && mouseX <= rock.x + rock.width &&
						  mouseY >= rock.y && mouseY <= rock.y + rock.height) {
						hitRock = true;
						break;
					  }
					}
					if (!hitRock) {
					  for (let i = 0; i < bossRocks.length; i++) {
						let bossRock = bossRocks[i];
						if (mouseX >= bossRock.x && mouseX <= bossRock.x + bossRock.width &&
							mouseY >= bossRock.y && mouseY <= bossRock.y + bossRock.height) {
						  hitRock = true;
						  break;
						}
					  }
					}
					if (hitRock) {
					  console.log("Removed all rocks");
					  rocks = [];
					  bossRocks = [];
					  event.preventDefault();
					  return;
					}
				  }
				  event.preventDefault();
				}
		});
		// End of Debug Click Features
		
		// Boss debug clicks
		function evolveBoss() {
			if (!boss || !bossFight) return; // No boss to evolve

			if (bossState === "yellow") {
				bossState = "orange";
				updateBossState();
				console.log("Boss evolved to orange!");
			} else if (bossState === "orange") {
				bossState = "red";
				updateBossState();
				console.log("Boss evolved to red!");
			} else if (bossState === "red") {
				console.log("Boss defeated!");
				boss = null;
				bossState = null;
				bossFight = false;
				bossRocks = [];
				bossShots = [];
				levelPaused = false;
				paused = false;
				messageOverlay.textContent = "";
			}
		}

		canvas.addEventListener("click", function(event) {
			if (!boss || !bossFight) return; // Do nothing if no boss is present

			let rect = canvas.getBoundingClientRect();
			let mouseX = event.clientX - rect.left;
			let mouseY = event.clientY - rect.top;

			// Check if the click is inside the boss
			if (
				mouseX >= boss.x &&
				mouseX <= boss.x + boss.size &&
				mouseY >= boss.y &&
				mouseY <= boss.y + boss.size
			) {
				evolveBoss();
			}
		});
	
	canvas.addEventListener("mouseup", function(event) {
	  if (event.button === 0 && debug) {
		if (leftClickTimer) {
		  clearTimeout(leftClickTimer);
		  leftClickTimer = null;
		  player.lives = Math.min(player.lives + 1, 999);
		  console.log("Life added");
		  event.preventDefault();
		}
	  }
	});
	
	canvas.addEventListener("mouseup", function(event) {
	  if (event.button === 1 && debug) {
		if (middleClickTimer) {
		  clearTimeout(middleClickTimer);
		  middleClickTimer = null;
		  player.shieldCount++;
		  console.log("Shields up! - Shield count: " + player.shieldCount);
		  event.preventDefault();
		}
	  }
	});
    
	function debugSkipLevels(levelsToSkip) {
	  if (levelsToSkip === 10) {
		// Calculate the next multiple of 10.
		// (player.level + 1) ensures that if you're exactly on a multiple (e.g., 10),
		// you will jump to the next one (20).
		player.level = Math.ceil((player.level + 1) / 10) * 10;
	  } else {
		player.level += levelsToSkip;
	  }
	  clearPurplePower();
	  spawnLevel();
	  clearLevel();
	  levelPaused = true;
	  paused = true;
	  levelMessage();
	}
	triHud(); // Ensure the HUD updates with saved values
  </script>
</body>
</html>
